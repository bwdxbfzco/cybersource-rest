// Code generated by go-swagger; DO NOT EDIT.

package e_m_v_tag_details

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ParseEmvTagsReader is a Reader for the ParseEmvTags structure.
type ParseEmvTagsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *ParseEmvTagsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewParseEmvTagsOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 404:
		result := NewParseEmvTagsNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewParseEmvTagsInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[POST /tss/v2/transactions/emvTagDetails] parseEmvTags", response, response.Code())
	}
}

// NewParseEmvTagsOK creates a ParseEmvTagsOK with default headers values
func NewParseEmvTagsOK() *ParseEmvTagsOK {
	return &ParseEmvTagsOK{}
}

/*
ParseEmvTagsOK describes a response with status code 200, with default header values.

Successful response.
*/
type ParseEmvTagsOK struct {
	Payload *ParseEmvTagsOKBody
}

// IsSuccess returns true when this parse emv tags o k response has a 2xx status code
func (o *ParseEmvTagsOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this parse emv tags o k response has a 3xx status code
func (o *ParseEmvTagsOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this parse emv tags o k response has a 4xx status code
func (o *ParseEmvTagsOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this parse emv tags o k response has a 5xx status code
func (o *ParseEmvTagsOK) IsServerError() bool {
	return false
}

// IsCode returns true when this parse emv tags o k response a status code equal to that given
func (o *ParseEmvTagsOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the parse emv tags o k response
func (o *ParseEmvTagsOK) Code() int {
	return 200
}

func (o *ParseEmvTagsOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tss/v2/transactions/emvTagDetails][%d] parseEmvTagsOK %s", 200, payload)
}

func (o *ParseEmvTagsOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tss/v2/transactions/emvTagDetails][%d] parseEmvTagsOK %s", 200, payload)
}

func (o *ParseEmvTagsOK) GetPayload() *ParseEmvTagsOKBody {
	return o.Payload
}

func (o *ParseEmvTagsOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ParseEmvTagsOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewParseEmvTagsNotFound creates a ParseEmvTagsNotFound with default headers values
func NewParseEmvTagsNotFound() *ParseEmvTagsNotFound {
	return &ParseEmvTagsNotFound{}
}

/*
ParseEmvTagsNotFound describes a response with status code 404, with default header values.

The specified resource not found in the system.
*/
type ParseEmvTagsNotFound struct {
}

// IsSuccess returns true when this parse emv tags not found response has a 2xx status code
func (o *ParseEmvTagsNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this parse emv tags not found response has a 3xx status code
func (o *ParseEmvTagsNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this parse emv tags not found response has a 4xx status code
func (o *ParseEmvTagsNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this parse emv tags not found response has a 5xx status code
func (o *ParseEmvTagsNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this parse emv tags not found response a status code equal to that given
func (o *ParseEmvTagsNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the parse emv tags not found response
func (o *ParseEmvTagsNotFound) Code() int {
	return 404
}

func (o *ParseEmvTagsNotFound) Error() string {
	return fmt.Sprintf("[POST /tss/v2/transactions/emvTagDetails][%d] parseEmvTagsNotFound", 404)
}

func (o *ParseEmvTagsNotFound) String() string {
	return fmt.Sprintf("[POST /tss/v2/transactions/emvTagDetails][%d] parseEmvTagsNotFound", 404)
}

func (o *ParseEmvTagsNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewParseEmvTagsInternalServerError creates a ParseEmvTagsInternalServerError with default headers values
func NewParseEmvTagsInternalServerError() *ParseEmvTagsInternalServerError {
	return &ParseEmvTagsInternalServerError{}
}

/*
ParseEmvTagsInternalServerError describes a response with status code 500, with default header values.

Unexpected server error
*/
type ParseEmvTagsInternalServerError struct {
}

// IsSuccess returns true when this parse emv tags internal server error response has a 2xx status code
func (o *ParseEmvTagsInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this parse emv tags internal server error response has a 3xx status code
func (o *ParseEmvTagsInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this parse emv tags internal server error response has a 4xx status code
func (o *ParseEmvTagsInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this parse emv tags internal server error response has a 5xx status code
func (o *ParseEmvTagsInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this parse emv tags internal server error response a status code equal to that given
func (o *ParseEmvTagsInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the parse emv tags internal server error response
func (o *ParseEmvTagsInternalServerError) Code() int {
	return 500
}

func (o *ParseEmvTagsInternalServerError) Error() string {
	return fmt.Sprintf("[POST /tss/v2/transactions/emvTagDetails][%d] parseEmvTagsInternalServerError", 500)
}

func (o *ParseEmvTagsInternalServerError) String() string {
	return fmt.Sprintf("[POST /tss/v2/transactions/emvTagDetails][%d] parseEmvTagsInternalServerError", 500)
}

func (o *ParseEmvTagsInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*
ParseEmvTagsBody parse emv tags body
swagger:model ParseEmvTagsBody
*/
type ParseEmvTagsBody struct {

	// An array of objects, each containing a requestId and the corresponding emvRequestCombinedTags
	//
	// Required: true
	EmvDetailsList []*ParseEmvTagsParamsBodyEmvDetailsListItems0 `json:"emvDetailsList"`

	// Number of tags to parse for each EMV tag string provided.
	//
	ParsedTagLimit int64 `json:"parsedTagLimit,omitempty"`

	// Identifies the service requesting parsing
	//
	// Required: true
	Requestor *string `json:"requestor"`
}

// Validate validates this parse emv tags body
func (o *ParseEmvTagsBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmvDetailsList(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsBody) validateEmvDetailsList(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"emvDetailsList", "body", o.EmvDetailsList); err != nil {
		return err
	}

	for i := 0; i < len(o.EmvDetailsList); i++ {
		if swag.IsZero(o.EmvDetailsList[i]) { // not required
			continue
		}

		if o.EmvDetailsList[i] != nil {
			if err := o.EmvDetailsList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "emvDetailsList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "emvDetailsList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *ParseEmvTagsBody) validateRequestor(formats strfmt.Registry) error {

	if err := validate.Required("body"+"."+"requestor", "body", o.Requestor); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this parse emv tags body based on the context it is used
func (o *ParseEmvTagsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmvDetailsList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsBody) contextValidateEmvDetailsList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.EmvDetailsList); i++ {

		if o.EmvDetailsList[i] != nil {

			if swag.IsZero(o.EmvDetailsList[i]) { // not required
				return nil
			}

			if err := o.EmvDetailsList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("body" + "." + "emvDetailsList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("body" + "." + "emvDetailsList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ParseEmvTagsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ParseEmvTagsBody) UnmarshalBinary(b []byte) error {
	var res ParseEmvTagsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ParseEmvTagsOKBody tssV2PostEmvTags200Response
swagger:model ParseEmvTagsOKBody
*/
type ParseEmvTagsOKBody struct {

	// An array of objects (one per object in the passed emvDetailsList), each of which contains a fully parsed EMV string
	//
	ParsedEMVTagsList []*ParseEmvTagsOKBodyParsedEMVTagsListItems0 `json:"parsedEMVTagsList"`
}

// Validate validates this parse emv tags o k body
func (o *ParseEmvTagsOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateParsedEMVTagsList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsOKBody) validateParsedEMVTagsList(formats strfmt.Registry) error {
	if swag.IsZero(o.ParsedEMVTagsList) { // not required
		return nil
	}

	for i := 0; i < len(o.ParsedEMVTagsList); i++ {
		if swag.IsZero(o.ParsedEMVTagsList[i]) { // not required
			continue
		}

		if o.ParsedEMVTagsList[i] != nil {
			if err := o.ParsedEMVTagsList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parseEmvTagsOK" + "." + "parsedEMVTagsList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parseEmvTagsOK" + "." + "parsedEMVTagsList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this parse emv tags o k body based on the context it is used
func (o *ParseEmvTagsOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateParsedEMVTagsList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsOKBody) contextValidateParsedEMVTagsList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ParsedEMVTagsList); i++ {

		if o.ParsedEMVTagsList[i] != nil {

			if swag.IsZero(o.ParsedEMVTagsList[i]) { // not required
				return nil
			}

			if err := o.ParsedEMVTagsList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("parseEmvTagsOK" + "." + "parsedEMVTagsList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("parseEmvTagsOK" + "." + "parsedEMVTagsList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ParseEmvTagsOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ParseEmvTagsOKBody) UnmarshalBinary(b []byte) error {
	var res ParseEmvTagsOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ParseEmvTagsOKBodyParsedEMVTagsListItems0 parse emv tags o k body parsed e m v tags list items0
swagger:model ParseEmvTagsOKBodyParsedEMVTagsListItems0
*/
type ParseEmvTagsOKBodyParsedEMVTagsListItems0 struct {

	// An array of objects, where each object contains one parsed tag from the relevant EMV string.
	//
	EmvTagBreakdownList []*ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0 `json:"emvTagBreakdownList"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	RequestID string `json:"requestId,omitempty"`

	// Number of tags parsed
	//
	TotalTags int64 `json:"totalTags,omitempty"`
}

// Validate validates this parse emv tags o k body parsed e m v tags list items0
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmvTagBreakdownList(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0) validateEmvTagBreakdownList(formats strfmt.Registry) error {
	if swag.IsZero(o.EmvTagBreakdownList) { // not required
		return nil
	}

	for i := 0; i < len(o.EmvTagBreakdownList); i++ {
		if swag.IsZero(o.EmvTagBreakdownList[i]) { // not required
			continue
		}

		if o.EmvTagBreakdownList[i] != nil {
			if err := o.EmvTagBreakdownList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("emvTagBreakdownList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("emvTagBreakdownList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0) validateRequestID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestID) { // not required
		return nil
	}

	if err := validate.MaxLength("requestId", "body", o.RequestID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this parse emv tags o k body parsed e m v tags list items0 based on the context it is used
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmvTagBreakdownList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0) contextValidateEmvTagBreakdownList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.EmvTagBreakdownList); i++ {

		if o.EmvTagBreakdownList[i] != nil {

			if swag.IsZero(o.EmvTagBreakdownList[i]) { // not required
				return nil
			}

			if err := o.EmvTagBreakdownList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("emvTagBreakdownList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("emvTagBreakdownList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0) UnmarshalBinary(b []byte) error {
	var res ParseEmvTagsOKBodyParsedEMVTagsListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0 parse emv tags o k body parsed e m v tags list items0 emv tag breakdown list items0
swagger:model ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0
*/
type ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0 struct {

	// Description of tag.
	//
	// Max Length: 400
	Description string `json:"description,omitempty"`

	// Tag length in bytes.
	//
	Length int64 `json:"length,omitempty"`

	// Name of tag.
	//
	// Max Length: 100
	Name string `json:"name,omitempty"`

	// Hexadecimal code of tag.
	//
	// Pattern: ^[0-9A-F]*$
	Tag string `json:"tag,omitempty"`

	// Hexadecimal value contained in the tag, masked data is represented by an 'X'.
	//
	// Max Length: 1998
	// Pattern: ^[0-9A-F|X]*$
	Value string `json:"value,omitempty"`
}

// Validate validates this parse emv tags o k body parsed e m v tags list items0 emv tag breakdown list items0
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTag(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(o.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", o.Description, 400); err != nil {
		return err
	}

	return nil
}

func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("name", "body", o.Name, 100); err != nil {
		return err
	}

	return nil
}

func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) validateTag(formats strfmt.Registry) error {
	if swag.IsZero(o.Tag) { // not required
		return nil
	}

	if err := validate.Pattern("tag", "body", o.Tag, `^[0-9A-F]*$`); err != nil {
		return err
	}

	return nil
}

func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", o.Value, 1998); err != nil {
		return err
	}

	if err := validate.Pattern("value", "body", o.Value, `^[0-9A-F|X]*$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this parse emv tags o k body parsed e m v tags list items0 emv tag breakdown list items0 based on context it is used
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0) UnmarshalBinary(b []byte) error {
	var res ParseEmvTagsOKBodyParsedEMVTagsListItems0EmvTagBreakdownListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ParseEmvTagsParamsBodyEmvDetailsListItems0 parse emv tags params body emv details list items0
swagger:model ParseEmvTagsParamsBodyEmvDetailsListItems0
*/
type ParseEmvTagsParamsBodyEmvDetailsListItems0 struct {

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For information about the individual tags, see the "Application Specification" section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.
	// All other card present information applies only to credit card processing. PIN debit processing is available only
	// on FDC Nashville Global.
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - `56`: Track 1 equivalent data
	//  - `57`: Track 2 equivalent data
	//  - `5A`: Application PAN
	//  - `5F20`: Cardholder name
	//  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)
	//  - `99`: Transaction PIN
	//  - `9F0B`: Cardholder name (extended)
	//  - `9F1F`: Track 1 discretionary data
	//  - `9F20`: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - `95`: Terminal verification results
	//  - `9F10`: Issuer application data
	//  - `9F26`: Application cryptogram
	//
	//
	// #### CyberSource through VisaNet
	// - In Japan: 199 bytes
	// - In other countries: String (252)
	//
	// For Mastercard Transactions, Optionally Tag 9F60 (Authenticated Application Data) and
	// Tag 96 (Kernel Identifier - Terminal) can be included in the Field.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// #### JCN Gateway
	// The following tags must be included:
	// - `4F`: Application identifier
	// - `84`: Dedicated file name
	//
	// Data length: 199 bytes
	//
	// #### All other processors:
	// String (999)
	//
	// #### Used by
	// Authorization: Optional
	// Authorization Reversal: Optional
	// Credit: Optional
	// PIN Debit processing (purchase, credit and reversal): Optional
	//
	// Required: true
	// Max Length: 1998
	EmvRequestCombinedTags *string `json:"emvRequestCombinedTags"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Required: true
	// Max Length: 26
	RequestID *string `json:"requestId"`
}

// Validate validates this parse emv tags params body emv details list items0
func (o *ParseEmvTagsParamsBodyEmvDetailsListItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmvRequestCombinedTags(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ParseEmvTagsParamsBodyEmvDetailsListItems0) validateEmvRequestCombinedTags(formats strfmt.Registry) error {

	if err := validate.Required("emvRequestCombinedTags", "body", o.EmvRequestCombinedTags); err != nil {
		return err
	}

	if err := validate.MaxLength("emvRequestCombinedTags", "body", *o.EmvRequestCombinedTags, 1998); err != nil {
		return err
	}

	return nil
}

func (o *ParseEmvTagsParamsBodyEmvDetailsListItems0) validateRequestID(formats strfmt.Registry) error {

	if err := validate.Required("requestId", "body", o.RequestID); err != nil {
		return err
	}

	if err := validate.MaxLength("requestId", "body", *o.RequestID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this parse emv tags params body emv details list items0 based on context it is used
func (o *ParseEmvTagsParamsBodyEmvDetailsListItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ParseEmvTagsParamsBodyEmvDetailsListItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ParseEmvTagsParamsBodyEmvDetailsListItems0) UnmarshalBinary(b []byte) error {
	var res ParseEmvTagsParamsBodyEmvDetailsListItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
