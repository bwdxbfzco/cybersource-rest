// Code generated by go-swagger; DO NOT EDIT.

package billing_agreements

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BillingAgreementsDeRegistrationReader is a Reader for the BillingAgreementsDeRegistration structure.
type BillingAgreementsDeRegistrationReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *BillingAgreementsDeRegistrationReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewBillingAgreementsDeRegistrationCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewBillingAgreementsDeRegistrationBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewBillingAgreementsDeRegistrationBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[PATCH /pts/v2/billing-agreements/{id}] billingAgreementsDeRegistration", response, response.Code())
	}
}

// NewBillingAgreementsDeRegistrationCreated creates a BillingAgreementsDeRegistrationCreated with default headers values
func NewBillingAgreementsDeRegistrationCreated() *BillingAgreementsDeRegistrationCreated {
	return &BillingAgreementsDeRegistrationCreated{}
}

/*
BillingAgreementsDeRegistrationCreated describes a response with status code 201, with default header values.

Successful response.
*/
type BillingAgreementsDeRegistrationCreated struct {
	Payload *BillingAgreementsDeRegistrationCreatedBody
}

// IsSuccess returns true when this billing agreements de registration created response has a 2xx status code
func (o *BillingAgreementsDeRegistrationCreated) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this billing agreements de registration created response has a 3xx status code
func (o *BillingAgreementsDeRegistrationCreated) IsRedirect() bool {
	return false
}

// IsClientError returns true when this billing agreements de registration created response has a 4xx status code
func (o *BillingAgreementsDeRegistrationCreated) IsClientError() bool {
	return false
}

// IsServerError returns true when this billing agreements de registration created response has a 5xx status code
func (o *BillingAgreementsDeRegistrationCreated) IsServerError() bool {
	return false
}

// IsCode returns true when this billing agreements de registration created response a status code equal to that given
func (o *BillingAgreementsDeRegistrationCreated) IsCode(code int) bool {
	return code == 201
}

// Code gets the status code for the billing agreements de registration created response
func (o *BillingAgreementsDeRegistrationCreated) Code() int {
	return 201
}

func (o *BillingAgreementsDeRegistrationCreated) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/billing-agreements/{id}][%d] billingAgreementsDeRegistrationCreated %s", 201, payload)
}

func (o *BillingAgreementsDeRegistrationCreated) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/billing-agreements/{id}][%d] billingAgreementsDeRegistrationCreated %s", 201, payload)
}

func (o *BillingAgreementsDeRegistrationCreated) GetPayload() *BillingAgreementsDeRegistrationCreatedBody {
	return o.Payload
}

func (o *BillingAgreementsDeRegistrationCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(BillingAgreementsDeRegistrationCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewBillingAgreementsDeRegistrationBadRequest creates a BillingAgreementsDeRegistrationBadRequest with default headers values
func NewBillingAgreementsDeRegistrationBadRequest() *BillingAgreementsDeRegistrationBadRequest {
	return &BillingAgreementsDeRegistrationBadRequest{}
}

/*
BillingAgreementsDeRegistrationBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type BillingAgreementsDeRegistrationBadRequest struct {
	Payload *BillingAgreementsDeRegistrationBadRequestBody
}

// IsSuccess returns true when this billing agreements de registration bad request response has a 2xx status code
func (o *BillingAgreementsDeRegistrationBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this billing agreements de registration bad request response has a 3xx status code
func (o *BillingAgreementsDeRegistrationBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this billing agreements de registration bad request response has a 4xx status code
func (o *BillingAgreementsDeRegistrationBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this billing agreements de registration bad request response has a 5xx status code
func (o *BillingAgreementsDeRegistrationBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this billing agreements de registration bad request response a status code equal to that given
func (o *BillingAgreementsDeRegistrationBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the billing agreements de registration bad request response
func (o *BillingAgreementsDeRegistrationBadRequest) Code() int {
	return 400
}

func (o *BillingAgreementsDeRegistrationBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/billing-agreements/{id}][%d] billingAgreementsDeRegistrationBadRequest %s", 400, payload)
}

func (o *BillingAgreementsDeRegistrationBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/billing-agreements/{id}][%d] billingAgreementsDeRegistrationBadRequest %s", 400, payload)
}

func (o *BillingAgreementsDeRegistrationBadRequest) GetPayload() *BillingAgreementsDeRegistrationBadRequestBody {
	return o.Payload
}

func (o *BillingAgreementsDeRegistrationBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(BillingAgreementsDeRegistrationBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewBillingAgreementsDeRegistrationBadGateway creates a BillingAgreementsDeRegistrationBadGateway with default headers values
func NewBillingAgreementsDeRegistrationBadGateway() *BillingAgreementsDeRegistrationBadGateway {
	return &BillingAgreementsDeRegistrationBadGateway{}
}

/*
BillingAgreementsDeRegistrationBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type BillingAgreementsDeRegistrationBadGateway struct {
	Payload *BillingAgreementsDeRegistrationBadGatewayBody
}

// IsSuccess returns true when this billing agreements de registration bad gateway response has a 2xx status code
func (o *BillingAgreementsDeRegistrationBadGateway) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this billing agreements de registration bad gateway response has a 3xx status code
func (o *BillingAgreementsDeRegistrationBadGateway) IsRedirect() bool {
	return false
}

// IsClientError returns true when this billing agreements de registration bad gateway response has a 4xx status code
func (o *BillingAgreementsDeRegistrationBadGateway) IsClientError() bool {
	return false
}

// IsServerError returns true when this billing agreements de registration bad gateway response has a 5xx status code
func (o *BillingAgreementsDeRegistrationBadGateway) IsServerError() bool {
	return true
}

// IsCode returns true when this billing agreements de registration bad gateway response a status code equal to that given
func (o *BillingAgreementsDeRegistrationBadGateway) IsCode(code int) bool {
	return code == 502
}

// Code gets the status code for the billing agreements de registration bad gateway response
func (o *BillingAgreementsDeRegistrationBadGateway) Code() int {
	return 502
}

func (o *BillingAgreementsDeRegistrationBadGateway) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/billing-agreements/{id}][%d] billingAgreementsDeRegistrationBadGateway %s", 502, payload)
}

func (o *BillingAgreementsDeRegistrationBadGateway) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/billing-agreements/{id}][%d] billingAgreementsDeRegistrationBadGateway %s", 502, payload)
}

func (o *BillingAgreementsDeRegistrationBadGateway) GetPayload() *BillingAgreementsDeRegistrationBadGatewayBody {
	return o.Payload
}

func (o *BillingAgreementsDeRegistrationBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(BillingAgreementsDeRegistrationBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
BillingAgreementsDeRegistrationBadGatewayBody ptsV2ModifyBillingAgreementPost502Response
// Example: {"id":"6981713080281234567890","message":"General system failure.","reason":"SYSTEM_ERROR","status":"SERVER_ERROR","submitTimeUtc":"2023-11-28T14:12:01Z"}
swagger:model BillingAgreementsDeRegistrationBadGatewayBody
*/
type BillingAgreementsDeRegistrationBadGatewayBody struct {

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	// Max Length: 20
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this billing agreements de registration bad gateway body
func (o *BillingAgreementsDeRegistrationBadGatewayBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitTimeUtc(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationBadGatewayBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationBadGateway"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBadGatewayBody) validateSubmitTimeUtc(formats strfmt.Registry) error {
	if swag.IsZero(o.SubmitTimeUtc) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationBadGateway"+"."+"submitTimeUtc", "body", o.SubmitTimeUtc, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration bad gateway body based on context it is used
func (o *BillingAgreementsDeRegistrationBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationBadRequestBody ptsV2ModifyBillingAgreementPost400Response
// Example: {"details":[{"field":"clientReferenceInformation.code","reason":"INVALID_DATA"}],"id":"6981713080281234567890","message":"One or more fields in the request contains invalid data.","reason":"INVALID_DATA","status":"INVALID_REQUEST","submitTimeUtc":"2023-11-28T14:12:01Z"}
swagger:model BillingAgreementsDeRegistrationBadRequestBody
*/
type BillingAgreementsDeRegistrationBadRequestBody struct {

	// details
	Details []*BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0 `json:"details"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - PROCESSOR_UNAVAILABLE
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	// Max Length: 20
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this billing agreements de registration bad request body
func (o *BillingAgreementsDeRegistrationBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitTimeUtc(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("billingAgreementsDeRegistrationBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("billingAgreementsDeRegistrationBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBadRequestBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationBadRequest"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBadRequestBody) validateSubmitTimeUtc(formats strfmt.Registry) error {
	if swag.IsZero(o.SubmitTimeUtc) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationBadRequest"+"."+"submitTimeUtc", "body", o.SubmitTimeUtc, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this billing agreements de registration bad request body based on the context it is used
func (o *BillingAgreementsDeRegistrationBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("billingAgreementsDeRegistrationBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("billingAgreementsDeRegistrationBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBadRequestBody) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0 billing agreements de registration bad request body details items0
swagger:model BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0
*/
type BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this billing agreements de registration bad request body details items0
func (o *BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this billing agreements de registration bad request body details items0 based on context it is used
func (o *BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationBody billing agreements de registration body
// Example: {"aggregatorInformation":{"name":"aggregatorname","subMerchant":{"name":"rupay"}},"agreementInformation":{"eSignIndicator":"y","id":"G8UD2OKG49UW"},"buyerInformation":{"dateOfBirth":"19990101","gender":"F","language":"en"},"clientReferenceInformation":{"code":"TC84105-1"},"consumerAuthenticationInformation":{"authenticationTransactionContextId":"100000000000000000000000025253","transactionToken":"AxjzbwSTcz9aHyOIL490/949UafAxfvksgAxHXa2/+xcVZ0CtA+AbkvF"},"deviceInformation":{"httpAcceptBrowserValue":"http","ipAddress":"10.10.10.10","userAgentBrowserValue":"safari"},"installmentInformation":{"identifier":"1000000","paymentType":"1"},"merchantInformation":{"cancelUrl":"https://www.valid.merchant.redirect.url.from.request.html?actioncancel","failureUrl":"https://www.valid.merchant.redirect.url.from.request.html?actionfailure","successUrl":"https://www.valid.merchant.redirect.url.from.request.html?actionsuccess"},"orderInformation":{"amountDetails":{"currency":"INR","totalAmount":"100.00"},"billTo":{"address1":"808 Metro Blvd","address2":"Suite A101","administrativeArea":"CA","company":"Cybersource Trading Inc.","country":"US","county":"San Francisco","district":"SF","email":"srbuyeroffice@cybs.com","firstName":"Comet","lastName":"Bowditch","locality":"San Francisco","middleName":"Foster","phoneNumber":"16501234567","postalCode":"944041234","title":"Senior Buyer"}},"paymentInformation":{"bank":{"account":{"number":"1234567890ABCDEFGHIJ0123456789"},"iban":"NL51ABNC1122334455","scheme":"bacs","swiftCode":"ABNCNL2AGMK"},"card":{"expirationMonth":"12","expirationYear":"2031","number":"5082794233463","securityCode":"123","type":"061"},"paymentType":{"method":{"name":"SENTENIAL"},"name":"directDebitBacs"}},"processingInformation":{"actionList":["UPDATE_AGREEMENT"],"commerceIndicator":"rpy"}}
swagger:model BillingAgreementsDeRegistrationBody
*/
type BillingAgreementsDeRegistrationBody struct {

	// aggregator information
	AggregatorInformation *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation `json:"aggregatorInformation,omitempty"`

	// agreement information
	AgreementInformation *BillingAgreementsDeRegistrationParamsBodyAgreementInformation `json:"agreementInformation,omitempty"`

	// buyer information
	BuyerInformation *BillingAgreementsDeRegistrationParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// device information
	DeviceInformation *BillingAgreementsDeRegistrationParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// installment information
	InstallmentInformation *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// merchant information
	MerchantInformation *BillingAgreementsDeRegistrationParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *BillingAgreementsDeRegistrationParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *BillingAgreementsDeRegistrationParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// processing information
	ProcessingInformation *BillingAgreementsDeRegistrationParamsBodyProcessingInformation `json:"processingInformation,omitempty"`
}

// Validate validates this billing agreements de registration body
func (o *BillingAgreementsDeRegistrationBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAgreementInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateAggregatorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AggregatorInformation) { // not required
		return nil
	}

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateAgreementInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AgreementInformation) { // not required
		return nil
	}

	if o.AgreementInformation != nil {
		if err := o.AgreementInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "agreementInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "agreementInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateDeviceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateInstallmentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration body based on the context it is used
func (o *BillingAgreementsDeRegistrationBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAggregatorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAgreementInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConsumerAuthenticationInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeviceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstallmentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateAggregatorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AggregatorInformation != nil {

		if swag.IsZero(o.AggregatorInformation) { // not required
			return nil
		}

		if err := o.AggregatorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateAgreementInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AgreementInformation != nil {

		if swag.IsZero(o.AgreementInformation) { // not required
			return nil
		}

		if err := o.AgreementInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "agreementInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "agreementInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {

		if swag.IsZero(o.BuyerInformation) { // not required
			return nil
		}

		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateConsumerAuthenticationInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ConsumerAuthenticationInformation != nil {

		if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
			return nil
		}

		if err := o.ConsumerAuthenticationInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateDeviceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.DeviceInformation != nil {

		if swag.IsZero(o.DeviceInformation) { // not required
			return nil
		}

		if err := o.DeviceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateInstallmentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.InstallmentInformation != nil {

		if swag.IsZero(o.InstallmentInformation) { // not required
			return nil
		}

		if err := o.InstallmentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {

		if swag.IsZero(o.MerchantInformation) { // not required
			return nil
		}

		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {

		if swag.IsZero(o.PaymentInformation) { // not required
			return nil
		}

		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationBody) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBody ptsV2ModifyBillingAgreementPost201Response
// Example: {"_links":{"self":{"href":"GET","method":"/pts/v2/billing/agreements/6853506446826005503878"},"status":{"href":"PATCH","method":"/pts/v2/billing/agreements/6853506446826005503878"}},"agreementInformation":{"dateCreated":"20181009","dateRevoked":"20181009","dateSigned":"20181109","encodedHtml":"PGh0bWw+DQo8Ym9keT4NCiANCjxwPjxiPlRoaXMgdGV4dCBpcyBib2xkPC9iPjwvcD4NCjxwPjxpPlRoaXMgdGV4dCBpcyBpdGFsaWM8L2k+PC9wPg0KPHA+VGhpcyBpczxzdWI+IHN1YnNjcmlwdDwvc3ViPiBhbmQgPHN1cD5zdXBlcnNjcmlwdDwvc3VwPjwvcD4NCiANCjwvYm9keT4NCjwvaHRtbD4NCg==","encodedHtmlPopup":"PGh0bWw+DQo8Ym9keT4NCiANCjxwPjxiPlRoaXMgdGV4dCBpcyBib2xkPC9iPjwvcD4NCjxwPjxpPlRoaXMgdGV4dCBpcyBpdGFsaWM8L2k+PC9wPg0KPHA+VGhpcyBpczxzdWI+IHN1YnNjcmlwdDwvc3ViPiBhbmQgPHN1cD5zdXBlcnNjcmlwdDwvc3VwPjwvcD4NCiANCjwvYm9keT4NCjwvaHRtbD4NCg==","id":"G8UD2OKG49UW","transactionId":"12312731","url":"https://merchant.redirect.com/url.do?param_utf=%27%22%3C%3E%20%E6%B8%AC%E8%A9%A6%E6%B8%AC\u0026param_url=https%3A%2F%2Fwww.abc.com\u0026param_special=+@#%~_\u0026sign=fdaa1df42b6260a10e2e3f1c0fc87862"},"clientReferenceInformation":{"code":"TC84105-1"},"id":"6853506446826005503878","installmentInformation":{"identifier":"1000000000"},"orderInformation":{"billTo":{"address1":"201 S. Division St.","address2":"Suite A101","administrativeArea":"MI","country":"IN","email":"test@cybs.com","firstName":"Krishna","lastName":"CYBS","locality":"NPCI","postalCode":"560048"},"shipTo":{"address1":"201 S. Division St.","address2":"Suite A101","administrativeArea":"MI","country":"IN","firstName":"Krishna","lastName":"CYBS","locality":"NPCI","postalCode":"560048"}},"paymentInformation":{"bank":{"iban":"NL51ABNC1122334455"},"eWallet":{"accountId":"123456"}},"processorInformation":{"reasonCode":"100","responseCode":"00","responseDetails":"100","transactionId":"2016011808153910011808153910TR"},"riskInformation":{"processorResults":{"riskScore":"3"}},"status":"SUCCESS","submitTimeUtc":"2023-05-29T08:57:25Z"}
swagger:model BillingAgreementsDeRegistrationCreatedBody
*/
type BillingAgreementsDeRegistrationCreatedBody struct {

	// links
	Links *BillingAgreementsDeRegistrationCreatedBodyLinks `json:"_links,omitempty"`

	// agreement information
	AgreementInformation *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation `json:"agreementInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// installment information
	InstallmentInformation *BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// order information
	OrderInformation *BillingAgreementsDeRegistrationCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// processor information
	ProcessorInformation *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// risk information
	RiskInformation *BillingAgreementsDeRegistrationCreatedBodyRiskInformation `json:"riskInformation,omitempty"`

	// The status of the billing agreement.
	// Possible value is:
	//   - PENDING
	//   - REVOKED
	//   - ACTIVE
	//   - FAILED
	//   - EXPIRED
	//   - INACTIVE
	//
	// Max Length: 15
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this billing agreements de registration created body
func (o *BillingAgreementsDeRegistrationCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAgreementInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRiskInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateAgreementInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AgreementInformation) { // not required
		return nil
	}

	if o.AgreementInformation != nil {
		if err := o.AgreementInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "agreementInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "agreementInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateInstallmentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateRiskInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.RiskInformation) { // not required
		return nil
	}

	if o.RiskInformation != nil {
		if err := o.RiskInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.Status) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"status", "body", o.Status, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this billing agreements de registration created body based on the context it is used
func (o *BillingAgreementsDeRegistrationCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAgreementInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstallmentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRiskInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidateAgreementInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AgreementInformation != nil {

		if swag.IsZero(o.AgreementInformation) { // not required
			return nil
		}

		if err := o.AgreementInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "agreementInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "agreementInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidateInstallmentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.InstallmentInformation != nil {

		if swag.IsZero(o.InstallmentInformation) { // not required
			return nil
		}

		if err := o.InstallmentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {

		if swag.IsZero(o.PaymentInformation) { // not required
			return nil
		}

		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidateProcessorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessorInformation != nil {

		if swag.IsZero(o.ProcessorInformation) { // not required
			return nil
		}

		if err := o.ProcessorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBody) contextValidateRiskInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.RiskInformation != nil {

		if swag.IsZero(o.RiskInformation) { // not required
			return nil
		}

		if err := o.RiskInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBody) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyAgreementInformation billing agreements de registration created body agreement information
swagger:model BillingAgreementsDeRegistrationCreatedBodyAgreementInformation
*/
type BillingAgreementsDeRegistrationCreatedBodyAgreementInformation struct {

	// Date the mandate has been created.  Format YYYYMMdd
	// Max Length: 8
	DateCreated string `json:"dateCreated,omitempty"`

	// Date the mandate has been revoked.  Format YYYYMMdd
	// Max Length: 8
	DateRevoked string `json:"dateRevoked,omitempty"`

	// Date the mandate has been signed.  Format YYYYMMdd
	// Max Length: 8
	DateSigned string `json:"dateSigned,omitempty"`

	// Base64 encoded html string
	EncodedHTML string `json:"encodedHtml,omitempty"`

	// Base64 encoded popup html string
	EncodedHTMLPopup string `json:"encodedHtmlPopup,omitempty"`

	// Identifier for the mandate.
	//
	// Max Length: 50
	ID string `json:"id,omitempty"`

	// The Billing Agreement ID returned by processor (PayPal).
	//
	// Max Length: 50
	TransactionID string `json:"transactionId,omitempty"`

	// URL for redirecting the customer for creating
	// the mandate.
	//
	// Max Length: 2048
	URL string `json:"url,omitempty"`
}

// Validate validates this billing agreements de registration created body agreement information
func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateRevoked(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateSigned(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) validateDateCreated(formats strfmt.Registry) error {
	if swag.IsZero(o.DateCreated) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"agreementInformation"+"."+"dateCreated", "body", o.DateCreated, 8); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) validateDateRevoked(formats strfmt.Registry) error {
	if swag.IsZero(o.DateRevoked) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"agreementInformation"+"."+"dateRevoked", "body", o.DateRevoked, 8); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) validateDateSigned(formats strfmt.Registry) error {
	if swag.IsZero(o.DateSigned) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"agreementInformation"+"."+"dateSigned", "body", o.DateSigned, 8); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"agreementInformation"+"."+"id", "body", o.ID, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"agreementInformation"+"."+"transactionId", "body", o.TransactionID, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(o.URL) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"agreementInformation"+"."+"url", "body", o.URL, 2048); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body agreement information based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyAgreementInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyAgreementInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation billing agreements de registration created body client reference information
swagger:model BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation
*/
type BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`
}

// Validate validates this billing agreements de registration created body client reference information
func (o *BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body client reference information based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation billing agreements de registration created body installment information
swagger:model BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation
*/
type BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation struct {

	// Identifier
	//
	// Max Length: 100
	Identifier string `json:"identifier,omitempty"`
}

// Validate validates this billing agreements de registration created body installment information
func (o *BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation) validateIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.Identifier) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"installmentInformation"+"."+"identifier", "body", o.Identifier, 100); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body installment information based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyLinks billing agreements de registration created body links
swagger:model BillingAgreementsDeRegistrationCreatedBodyLinks
*/
type BillingAgreementsDeRegistrationCreatedBodyLinks struct {

	// self
	Self *BillingAgreementsDeRegistrationCreatedBodyLinksSelf `json:"self,omitempty"`

	// status
	Status *BillingAgreementsDeRegistrationCreatedBodyLinksStatus `json:"status,omitempty"`
}

// Validate validates this billing agreements de registration created body links
func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.Status) { // not required
		return nil
	}

	if o.Status != nil {
		if err := o.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration created body links based on the context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if o.Status != nil {

		if swag.IsZero(o.Status) { // not required
			return nil
		}

		if err := o.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "_links" + "." + "status")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyLinksSelf billing agreements de registration created body links self
swagger:model BillingAgreementsDeRegistrationCreatedBodyLinksSelf
*/
type BillingAgreementsDeRegistrationCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this billing agreements de registration created body links self
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this billing agreements de registration created body links self based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyLinksStatus billing agreements de registration created body links status
swagger:model BillingAgreementsDeRegistrationCreatedBodyLinksStatus
*/
type BillingAgreementsDeRegistrationCreatedBodyLinksStatus struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this billing agreements de registration created body links status
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksStatus) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this billing agreements de registration created body links status based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksStatus) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyLinksStatus) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyLinksStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyOrderInformation billing agreements de registration created body order information
swagger:model BillingAgreementsDeRegistrationCreatedBodyOrderInformation
*/
type BillingAgreementsDeRegistrationCreatedBodyOrderInformation struct {

	// bill to
	BillTo *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// ship to
	ShipTo *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo `json:"shipTo,omitempty"`
}

// Validate validates this billing agreements de registration created body order information
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration created body order information based on the context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {

		if swag.IsZero(o.ShipTo) { // not required
			return nil
		}

		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo billing agreements de registration created body order information bill to
swagger:model BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo
*/
type BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo struct {

	// First line of the billing street address.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	// Example: Attention - Accounts Payable
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State of the billing address in the U.S.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Billing country. Use the two character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full
	// domain name.
	//
	// Max Length: 256
	Email string `json:"email,omitempty"`

	// Customer's first name.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer's last name.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the billing address.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	// A 9-digit postal code must follow this format: [5 digits][dash][4 digits]
	//
	// Example: 12345-6789"
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this billing agreements de registration created body order information bill to
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email, 256); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body order information bill to based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo billing agreements de registration created body order information ship to
swagger:model BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo
*/
type BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo struct {

	// First line of the shipping address.
	//
	// Max Length: 100
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	//
	// Max Length: 100
	Address2 string `json:"address2,omitempty"`

	// State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)
	//
	// Max Length: 40
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// First name of the recipient.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the recipient.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the shipping address.
	//
	// Max Length: 40
	Locality string `json:"locality,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// Max Length: 20
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this billing agreements de registration created body order information ship to
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"address1", "body", o.Address1, 100); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"address2", "body", o.Address2, 100); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 40); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"locality", "body", o.Locality, 40); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body order information ship to based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyPaymentInformation billing agreements de registration created body payment information
swagger:model BillingAgreementsDeRegistrationCreatedBodyPaymentInformation
*/
type BillingAgreementsDeRegistrationCreatedBodyPaymentInformation struct {

	// bank
	Bank *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank `json:"bank,omitempty"`

	// e wallet
	EWallet *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet `json:"eWallet,omitempty"`
}

// Validate validates this billing agreements de registration created body payment information
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEWallet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) validateBank(formats strfmt.Registry) error {
	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) validateEWallet(formats strfmt.Registry) error {
	if swag.IsZero(o.EWallet) { // not required
		return nil
	}

	if o.EWallet != nil {
		if err := o.EWallet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "eWallet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "eWallet")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration created body payment information based on the context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBank(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateEWallet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) contextValidateBank(ctx context.Context, formats strfmt.Registry) error {

	if o.Bank != nil {

		if swag.IsZero(o.Bank) { // not required
			return nil
		}

		if err := o.Bank.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) contextValidateEWallet(ctx context.Context, formats strfmt.Registry) error {

	if o.EWallet != nil {

		if swag.IsZero(o.EWallet) { // not required
			return nil
		}

		if err := o.EWallet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "eWallet")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "paymentInformation" + "." + "eWallet")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank billing agreements de registration created body payment information bank
swagger:model BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank
*/
type BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank struct {

	// International Bank Account Number (IBAN).
	//
	// Max Length: 34
	Iban string `json:"iban,omitempty"`
}

// Validate validates this billing agreements de registration created body payment information bank
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateIban(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank) validateIban(formats strfmt.Registry) error {
	if swag.IsZero(o.Iban) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"paymentInformation"+"."+"bank"+"."+"iban", "body", o.Iban, 34); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body payment information bank based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet billing agreements de registration created body payment information e wallet
swagger:model BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet
*/
type BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet struct {

	// The ID of the customer, passed in the return_url field by PayPal after customer approval.
	//
	// Max Length: 30
	AccountID string `json:"accountId,omitempty"`
}

// Validate validates this billing agreements de registration created body payment information e wallet
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet) validateAccountID(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountID) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"paymentInformation"+"."+"eWallet"+"."+"accountId", "body", o.AccountID, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body payment information e wallet based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyPaymentInformationEWallet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyProcessorInformation billing agreements de registration created body processor information
swagger:model BillingAgreementsDeRegistrationCreatedBodyProcessorInformation
*/
type BillingAgreementsDeRegistrationCreatedBodyProcessorInformation struct {

	// Authorization code. Returned only when the processor returns this value.
	//
	// The length of this value depends on your processor.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Authorization code that is returned by the processor.
	//
	// Returned by PIN debit credit.
	//
	// #### Elavon Encrypted Account Number Program
	// The returned value is OFFLINE.
	//
	// #### TSYS Acquiring Solutions
	// The returned value for a successful zero amount authorization is 000000.
	//
	// Max Length: 6
	ApprovalCode string `json:"approvalCode,omitempty"`

	// Numeric value corresponding to the result of the request.
	//
	// Max Length: 5
	ReasonCode string `json:"reasonCode,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	// #### SEPA/BACS
	// Response code from the processor. Possible values: 00000–99999. See Appendix C,
	// "Reason Codes and Processor Response
	// Codes," on page 42.
	//
	// #### PIN debit
	// Response value that is returned by the processor or bank.
	// **Important** Do not use this field to evaluate the results of the transaction request.
	//
	// Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or response code received from the processor separated by a colon.
	// Format: [status code]:E[error code] or [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field.
	// String (3)
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// Response code indicating that creating the agreement failed
	//
	// Max Length: 60
	ResponseDetails string `json:"responseDetails,omitempty"`

	// Transaction ID assigned by the processor.
	//
	// Max Length: 255
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this billing agreements de registration created body processor information
func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateApprovalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReasonCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) validateApprovalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ApprovalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"processorInformation"+"."+"approvalCode", "body", o.ApprovalCode, 6); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) validateReasonCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ReasonCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"processorInformation"+"."+"reasonCode", "body", o.ReasonCode, 5); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"processorInformation"+"."+"responseCode", "body", o.ResponseCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) validateResponseDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"processorInformation"+"."+"responseDetails", "body", o.ResponseDetails, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"processorInformation"+"."+"transactionId", "body", o.TransactionID, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body processor information based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyRiskInformation billing agreements de registration created body risk information
swagger:model BillingAgreementsDeRegistrationCreatedBodyRiskInformation
*/
type BillingAgreementsDeRegistrationCreatedBodyRiskInformation struct {

	// processor results
	ProcessorResults *BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults `json:"processorResults,omitempty"`
}

// Validate validates this billing agreements de registration created body risk information
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateProcessorResults(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformation) validateProcessorResults(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorResults) { // not required
		return nil
	}

	if o.ProcessorResults != nil {
		if err := o.ProcessorResults.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation" + "." + "processorResults")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation" + "." + "processorResults")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration created body risk information based on the context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateProcessorResults(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformation) contextValidateProcessorResults(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessorResults != nil {

		if swag.IsZero(o.ProcessorResults) { // not required
			return nil
		}

		if err := o.ProcessorResults.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation" + "." + "processorResults")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billingAgreementsDeRegistrationCreated" + "." + "riskInformation" + "." + "processorResults")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyRiskInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults billing agreements de registration created body risk information processor results
swagger:model BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults
*/
type BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults struct {

	// Risk score returned by the processor. Possible
	// values of 0-10. A value of 10 indicates a high risk.
	//
	// Max Length: 25
	RiskScore string `json:"riskScore,omitempty"`
}

// Validate validates this billing agreements de registration created body risk information processor results
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRiskScore(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults) validateRiskScore(formats strfmt.Registry) error {
	if swag.IsZero(o.RiskScore) { // not required
		return nil
	}

	if err := validate.MaxLength("billingAgreementsDeRegistrationCreated"+"."+"riskInformation"+"."+"processorResults"+"."+"riskScore", "body", o.RiskScore, 25); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration created body risk information processor results based on context it is used
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationCreatedBodyRiskInformationProcessorResults
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyAggregatorInformation billing agreements de registration params body aggregator information
swagger:model BillingAgreementsDeRegistrationParamsBodyAggregatorInformation
*/
type BillingAgreementsDeRegistrationParamsBodyAggregatorInformation struct {

	// Your payment aggregator business name.
	//
	// **American Express Direct**\
	// The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the aggregator_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// sub merchant
	SubMerchant *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant `json:"subMerchant,omitempty"`
}

// Validate validates this billing agreements de registration params body aggregator information
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubMerchant(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation) validateSubMerchant(formats strfmt.Registry) error {
	if swag.IsZero(o.SubMerchant) { // not required
		return nil
	}

	if o.SubMerchant != nil {
		if err := o.SubMerchant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration params body aggregator information based on the context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSubMerchant(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation) contextValidateSubMerchant(ctx context.Context, formats strfmt.Registry) error {

	if o.SubMerchant != nil {

		if swag.IsZero(o.SubMerchant) { // not required
			return nil
		}

		if err := o.SubMerchant.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyAggregatorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant billing agreements de registration params body aggregator information sub merchant
swagger:model BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant
*/
type BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant struct {

	// First line of the sub-merchant's street address.
	//
	// For processor-specific details, see `submerchant_street` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 38
	Address1 string `json:"address1,omitempty"`

	// Sub-merchant's state or province.
	//
	// For possible values and also aggregator support, see `submerchant_state` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Unique identifier assigned by the payment card company to the sub-merchant.
	// Max Length: 15
	CardAcceptorID string `json:"cardAcceptorId,omitempty"`

	// Sub-merchant's country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// For details, see the `submerchant_country` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Sub-merchant's email address.
	//
	// **Maximum length for processors**
	//
	//  - American Express Direct: 40
	//  - CyberSource through VisaNet: 40
	//  - FDC Compass: 40
	//  - FDC Nashville Global: 19
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 25-64
	// - Field: American Express Seller E-mail Address
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant's acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Max Length: 40
	Email string `json:"email,omitempty"`

	// The ID you assigned to your sub-merchant.
	// CyberSource through VisaNet: For American Express transaction, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 65-84
	// - Field: American Express Seller ID
	// For  Mastercard transactions, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 117-131
	// - Field: Sub-Merchant ID
	// FDC Compass: This value must consist of uppercase characters.
	//
	// American Express Direct: String (20)
	// CyberSource through VisaNet with American Express: String (20)
	// CyberSource through VisaNet with Visa,Mastercard and Discover: String (15)
	// FDC Compass: String (20)
	// FDC Nashville Global: String (14)
	//
	// Max Length: 20
	ID string `json:"id,omitempty"`

	// Sub-merchant's city.
	//
	// For processor-specific details, see `submerchant_city` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 21
	Locality string `json:"locality,omitempty"`

	// Sub-merchant's business name.
	//
	// #### American Express Direct
	// The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// #### FDC Nashville Global
	// With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name:
	// - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21.
	// - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17.
	// - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12.
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// Sub-merchant's telephone number.
	//
	// **Maximum length for procesors**
	//
	//  - American Express Direct: 20
	//  - CyberSource through VisaNet: 20
	//  - FDC Compass: 13
	//  - FDC Nashville Global: 10
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCRB
	// - Position: 5-24
	// - Field: American Express Seller Telephone Number
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters. Use one of these recommended formats:\
	// `NNN-NNN-NNNN`\
	// `NNN-AAAAAAA`
	//
	// Max Length: 20
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Partial postal code for the sub-merchant's address.
	//
	// For processor-specific details, see `submerchant_postal_code` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`

	// Sub-merchant's region.
	//
	// **Example**\
	// `NE` indicates that the sub-merchant is in the northeast region.
	//
	// For processor-specific details, see `submerchant_region` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	Region string `json:"region,omitempty"`
}

// Validate validates this billing agreements de registration params body aggregator information sub merchant
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardAcceptorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"address1", "body", o.Address1, 38); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"administrativeArea", "body", o.AdministrativeArea, 3); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateCardAcceptorID(formats strfmt.Registry) error {
	if swag.IsZero(o.CardAcceptorID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"cardAcceptorId", "body", o.CardAcceptorID, 15); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"email", "body", o.Email, 40); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"id", "body", o.ID, 20); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"locality", "body", o.Locality, 21); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"phoneNumber", "body", o.PhoneNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"postalCode", "body", o.PostalCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) validateRegion(formats strfmt.Registry) error {
	if swag.IsZero(o.Region) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"region", "body", o.Region, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body aggregator information sub merchant based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyAggregatorInformationSubMerchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyAgreementInformation billing agreements de registration params body agreement information
swagger:model BillingAgreementsDeRegistrationParamsBodyAgreementInformation
*/
type BillingAgreementsDeRegistrationParamsBodyAgreementInformation struct {

	// e sign indicator
	// Max Length: 1
	ESignIndicator string `json:"eSignIndicator,omitempty"`

	// Identifier for the mandate.
	// #### SEPA/BACS
	// Required for mandates services
	//
	// Max Length: 50
	ID string `json:"id,omitempty"`
}

// Validate validates this billing agreements de registration params body agreement information
func (o *BillingAgreementsDeRegistrationParamsBodyAgreementInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateESignIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAgreementInformation) validateESignIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.ESignIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"agreementInformation"+"."+"eSignIndicator", "body", o.ESignIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyAgreementInformation) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"agreementInformation"+"."+"id", "body", o.ID, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body agreement information based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyAgreementInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyAgreementInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyAgreementInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyAgreementInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyBuyerInformation billing agreements de registration params body buyer information
swagger:model BillingAgreementsDeRegistrationParamsBodyBuyerInformation
*/
type BillingAgreementsDeRegistrationParamsBodyBuyerInformation struct {

	// Recipient's date of birth. **Format**: `YYYYMMDD`.
	//
	// This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters
	// but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field
	// is not required for the transaction, CyberSource does not forward it to the processor.
	//
	// For more details, see `recipient_date_of_birth` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 8
	DateOfBirth string `json:"dateOfBirth,omitempty"`

	// Customer's gender. Possible values are F (female), M (male), O (other).
	// Max Length: 1
	Gender string `json:"gender,omitempty"`

	// language setting of the user
	// Max Length: 5
	Language string `json:"language,omitempty"`
}

// Validate validates this billing agreements de registration params body buyer information
func (o *BillingAgreementsDeRegistrationParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGender(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"buyerInformation"+"."+"dateOfBirth", "body", o.DateOfBirth, 8); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyBuyerInformation) validateGender(formats strfmt.Registry) error {
	if swag.IsZero(o.Gender) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"buyerInformation"+"."+"gender", "body", o.Gender, 1); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyBuyerInformation) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(o.Language) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"buyerInformation"+"."+"language", "body", o.Language, 5); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body buyer information based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation billing agreements de registration params body client reference information
swagger:model BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation
*/
type BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation struct {

	// The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource.
	//
	ApplicationName string `json:"applicationName,omitempty"`

	// The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method.
	//
	ApplicationUser string `json:"applicationUser,omitempty"`

	// Version of the CyberSource application or integration used for a transaction.
	//
	ApplicationVersion string `json:"applicationVersion,omitempty"`

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	//
	// #### SEPA/BACS
	// Required for mandates services
	// #### Paypal
	// Required for billing agreements
	//
	//
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call.
	//
	// Max Length: 26
	PausedRequestID string `json:"pausedRequestId,omitempty"`

	// Reference number for the transaction.
	// Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource.
	// The actual value used in the request to the processor is provided back to you by Cybersource in the response.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.
	//
	// **Note** Use this field only if you want to support merchant-initiated reversal and void operations.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, and Void**
	// Optional field.
	//
	// #### PIN Debit
	// For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier.
	// Optional field for PIN debit purchase or credit requests.
	//
	// Max Length: 30
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this billing agreements de registration params body client reference information
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePausedRequestID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) validatePausedRequestID(formats strfmt.Registry) error {
	if swag.IsZero(o.PausedRequestID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"pausedRequestId", "body", o.PausedRequestID, 26); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"transactionId", "body", o.TransactionID, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this billing agreements de registration params body client reference information based on the context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {

		if swag.IsZero(o.Partner) { // not required
			return nil
		}

		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner billing agreements de registration params body client reference information partner
swagger:model BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner
*/
type BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminal's software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal's
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`

	// Value that identifies the application vendor and application version for a third party gateway.
	// CyberSource provides you with this value during testing and validation.
	// This field is supported only on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, Incremental Authorization, and Void**
	// Optional field.
	//
	// #### PIN debit
	// Required field for PIN debit credit, PIN debit purchase, or PIN debit reversal request.
	//
	// Max Length: 12
	ThirdPartyCertificationNumber string `json:"thirdPartyCertificationNumber,omitempty"`
}

// Validate validates this billing agreements de registration params body client reference information partner
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThirdPartyCertificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", o.OriginalTransactionID, 32); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) validateThirdPartyCertificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ThirdPartyCertificationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"clientReferenceInformation"+"."+"partner"+"."+"thirdPartyCertificationNumber", "body", o.ThirdPartyCertificationNumber, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body client reference information partner based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation billing agreements de registration params body consumer authentication information
swagger:model BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation
*/
type BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation struct {

	// Payer authentication transaction identifier passed to link the validation and authorization calls.
	//
	// Max Length: 30
	AuthenticationTransactionContextID string `json:"authenticationTransactionContextId,omitempty"`

	// Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and
	// Discover transactions after the customer is authenticated. The value is in base64. When you
	// request the card authorization service, CyberSource automatically converts the value, not the field name,
	// to the format required by your payment processor.
	//
	// Max Length: 255
	Cavv string `json:"cavv,omitempty"`

	// Web based token used to authenticate consumer with Rupay authentication provider.
	//
	// Max Length: 256
	TransactionToken string `json:"transactionToken,omitempty"`

	// Transaction identifier generated by CyberSource for successful enrollment or validation checks.
	// Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes.
	// CyberSource forwards the XID with the card authorization service to these payment processors in these cases:
	// - Barclays
	// - Streamline (when the **ecommerceIndicator**`=spa`)
	//
	Xid string `json:"xid,omitempty"`
}

// Validate validates this billing agreements de registration params body consumer authentication information
func (o *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthenticationTransactionContextID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionToken(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation) validateAuthenticationTransactionContextID(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationTransactionContextID) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionContextId", "body", o.AuthenticationTransactionContextID, 30); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation) validateCavv(formats strfmt.Registry) error {
	if swag.IsZero(o.Cavv) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"consumerAuthenticationInformation"+"."+"cavv", "body", o.Cavv, 255); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation) validateTransactionToken(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionToken) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"consumerAuthenticationInformation"+"."+"transactionToken", "body", o.TransactionToken, 256); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body consumer authentication information based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyDeviceInformation billing agreements de registration params body device information
swagger:model BillingAgreementsDeRegistrationParamsBodyDeviceInformation
*/
type BillingAgreementsDeRegistrationParamsBodyDeviceInformation struct {

	// Value of the Accept header sent by the customer's web browser.
	// **Note** If the customer's browser provides a value, you must include it in your request.
	//
	// Max Length: 255
	HTTPAcceptBrowserValue string `json:"httpAcceptBrowserValue,omitempty"`

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 45
	IPAddress string `json:"ipAddress,omitempty"`

	// Value of the User-Agent header sent by the customer's web browser.
	// Note If the customer's browser provides a value, you must include it in your request.
	//
	// Max Length: 255
	UserAgentBrowserValue string `json:"userAgentBrowserValue,omitempty"`
}

// Validate validates this billing agreements de registration params body device information
func (o *BillingAgreementsDeRegistrationParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHTTPAcceptBrowserValue(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgentBrowserValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyDeviceInformation) validateHTTPAcceptBrowserValue(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPAcceptBrowserValue) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"deviceInformation"+"."+"httpAcceptBrowserValue", "body", o.HTTPAcceptBrowserValue, 255); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"deviceInformation"+"."+"ipAddress", "body", o.IPAddress, 45); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyDeviceInformation) validateUserAgentBrowserValue(formats strfmt.Registry) error {
	if swag.IsZero(o.UserAgentBrowserValue) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"deviceInformation"+"."+"userAgentBrowserValue", "body", o.UserAgentBrowserValue, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body device information based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyDeviceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyInstallmentInformation billing agreements de registration params body installment information
swagger:model BillingAgreementsDeRegistrationParamsBodyInstallmentInformation
*/
type BillingAgreementsDeRegistrationParamsBodyInstallmentInformation struct {

	// Applicable only for SI. Required in case the authentication is initiated for SI registration.
	// Valid Values:
	// - `SMS`
	// - `EMAIL`
	// - `BOTH`
	//
	// Max Length: 5
	AlertPreference string `json:"alertPreference,omitempty"`

	// Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR9
	// - Position: 42-47
	// - Field: Date of First Installment
	//
	// Max Length: 6
	FirstInstallmentDate string `json:"firstInstallmentDate,omitempty"`

	// Standing Instruction/Installment identifier.
	//
	// Max Length: 60
	Identifier string `json:"identifier,omitempty"`

	// End date of the SI transactions.
	// Cannot be later than card expiry date. Ideally this can be set to expiry date.
	// Required in case the authentication is initiated for SI registration.
	//
	// Max Length: 8
	LastInstallmentDate string `json:"lastInstallmentDate,omitempty"`

	// Maximum Amount for which SI can be initiated.
	// Required in case the authentication is initiated for SI registration.
	//
	// Max Length: 12
	MaxAmount string `json:"maxAmount,omitempty"`

	// Minimum Amount for which SI can be initiated.
	// Required in case the authentication is initiated for SI registration.
	//
	// Max Length: 12
	MinAmount string `json:"minAmount,omitempty"`

	// Payment plan for the installments.
	//
	// Possible values:
	// - 0 (default): Regular installment. This value is not allowed for airline transactions.
	// - 1: Installment payment with down payment.
	// - 2: Installment payment without down payment. This value is supported only for airline transactions.
	// - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions.
	// - 4: Down payment only; regular installment payment will follow.
	// - 5: Boarding fee only. This value is supported only for airline transactions.
	//
	// This field is supported only for installment payments with Visa on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 9
	// - Field: Merchant Installment Supporting Information
	//
	// Max Length: 1
	PaymentType string `json:"paymentType,omitempty"`

	// Preferred date for initiating the SI transaction every month.
	// This field need not be sent in case the SI has to be initiated as and when required, e.g., topping up the wallet, etc.
	//
	// Max Length: 2
	PreferredDay string `json:"preferredDay,omitempty"`

	// Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 38-40
	// - Field: Installment Payment Number
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant's acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	Sequence int64 `json:"sequence,omitempty"`
}

// Validate validates this billing agreements de registration params body installment information
func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlertPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastInstallmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMinAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePreferredDay(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSequence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validateAlertPreference(formats strfmt.Registry) error {
	if swag.IsZero(o.AlertPreference) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"alertPreference", "body", o.AlertPreference, 5); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validateFirstInstallmentDate(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstInstallmentDate) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"firstInstallmentDate", "body", o.FirstInstallmentDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validateIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.Identifier) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"identifier", "body", o.Identifier, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validateLastInstallmentDate(formats strfmt.Registry) error {
	if swag.IsZero(o.LastInstallmentDate) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"lastInstallmentDate", "body", o.LastInstallmentDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validateMaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.MaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"maxAmount", "body", o.MaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validateMinAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.MinAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"minAmount", "body", o.MinAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validatePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"paymentType", "body", o.PaymentType, 1); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validatePreferredDay(formats strfmt.Registry) error {
	if swag.IsZero(o.PreferredDay) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"installmentInformation"+"."+"preferredDay", "body", o.PreferredDay, 2); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) validateSequence(formats strfmt.Registry) error {
	if swag.IsZero(o.Sequence) { // not required
		return nil
	}

	if err := validate.MaximumInt("modifyBillingAgreement"+"."+"installmentInformation"+"."+"sequence", "body", o.Sequence, 99, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body installment information based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyMerchantInformation billing agreements de registration params body merchant information
swagger:model BillingAgreementsDeRegistrationParamsBodyMerchantInformation
*/
type BillingAgreementsDeRegistrationParamsBodyMerchantInformation struct {

	// The state where the merchant is located.
	//
	// #### PIN debit
	// State code or region code for your business. Use the Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) This value might be displayed on the cardholder's statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// URL to which the customer is directed if they fail to sign the mandate.
	// #### SEPA
	// Required for Create Mandate and Update Mandate
	// #### BACS
	// Required for Create Mandate
	//
	// Max Length: 255
	CancelURL string `json:"cancelUrl,omitempty"`

	// The value for this field is a four-digit number that the payment card industry uses to classify
	// merchants into market segments. A payment card company assigned one or more of these values to your business when you started
	// accepting the payment card company's cards. When you do not include this field in your request, CyberSource uses the value in your
	// CyberSource account.
	//
	// For processor-specific information, see the `merchant_category_code` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR4
	// - Position: 150-153
	// - Field: Merchant Category Code
	//
	// Maximum: 9999
	CategoryCode int64 `json:"categoryCode,omitempty"`

	// URL to which the customer is directed if they fail to sign the mandate.
	// #### SEPA
	// Required for Create Mandate and Update Mandate
	// #### BACS
	// Required for Create Mandate
	//
	// Max Length: 255
	FailureURL string `json:"failureUrl,omitempty"`

	// merchant descriptor
	MerchantDescriptor *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// URL to which the customer is directed if they fail to sign the mandate.
	// #### SEPA
	// Required for Create Mandate and Update Mandate
	// #### BACS
	// Required for Create Mandate
	//
	// Max Length: 255
	SuccessURL string `json:"successUrl,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where:
	//  - `YYYY` = year
	//  - `MM` = month
	//  - `DD` = day
	//  - `hh` = hour
	//  - `mm` = minutes
	//  - `ss` = seconds
	//
	// #### Used by
	// **Authorization**
	// Required for these processors:
	// - American Express Direct                                                                                                                                                                                                                                                                                                                         - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - SIX
	//
	// Optional for all other processors.
	//
	// Max Length: 14
	TransactionLocalDateTime string `json:"transactionLocalDateTime,omitempty"`
}

// Validate validates this billing agreements de registration params body merchant information
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCancelURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFailureURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSuccessURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) validateCancelURL(formats strfmt.Registry) error {
	if swag.IsZero(o.CancelURL) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"merchantInformation"+"."+"cancelUrl", "body", o.CancelURL, 255); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) validateCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaximumInt("modifyBillingAgreement"+"."+"merchantInformation"+"."+"categoryCode", "body", o.CategoryCode, 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) validateFailureURL(formats strfmt.Registry) error {
	if swag.IsZero(o.FailureURL) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"merchantInformation"+"."+"failureUrl", "body", o.FailureURL, 255); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) validateSuccessURL(formats strfmt.Registry) error {
	if swag.IsZero(o.SuccessURL) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"merchantInformation"+"."+"successUrl", "body", o.SuccessURL, 255); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) validateTransactionLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"merchantInformation"+"."+"transactionLocalDateTime", "body", o.TransactionLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this billing agreements de registration params body merchant information based on the context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {

		if swag.IsZero(o.MerchantDescriptor) { // not required
			return nil
		}

		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor billing agreements de registration params body merchant information merchant descriptor
swagger:model BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor
*/
type BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor struct {

	// For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_contact` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	// Contact information for the merchant.
	//
	// **Note** These are the maximum data lengths for the following payment processors:
	// - FDCCompass (13)
	// - Paymentech (13)
	//
	// Max Length: 14
	Contact string `json:"contact,omitempty"`

	// Merchant's City.
	//
	// #### PIN debit
	// City for your business location. This value might be displayed on the cardholder's statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// Max Length: 13
	Locality string `json:"locality,omitempty"`

	// Your merchant name.
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	// #### PIN debit
	// Your business name. This name is displayed on the cardholder's statement. When you
	// include more than one consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// #### Airline processing
	// Your merchant name. This name is displayed on the cardholder's statement. When you include more than one consecutive space, extra spaces are removed.
	//
	// **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.
	//
	// **Important** This value must consist of English characters.
	//
	// Required for captures and credits.
	//
	Name string `json:"name,omitempty"`

	// Merchant's postal code.
	//
	// #### PIN debit
	// Postal code for your business location. This value might be displayed on the cardholder's statement.
	//
	// If your business is domiciled in the U.S., you can use a 5-digit or 9-digit postal code. A 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	// Example: `12345-6789`
	//
	// If your business is domiciled in Canada, you can use a 6-digit or 9-digit postal code. A 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space]
	// [numeric][alpha][numeric]
	// Example: `A1B 2C3`
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	// **Important** Mastercard requires a postal code for any country that uses postal codes.
	// You can provide the postal code in your account or you can include this field in your request.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 14
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this billing agreements de registration params body merchant information merchant descriptor
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor) validateContact(formats strfmt.Registry) error {
	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"contact", "body", o.Contact, 14); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"locality", "body", o.Locality, 13); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"postalCode", "body", o.PostalCode, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body merchant information merchant descriptor based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyOrderInformation billing agreements de registration params body order information
swagger:model BillingAgreementsDeRegistrationParamsBodyOrderInformation
*/
type BillingAgreementsDeRegistrationParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`
}

// Validate validates this billing agreements de registration params body order information
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration params body order information based on the context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails billing agreements de registration params body order information amount details
swagger:model BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails
*/
type BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this billing agreements de registration params body order information amount details
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body order information amount details based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo billing agreements de registration params body order information bill to
swagger:model BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo
*/
type BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer's records.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_,
	// it must be sent as _1 1st Street_.
	//
	// Required if keyed; not used if swiped.
	//
	// String (20)
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional.
	// String (60)
	//
	// #### For Payouts
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Used for additional address information. For example: _Attention: Accounts Payable_
	// Optional field.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### FDMS Nashville
	// `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters.
	// String (20)
	//
	// #### All Other Processors
	// String (60)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// Max Length: 50
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Building number in the street address.
	//
	// For example, if the street address is:
	// Rua da Quitanda 187
	// then the building number is 187.
	//
	// This field is supported only for:
	//  - Cielo transactions.
	//  - Redecard customer validation with CyberSource Latin American Processing.
	//
	// Max Length: 256
	BuildingNumber string `json:"buildingNumber,omitempty"`

	// Company's Name, e.g. VISA
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### SEPA/BACS
	// Required for Create Mandate and Import Mandate
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// U.S. county if available.
	// Max Length: 50
	County string `json:"county,omitempty"`

	// Customer's neighborhood, community, or region
	// within the city or municipality.
	// #### SEPA/BACS
	// When you include this field in a request, the value for this field must
	// be the same as the value for the billTo_state field.
	//
	// Max Length: 50
	District string `json:"district,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customer's first name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	// #### BACS
	// Required for Import Mandate
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer's last name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	// #### BACS
	// Required for Import Mandate
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### RBS WorldPay Atlanta
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer's middle name.
	//
	// Max Length: 60
	MiddleName string `json:"middleName,omitempty"`

	// Customer's phone number.
	//
	// It is recommended that you include the country code when the order is from outside the U.S.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Optional field.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada.
	// Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada.
	// Not used if swiped.
	//
	// #### RBS WorldPay Atlanta:
	// For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional field.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`

	// title
	Title string `json:"title,omitempty"`
}

// Validate validates this billing agreements de registration params body order information bill to
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuildingNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCounty(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistrict(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiddleName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateBuildingNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.BuildingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"buildingNumber", "body", o.BuildingNumber, 256); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateCounty(formats strfmt.Registry) error {
	if swag.IsZero(o.County) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"county", "body", o.County, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateDistrict(formats strfmt.Registry) error {
	if swag.IsZero(o.District) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"district", "body", o.District, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validateMiddleName(formats strfmt.Registry) error {
	if swag.IsZero(o.MiddleName) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"middleName", "body", o.MiddleName, 60); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body order information bill to based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyPaymentInformation billing agreements de registration params body payment information
swagger:model BillingAgreementsDeRegistrationParamsBodyPaymentInformation
*/
type BillingAgreementsDeRegistrationParamsBodyPaymentInformation struct {

	// bank
	Bank *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank `json:"bank,omitempty"`

	// card
	Card *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// payment type
	PaymentType *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType `json:"paymentType,omitempty"`

	// tokenized card
	TokenizedCard *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this billing agreements de registration params body payment information
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) validateBank(formats strfmt.Registry) error {
	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) validatePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if o.PaymentType != nil {
		if err := o.PaymentType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration params body payment information based on the context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBank(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) contextValidateBank(ctx context.Context, formats strfmt.Registry) error {

	if o.Bank != nil {

		if swag.IsZero(o.Bank) { // not required
			return nil
		}

		if err := o.Bank.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) contextValidatePaymentType(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentType != nil {

		if swag.IsZero(o.PaymentType) { // not required
			return nil
		}

		if err := o.PaymentType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {

		if swag.IsZero(o.TokenizedCard) { // not required
			return nil
		}

		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank billing agreements de registration params body payment information bank
swagger:model BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank
*/
type BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank struct {

	// account
	Account *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// International Bank Account Number (IBAN).
	// #### SEPA
	// Required for mandates services
	//
	// Max Length: 34
	Iban string `json:"iban,omitempty"`

	// The scheme that sets the rules for the direct
	// debit process. Possible values:
	//   - SEPA
	//   - BACS
	// #### SEPA/BACS
	// Required for mandates services
	//
	// Max Length: 25
	Scheme string `json:"scheme,omitempty"`

	// Bank's SWIFT code. You can use this field only when scoring a direct debit transaction.
	// #### BACS
	// Required for mandates services
	//
	// Max Length: 20
	SwiftCode string `json:"swiftCode,omitempty"`
}

// Validate validates this billing agreements de registration params body payment information bank
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIban(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSwiftCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) validateIban(formats strfmt.Registry) error {
	if swag.IsZero(o.Iban) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"bank"+"."+"iban", "body", o.Iban, 34); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) validateScheme(formats strfmt.Registry) error {
	if swag.IsZero(o.Scheme) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"bank"+"."+"scheme", "body", o.Scheme, 25); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) validateSwiftCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SwiftCode) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"bank"+"."+"swiftCode", "body", o.SwiftCode, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this billing agreements de registration params body payment information bank based on the context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.Account != nil {

		if swag.IsZero(o.Account) { // not required
			return nil
		}

		if err := o.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount billing agreements de registration params body payment information bank account
swagger:model BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount
*/
type BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount struct {

	// Customer's bank account number.
	// #### BACS
	// Required for Create Mandate, Import Mandate, and Update Mandate
	//
	// Max Length: 30
	Number string `json:"number,omitempty"`
}

// Validate validates this billing agreements de registration params body payment information bank account
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"number", "body", o.Number, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body payment information bank account based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard billing agreements de registration params body payment information card
swagger:model BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard
*/
type BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer's payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// #### FDMS Nashville
	// Required. String (19)
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Card Verification Number.
	//
	// #### FDMS Nashville
	// Required for American Express or if swiped; otherwise, optional.
	//
	// #### Ingenico ePayments
	// Do not include this field when `commerceIndicator=recurring`.
	// **Note** Ingenico ePayments was previously called _Global Collect_.
	//
	// #### TSYS Acquiring Solutions
	// Optional if pointOfSaleInformation.entryMode=keyed; otherwise, not used.
	//
	// #### GPX
	// Optional.
	//
	// #### All other processors:
	// Optional.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	// - '070': EFTPOS
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this billing agreements de registration params body payment information card
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body payment information card based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType billing agreements de registration params body payment information payment type
swagger:model BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType
*/
type BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType struct {

	// method
	Method *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod `json:"method,omitempty"`

	// A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit.
	// Possible values:
	// - `EWALLET`
	// - `directDebitSepa`
	// - `directDebitBacs`
	// #### SEPA/BACS
	// Required for mandates services
	// #### Paypal
	// Required for billing agreements
	//
	Name string `json:"name,omitempty"`
}

// Validate validates this billing agreements de registration params body payment information payment type
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType) validateMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.Method) { // not required
		return nil
	}

	if o.Method != nil {
		if err := o.Method.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this billing agreements de registration params body payment information payment type based on the context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMethod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType) contextValidateMethod(ctx context.Context, formats strfmt.Registry) error {

	if o.Method != nil {

		if swag.IsZero(o.Method) { // not required
			return nil
		}

		if err := o.Method.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("modifyBillingAgreement" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod billing agreements de registration params body payment information payment type method
swagger:model BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod
*/
type BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod struct {

	// Identifier for the payment type.
	// Possible Values:
	//   - SENTENIAL
	//   - PAYPAL
	// #### SEPA/BACS
	// Required for mandates services
	// #### Paypal
	// Required for billing agreements
	//
	Name string `json:"name,omitempty"`
}

// Validate validates this billing agreements de registration params body payment information payment type method
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this billing agreements de registration params body payment information payment type method based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyPaymentInformationPaymentTypeMethod
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard billing agreements de registration params body payment information tokenized card
swagger:model BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard
*/
type BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard struct {

	// This field contains token information.
	// Max Length: 255
	Cryptogram string `json:"cryptogram,omitempty"`

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Customer's payment network token value.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that
	// provided you with information about the token.
	//
	// Possible value:
	// - `2`: Near-field communication (NFC) transaction. The customer's mobile device provided the token data for a contactless EMV transaction. For recurring
	// transactions, use this value if the original transaction was a contactless EMV transaction.
	//
	// #### Visa Platform Connect
	// - `1`: For Rupay and In App tokenization. Example: InApp apple pay.
	// - `3`: Card/Credential On File Tokenization.
	//
	// **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// #### Rupay
	// - `3`: Card/Credential On File Tokenization.
	// - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	// - '070': EFTPOS
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this billing agreements de registration params body payment information tokenized card
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCryptogram(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) validateCryptogram(formats strfmt.Registry) error {
	if swag.IsZero(o.Cryptogram) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"cryptogram", "body", o.Cryptogram, 255); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body payment information tokenized card based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
BillingAgreementsDeRegistrationParamsBodyProcessingInformation billing agreements de registration params body processing information
swagger:model BillingAgreementsDeRegistrationParamsBodyProcessingInformation
*/
type BillingAgreementsDeRegistrationParamsBodyProcessingInformation struct {

	// - Use `CONSUMER_AUTHENTICATION` to use Payer Authentication along with Decision Manager. For any other value, only Decision Manager will run.
	// - Use `WATCHLIST_SCREENING`  when you want to call Watchlist Screening service.
	// - Use `BILLING_AGREEMENT_CREATE` when Paypal billing agreements service is requested.
	// - Use `UPDATE_AGREEMENT`
	// - Use `CANCEL_AGREEMENT`
	// - Use `AP_UPDATE_AGREEMENT` when Alternative Payment update mandate service is requested.
	// - Use `AP_CANCEL_AGREEMENT` when Alternative Payment revoke mandate service is requested.
	// - Use `AP_REFRESH_AGREEMENT_STATUS` when Alternative Payment mandate status service is requested.
	//
	ActionList []string `json:"actionList"`

	// Type of transaction. Used to determine fees based on channel.
	//
	// Possible values:
	//
	//   - aesk: American Express SafeKey authentication was successful.
	//   - aesk_attempted: American Express SafeKey authentication was attempted but did not succeed. • install: Installment payment.
	//   - install_internet: Non-U.S. e-commerce (Internet) installment payment. This value is supported only on Visa Platform Connect.
	//   - internet (default for authorizations): E-commerce order placed using a web site.
	//   - js: JCB J/Secure authentication was successful.
	//   - js_attempted: JCB J/Secure authentication was attempted but did not succeed.
	//   - moto: Mail order or telephone order.
	//   - moto_cc: Mail order or telephone order from a call center. This value is supported only on the Asia, Middle East, and Africa Gateway.
	//   - pb: ProtectBuy authentication was successful.
	//   - pb_attempted: ProtectBuy authentication was attempted but did not succeed.
	//   - recurring: Recurring payment that is a U.S. transaction or non-U.S. mail order / telephone order (MOTO) transaction.
	//   - recurring_internet: Recurring payment that is a non-U.S. e-commerce (Internet) transaction.
	//   - retail: Card-present transaction.
	//   - spa: For Mastercard Identity Check: Authentication was successful or was attempted but did not succeed. The e-commerce indicator for all Mastercard Identity Check transactions, including authentication attempts, must be set to spa.
	//   - spa_attempted: Authentication for a co-badged Mastercard and Cartes Bancaires card was attempted but did not succeed.
	//   - spa_failure: – For Mastercard Identity Check: Authentication failed. This value is supported only on Elavon, HSBC, and Streamline.
	//   - vbv: – For Visa Secure: Authentication was successful.
	//   - vbv_attempted: – For Visa Secure: Authentication was attempted but did not succeed.
	//   - vbv_failure: – For Visa Secure: Authentication failed. This value is supported only on HSBC and Streamline.
	//
	// Max Length: 20
	CommerceIndicator string `json:"commerceIndicator,omitempty"`
}

// Validate validates this billing agreements de registration params body processing information
func (o *BillingAgreementsDeRegistrationParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommerceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *BillingAgreementsDeRegistrationParamsBodyProcessingInformation) validateCommerceIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CommerceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("modifyBillingAgreement"+"."+"processingInformation"+"."+"commerceIndicator", "body", o.CommerceIndicator, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this billing agreements de registration params body processing information based on context it is used
func (o *BillingAgreementsDeRegistrationParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *BillingAgreementsDeRegistrationParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res BillingAgreementsDeRegistrationParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
