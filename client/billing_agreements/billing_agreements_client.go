// Code generated by go-swagger; DO NOT EDIT.

package billing_agreements

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new billing agreements API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new billing agreements API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new billing agreements API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for billing agreements API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeApplicationJSONCharsetUTF8 sets the Content-Type header to "application/json;charset=utf-8".
func WithContentTypeApplicationJSONCharsetUTF8(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json;charset=utf-8"}
}

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationHalJSONCharsetUTF8 sets the Accept header to "application/hal+json;charset=utf-8".
func WithAcceptApplicationHalJSONCharsetUTF8(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/hal+json;charset=utf-8"}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	BillingAgreementsDeRegistration(params *BillingAgreementsDeRegistrationParams, opts ...ClientOption) (*BillingAgreementsDeRegistrationCreated, error)

	BillingAgreementsIntimation(params *BillingAgreementsIntimationParams, opts ...ClientOption) (*BillingAgreementsIntimationCreated, error)

	BillingAgreementsRegistration(params *BillingAgreementsRegistrationParams, opts ...ClientOption) (*BillingAgreementsRegistrationCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
	BillingAgreementsDeRegistration modifies a billing agreement

	#### Standing Instruction:

Standing Instruction with or without Token.

#### Revoke Mandate:
When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent.
When you revoke a mandate with no pending direct debits, the Bacs scheme or customer's bank notify you of any subsequent direct debit events.
When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate.
You can revoke a mandate when the customer:
  - Requests that you revoke the mandate.
  - Closes their account with you.

Possible revoke mandate status values -
  - Revoked—the revoke mandate request was successfully processed.
  - Failed—the revoke mandate request was not accepted.

#### Update Mandate:
In most cases, the account details of an existing mandate cannot be updated in the Bacs schema,
except by creating a new mandate. However, some very limited customer information, like name and address,
can be updated to the mandate without needing to revoke it first

#### Mandate Status:
After the customer signs the mandate, request that the mandate status service verify the mandate status.
Possible mandate status values:
  - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.
  - Pending—a pending mandate means the mandate is not yet signed.
  - Failed—the customer did not authenticate.
  - Expired—the deadline to create the mandate passed.
  - Revoked—the mandate is cancelled.

#### Paypal Billing Agreement:
A billing agreement is set up between PayPal and your customer.
When you collect the details of a customer's billing agreement, you are able to bill that customer without requiring an authorization for each payment.
You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes.
*/
func (a *Client) BillingAgreementsDeRegistration(params *BillingAgreementsDeRegistrationParams, opts ...ClientOption) (*BillingAgreementsDeRegistrationCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBillingAgreementsDeRegistrationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "billingAgreementsDeRegistration",
		Method:             "PATCH",
		PathPattern:        "/pts/v2/billing-agreements/{id}",
		ProducesMediaTypes: []string{"application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BillingAgreementsDeRegistrationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BillingAgreementsDeRegistrationCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for billingAgreementsDeRegistration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
BillingAgreementsIntimation standings instruction intimation

Standing Instruction with or without Token.
*/
func (a *Client) BillingAgreementsIntimation(params *BillingAgreementsIntimationParams, opts ...ClientOption) (*BillingAgreementsIntimationCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBillingAgreementsIntimationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "billingAgreementsIntimation",
		Method:             "POST",
		PathPattern:        "/pts/v2/billing-agreements/{id}/intimations",
		ProducesMediaTypes: []string{"application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BillingAgreementsIntimationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BillingAgreementsIntimationCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for billingAgreementsIntimation: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	BillingAgreementsRegistration creates a billing agreement

	#### Standing Instruction:

Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed

#### Create Mandate:
You can create a mandate through the direct debit mandate flow.
Possible create mandate status values:
  - Pending—the create mandate request was successfully processed.
  - Failed—the create mandate request was not accepted.

#### Import Mandate:
In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately.
You can import a mandate to the CyberSource database when:
  - You have existing customers with signed, active mandates
  - You manage mandates outside of CyberSource.

When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error.
If an import mandate request is not accepted, the import mandate status value is failed.
*/
func (a *Client) BillingAgreementsRegistration(params *BillingAgreementsRegistrationParams, opts ...ClientOption) (*BillingAgreementsRegistrationCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBillingAgreementsRegistrationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "billingAgreementsRegistration",
		Method:             "POST",
		PathPattern:        "/pts/v2/billing-agreements",
		ProducesMediaTypes: []string{"application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &BillingAgreementsRegistrationReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*BillingAgreementsRegistrationCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for billingAgreementsRegistration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
