// Code generated by go-swagger; DO NOT EDIT.

package replay_webhooks

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ReplayPreviousWebhooksReader is a Reader for the ReplayPreviousWebhooks structure.
type ReplayPreviousWebhooksReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *ReplayPreviousWebhooksReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 202:
		result := NewReplayPreviousWebhooksAccepted()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewReplayPreviousWebhooksBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewReplayPreviousWebhooksUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewReplayPreviousWebhooksNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewReplayPreviousWebhooksInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[POST /nrtf/v1/webhooks/{webhookId}/replays] replayPreviousWebhooks", response, response.Code())
	}
}

// NewReplayPreviousWebhooksAccepted creates a ReplayPreviousWebhooksAccepted with default headers values
func NewReplayPreviousWebhooksAccepted() *ReplayPreviousWebhooksAccepted {
	return &ReplayPreviousWebhooksAccepted{}
}

/*
ReplayPreviousWebhooksAccepted describes a response with status code 202, with default header values.

Accepted
*/
type ReplayPreviousWebhooksAccepted struct {
}

// IsSuccess returns true when this replay previous webhooks accepted response has a 2xx status code
func (o *ReplayPreviousWebhooksAccepted) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this replay previous webhooks accepted response has a 3xx status code
func (o *ReplayPreviousWebhooksAccepted) IsRedirect() bool {
	return false
}

// IsClientError returns true when this replay previous webhooks accepted response has a 4xx status code
func (o *ReplayPreviousWebhooksAccepted) IsClientError() bool {
	return false
}

// IsServerError returns true when this replay previous webhooks accepted response has a 5xx status code
func (o *ReplayPreviousWebhooksAccepted) IsServerError() bool {
	return false
}

// IsCode returns true when this replay previous webhooks accepted response a status code equal to that given
func (o *ReplayPreviousWebhooksAccepted) IsCode(code int) bool {
	return code == 202
}

// Code gets the status code for the replay previous webhooks accepted response
func (o *ReplayPreviousWebhooksAccepted) Code() int {
	return 202
}

func (o *ReplayPreviousWebhooksAccepted) Error() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksAccepted", 202)
}

func (o *ReplayPreviousWebhooksAccepted) String() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksAccepted", 202)
}

func (o *ReplayPreviousWebhooksAccepted) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewReplayPreviousWebhooksBadRequest creates a ReplayPreviousWebhooksBadRequest with default headers values
func NewReplayPreviousWebhooksBadRequest() *ReplayPreviousWebhooksBadRequest {
	return &ReplayPreviousWebhooksBadRequest{}
}

/*
ReplayPreviousWebhooksBadRequest describes a response with status code 400, with default header values.

Bad request
*/
type ReplayPreviousWebhooksBadRequest struct {
}

// IsSuccess returns true when this replay previous webhooks bad request response has a 2xx status code
func (o *ReplayPreviousWebhooksBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this replay previous webhooks bad request response has a 3xx status code
func (o *ReplayPreviousWebhooksBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this replay previous webhooks bad request response has a 4xx status code
func (o *ReplayPreviousWebhooksBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this replay previous webhooks bad request response has a 5xx status code
func (o *ReplayPreviousWebhooksBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this replay previous webhooks bad request response a status code equal to that given
func (o *ReplayPreviousWebhooksBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the replay previous webhooks bad request response
func (o *ReplayPreviousWebhooksBadRequest) Code() int {
	return 400
}

func (o *ReplayPreviousWebhooksBadRequest) Error() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksBadRequest", 400)
}

func (o *ReplayPreviousWebhooksBadRequest) String() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksBadRequest", 400)
}

func (o *ReplayPreviousWebhooksBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewReplayPreviousWebhooksUnauthorized creates a ReplayPreviousWebhooksUnauthorized with default headers values
func NewReplayPreviousWebhooksUnauthorized() *ReplayPreviousWebhooksUnauthorized {
	return &ReplayPreviousWebhooksUnauthorized{}
}

/*
ReplayPreviousWebhooksUnauthorized describes a response with status code 401, with default header values.

Unauthorized
*/
type ReplayPreviousWebhooksUnauthorized struct {
}

// IsSuccess returns true when this replay previous webhooks unauthorized response has a 2xx status code
func (o *ReplayPreviousWebhooksUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this replay previous webhooks unauthorized response has a 3xx status code
func (o *ReplayPreviousWebhooksUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this replay previous webhooks unauthorized response has a 4xx status code
func (o *ReplayPreviousWebhooksUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this replay previous webhooks unauthorized response has a 5xx status code
func (o *ReplayPreviousWebhooksUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this replay previous webhooks unauthorized response a status code equal to that given
func (o *ReplayPreviousWebhooksUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the replay previous webhooks unauthorized response
func (o *ReplayPreviousWebhooksUnauthorized) Code() int {
	return 401
}

func (o *ReplayPreviousWebhooksUnauthorized) Error() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksUnauthorized", 401)
}

func (o *ReplayPreviousWebhooksUnauthorized) String() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksUnauthorized", 401)
}

func (o *ReplayPreviousWebhooksUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewReplayPreviousWebhooksNotFound creates a ReplayPreviousWebhooksNotFound with default headers values
func NewReplayPreviousWebhooksNotFound() *ReplayPreviousWebhooksNotFound {
	return &ReplayPreviousWebhooksNotFound{}
}

/*
ReplayPreviousWebhooksNotFound describes a response with status code 404, with default header values.

Not Found
*/
type ReplayPreviousWebhooksNotFound struct {
}

// IsSuccess returns true when this replay previous webhooks not found response has a 2xx status code
func (o *ReplayPreviousWebhooksNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this replay previous webhooks not found response has a 3xx status code
func (o *ReplayPreviousWebhooksNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this replay previous webhooks not found response has a 4xx status code
func (o *ReplayPreviousWebhooksNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this replay previous webhooks not found response has a 5xx status code
func (o *ReplayPreviousWebhooksNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this replay previous webhooks not found response a status code equal to that given
func (o *ReplayPreviousWebhooksNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the replay previous webhooks not found response
func (o *ReplayPreviousWebhooksNotFound) Code() int {
	return 404
}

func (o *ReplayPreviousWebhooksNotFound) Error() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksNotFound", 404)
}

func (o *ReplayPreviousWebhooksNotFound) String() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksNotFound", 404)
}

func (o *ReplayPreviousWebhooksNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewReplayPreviousWebhooksInternalServerError creates a ReplayPreviousWebhooksInternalServerError with default headers values
func NewReplayPreviousWebhooksInternalServerError() *ReplayPreviousWebhooksInternalServerError {
	return &ReplayPreviousWebhooksInternalServerError{}
}

/*
ReplayPreviousWebhooksInternalServerError describes a response with status code 500, with default header values.

Server error
*/
type ReplayPreviousWebhooksInternalServerError struct {
}

// IsSuccess returns true when this replay previous webhooks internal server error response has a 2xx status code
func (o *ReplayPreviousWebhooksInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this replay previous webhooks internal server error response has a 3xx status code
func (o *ReplayPreviousWebhooksInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this replay previous webhooks internal server error response has a 4xx status code
func (o *ReplayPreviousWebhooksInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this replay previous webhooks internal server error response has a 5xx status code
func (o *ReplayPreviousWebhooksInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this replay previous webhooks internal server error response a status code equal to that given
func (o *ReplayPreviousWebhooksInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the replay previous webhooks internal server error response
func (o *ReplayPreviousWebhooksInternalServerError) Code() int {
	return 500
}

func (o *ReplayPreviousWebhooksInternalServerError) Error() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksInternalServerError", 500)
}

func (o *ReplayPreviousWebhooksInternalServerError) String() string {
	return fmt.Sprintf("[POST /nrtf/v1/webhooks/{webhookId}/replays][%d] replayPreviousWebhooksInternalServerError", 500)
}

func (o *ReplayPreviousWebhooksInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*
ReplayPreviousWebhooksBody replay previous webhooks body
// Example: {"deliveryStatus":{"endTime":"2021-02-25T21:35:52.284Z","startTime":"2021-02-25T09:35:52.284Z","status":"FAILED"},"transactionTraceIdentifiers":["1f1d0bf4-9299-418d-99d8-faa3313829f1","d19fb205-20e5-43a2-867e-bd0f574b771e","2f2461a3-457c-40e9-867f-aced89662bbb","e23ddc19-93d5-4f1f-8482-d7cafbb3ed9b","eb9fc4a9-b31f-48d5-81a9-b1d773fd76d8"]}
swagger:model ReplayPreviousWebhooksBody
*/
type ReplayPreviousWebhooksBody struct {

	// by delivery status
	ByDeliveryStatus *ReplayPreviousWebhooksParamsBodyByDeliveryStatus `json:"byDeliveryStatus,omitempty"`

	// by transaction trace identifiers
	ByTransactionTraceIdentifiers []string `json:"byTransactionTraceIdentifiers"`
}

// Validate validates this replay previous webhooks body
func (o *ReplayPreviousWebhooksBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateByDeliveryStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ReplayPreviousWebhooksBody) validateByDeliveryStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.ByDeliveryStatus) { // not required
		return nil
	}

	if o.ByDeliveryStatus != nil {
		if err := o.ByDeliveryStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replayWebhooksRequest" + "." + "byDeliveryStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replayWebhooksRequest" + "." + "byDeliveryStatus")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this replay previous webhooks body based on the context it is used
func (o *ReplayPreviousWebhooksBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateByDeliveryStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ReplayPreviousWebhooksBody) contextValidateByDeliveryStatus(ctx context.Context, formats strfmt.Registry) error {

	if o.ByDeliveryStatus != nil {

		if swag.IsZero(o.ByDeliveryStatus) { // not required
			return nil
		}

		if err := o.ByDeliveryStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replayWebhooksRequest" + "." + "byDeliveryStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("replayWebhooksRequest" + "." + "byDeliveryStatus")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ReplayPreviousWebhooksBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ReplayPreviousWebhooksBody) UnmarshalBinary(b []byte) error {
	var res ReplayPreviousWebhooksBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ReplayPreviousWebhooksParamsBodyByDeliveryStatus replay previous webhooks params body by delivery status
// Example: {"endTime":"2021-02-25T21:35:52.284Z","startTime":"2021-02-25T09:35:52.284Z","status":"FAILED"}
swagger:model ReplayPreviousWebhooksParamsBodyByDeliveryStatus
*/
type ReplayPreviousWebhooksParamsBodyByDeliveryStatus struct {

	// The end time in yyyy-mm-dd hh:mm:ss.ms format.
	//
	// The difference between Start Time and End Time cannot exceed a 24 hour window within the last month.
	//
	// Format: date-time
	EndTime strfmt.DateTime `json:"endTime,omitempty"`

	// event type
	EventType string `json:"eventType,omitempty"`

	// Alternative parameter to startTime/endTime.
	//
	// It evaluates the startTime using the current system time (endTime) and the hoursBack value (default = 24hrs).
	//
	HoursBack int64 `json:"hoursBack,omitempty"`

	// product Id
	ProductID string `json:"productId,omitempty"`

	// The start time in yyyy-mm-dd hh:mm:ss.ms format. Maximum value is 1 month prior to todays system time.
	//
	// The difference between Start Time and End Time cannot exceed a 24 hour window within the last month.
	//
	// Format: date-time
	StartTime strfmt.DateTime `json:"startTime,omitempty"`

	// The status of the webhook. Options are FAILED or RETRY
	Status string `json:"status,omitempty"`
}

// Validate validates this replay previous webhooks params body by delivery status
func (o *ReplayPreviousWebhooksParamsBodyByDeliveryStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEndTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ReplayPreviousWebhooksParamsBodyByDeliveryStatus) validateEndTime(formats strfmt.Registry) error {
	if swag.IsZero(o.EndTime) { // not required
		return nil
	}

	if err := validate.FormatOf("replayWebhooksRequest"+"."+"byDeliveryStatus"+"."+"endTime", "body", "date-time", o.EndTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *ReplayPreviousWebhooksParamsBodyByDeliveryStatus) validateStartTime(formats strfmt.Registry) error {
	if swag.IsZero(o.StartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("replayWebhooksRequest"+"."+"byDeliveryStatus"+"."+"startTime", "body", "date-time", o.StartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this replay previous webhooks params body by delivery status based on context it is used
func (o *ReplayPreviousWebhooksParamsBodyByDeliveryStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ReplayPreviousWebhooksParamsBodyByDeliveryStatus) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ReplayPreviousWebhooksParamsBodyByDeliveryStatus) UnmarshalBinary(b []byte) error {
	var res ReplayPreviousWebhooksParamsBodyByDeliveryStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
