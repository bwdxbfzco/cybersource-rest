// Code generated by go-swagger; DO NOT EDIT.

package invoices

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GetInvoiceReader is a Reader for the GetInvoice structure.
type GetInvoiceReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetInvoiceReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetInvoiceOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewGetInvoiceBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewGetInvoiceNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		result := NewGetInvoiceDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewGetInvoiceOK creates a GetInvoiceOK with default headers values
func NewGetInvoiceOK() *GetInvoiceOK {
	return &GetInvoiceOK{}
}

/*
GetInvoiceOK describes a response with status code 200, with default header values.

OK.
*/
type GetInvoiceOK struct {
	Payload *GetInvoiceOKBody
}

// IsSuccess returns true when this get invoice o k response has a 2xx status code
func (o *GetInvoiceOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get invoice o k response has a 3xx status code
func (o *GetInvoiceOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get invoice o k response has a 4xx status code
func (o *GetInvoiceOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get invoice o k response has a 5xx status code
func (o *GetInvoiceOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get invoice o k response a status code equal to that given
func (o *GetInvoiceOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get invoice o k response
func (o *GetInvoiceOK) Code() int {
	return 200
}

func (o *GetInvoiceOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoiceOK %s", 200, payload)
}

func (o *GetInvoiceOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoiceOK %s", 200, payload)
}

func (o *GetInvoiceOK) GetPayload() *GetInvoiceOKBody {
	return o.Payload
}

func (o *GetInvoiceOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetInvoiceOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetInvoiceBadRequest creates a GetInvoiceBadRequest with default headers values
func NewGetInvoiceBadRequest() *GetInvoiceBadRequest {
	return &GetInvoiceBadRequest{}
}

/*
GetInvoiceBadRequest describes a response with status code 400, with default header values.

Invoicing service is not enabled.
*/
type GetInvoiceBadRequest struct {
	Payload *GetInvoiceBadRequestBody
}

// IsSuccess returns true when this get invoice bad request response has a 2xx status code
func (o *GetInvoiceBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get invoice bad request response has a 3xx status code
func (o *GetInvoiceBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get invoice bad request response has a 4xx status code
func (o *GetInvoiceBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this get invoice bad request response has a 5xx status code
func (o *GetInvoiceBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this get invoice bad request response a status code equal to that given
func (o *GetInvoiceBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the get invoice bad request response
func (o *GetInvoiceBadRequest) Code() int {
	return 400
}

func (o *GetInvoiceBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoiceBadRequest %s", 400, payload)
}

func (o *GetInvoiceBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoiceBadRequest %s", 400, payload)
}

func (o *GetInvoiceBadRequest) GetPayload() *GetInvoiceBadRequestBody {
	return o.Payload
}

func (o *GetInvoiceBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetInvoiceBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetInvoiceNotFound creates a GetInvoiceNotFound with default headers values
func NewGetInvoiceNotFound() *GetInvoiceNotFound {
	return &GetInvoiceNotFound{}
}

/*
GetInvoiceNotFound describes a response with status code 404, with default header values.

Invoice does not exist.
*/
type GetInvoiceNotFound struct {
	Payload *GetInvoiceNotFoundBody
}

// IsSuccess returns true when this get invoice not found response has a 2xx status code
func (o *GetInvoiceNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get invoice not found response has a 3xx status code
func (o *GetInvoiceNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get invoice not found response has a 4xx status code
func (o *GetInvoiceNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this get invoice not found response has a 5xx status code
func (o *GetInvoiceNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this get invoice not found response a status code equal to that given
func (o *GetInvoiceNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the get invoice not found response
func (o *GetInvoiceNotFound) Code() int {
	return 404
}

func (o *GetInvoiceNotFound) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoiceNotFound %s", 404, payload)
}

func (o *GetInvoiceNotFound) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoiceNotFound %s", 404, payload)
}

func (o *GetInvoiceNotFound) GetPayload() *GetInvoiceNotFoundBody {
	return o.Payload
}

func (o *GetInvoiceNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetInvoiceNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetInvoiceDefault creates a GetInvoiceDefault with default headers values
func NewGetInvoiceDefault(code int) *GetInvoiceDefault {
	return &GetInvoiceDefault{
		_statusCode: code,
	}
}

/*
GetInvoiceDefault describes a response with status code -1, with default header values.

Unexpected error.
*/
type GetInvoiceDefault struct {
	_statusCode int

	Payload *GetInvoiceDefaultBody
}

// IsSuccess returns true when this get invoice default response has a 2xx status code
func (o *GetInvoiceDefault) IsSuccess() bool {
	return o._statusCode/100 == 2
}

// IsRedirect returns true when this get invoice default response has a 3xx status code
func (o *GetInvoiceDefault) IsRedirect() bool {
	return o._statusCode/100 == 3
}

// IsClientError returns true when this get invoice default response has a 4xx status code
func (o *GetInvoiceDefault) IsClientError() bool {
	return o._statusCode/100 == 4
}

// IsServerError returns true when this get invoice default response has a 5xx status code
func (o *GetInvoiceDefault) IsServerError() bool {
	return o._statusCode/100 == 5
}

// IsCode returns true when this get invoice default response a status code equal to that given
func (o *GetInvoiceDefault) IsCode(code int) bool {
	return o._statusCode == code
}

// Code gets the status code for the get invoice default response
func (o *GetInvoiceDefault) Code() int {
	return o._statusCode
}

func (o *GetInvoiceDefault) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoice default %s", o._statusCode, payload)
}

func (o *GetInvoiceDefault) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /invoicing/v2/invoices/{id}][%d] getInvoice default %s", o._statusCode, payload)
}

func (o *GetInvoiceDefault) GetPayload() *GetInvoiceDefaultBody {
	return o.Payload
}

func (o *GetInvoiceDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetInvoiceDefaultBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
GetInvoiceBadRequestBody invoicingV2InvoicesGet400Response
// Example: {"details":[{"field":"customerInformation.email","reason":"Invalid email"}],"message":"Field validation errors.","reason":"VALIDATION_ERROR","status":"BADREQUEST","submitTimeUtc":"2019-07-01T21:40:10Z"}
swagger:model GetInvoiceBadRequestBody
*/
type GetInvoiceBadRequestBody struct {

	// details
	Details []*GetInvoiceBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - PROCESSOR_UNAVAILABLE
	//
	Reason string `json:"reason,omitempty"`

	// The status of the invoice.
	//
	// Possible values:
	//   - BADREQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get invoice bad request body
func (o *GetInvoiceBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get invoice bad request body based on the context it is used
func (o *GetInvoiceBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceBadRequestBody) UnmarshalBinary(b []byte) error {
	var res GetInvoiceBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceBadRequestBodyDetailsItems0 get invoice bad request body details items0
swagger:model GetInvoiceBadRequestBodyDetailsItems0
*/
type GetInvoiceBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this get invoice bad request body details items0
func (o *GetInvoiceBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get invoice bad request body details items0 based on context it is used
func (o *GetInvoiceBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetInvoiceBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceDefaultBody invoicingV2InvoicesGet502Response
// Example: {"message":"Error - General system failure.","reason":"SERVER_ERROR","status":"SERVER_ERROR","submitTimeUtc":"2018-06-12T09:27:20.000Z"}
swagger:model GetInvoiceDefaultBody
*/
type GetInvoiceDefaultBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get invoice default body
func (o *GetInvoiceDefaultBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get invoice default body based on context it is used
func (o *GetInvoiceDefaultBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceDefaultBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceDefaultBody) UnmarshalBinary(b []byte) error {
	var res GetInvoiceDefaultBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceNotFoundBody invoicingV2InvoicesGet404Response
// Example: {"message":"Invoice does not exist.","reason":"NOT_FOUND","status":"NOTFOUND","submitTimeUtc":"2019-07-01T21:36:29Z"}
swagger:model GetInvoiceNotFoundBody
*/
type GetInvoiceNotFoundBody struct {

	// details
	Details []*GetInvoiceNotFoundBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - PROCESSOR_UNAVAILABLE
	//
	Reason string `json:"reason,omitempty"`

	// The status of the invoice.
	//
	// Possible values:
	//  - NOTFOUND
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get invoice not found body
func (o *GetInvoiceNotFoundBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceNotFoundBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceNotFound" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceNotFound" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get invoice not found body based on the context it is used
func (o *GetInvoiceNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceNotFoundBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceNotFound" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceNotFound" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceNotFoundBody) UnmarshalBinary(b []byte) error {
	var res GetInvoiceNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceNotFoundBodyDetailsItems0 get invoice not found body details items0
swagger:model GetInvoiceNotFoundBodyDetailsItems0
*/
type GetInvoiceNotFoundBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this get invoice not found body details items0
func (o *GetInvoiceNotFoundBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get invoice not found body details items0 based on context it is used
func (o *GetInvoiceNotFoundBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceNotFoundBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceNotFoundBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetInvoiceNotFoundBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBody invoicingV2InvoicesGet200Response
// Example: {"_links":{"self":{"href":"/rest/v2/invoices/A123","method":"GET"}},"customerInformation":{"company":{"name":"ABC"},"email":"tanya.lee@my-email.world","merchantCustomerId":"1234","name":"Tanya Lee"},"id":"A123","invoiceHistory":[{"date":"2019-06-18T21:57:31.09Z","event":"PAYMENT","transactionDetails":{"amount":"111.74","transactionId":"2155897958"}},{"date":"2019-06-18T21:55:01.02Z","event":"RESEND"},{"date":"2019-06-18T21:51:19.09Z","event":"SEND"},{"date":"2019-06-18T21:51:18.76Z","event":"CREATE"}],"invoiceInformation":{"allowPartialPayments":false,"deliveryMode":"email","description":"This is a test invoice","dueDate":"2019-07-11","invoiceNumber":"A123","paymentLink":"https://ebc.cybersource.com/ebc2/invoicing/payInvoice/c7UI9Vz8rdhXbc8FdK6SaoeOATON4TQLhbd5lfib9UCyywvZLhIrSuYYNFMynMCc"},"orderInformation":{"amountDetails":{"balanceAmount":"11843.71","currency":"USD","discountAmount":"1402.60","discountPercent":"10.5","freight":{"amount":"40.00","taxable":true},"minimumPartialAmount":"100.00","subAmount":"13358.05","taxDetails":{"amount":"1018.05","rate":"8.25","type":"State Tax"},"totalAmount":"11955.45"},"lineItems":[{"discountAmount":"13.04","discountPercent":"5.0","productName":"First line item's name","productSku":"P653727383","quantity":"20","taxAmount":"0.0","taxRate":"0.0","totalAmount":"247.86","unitPrice":"12.05"}]},"status":"SENT","submitTimeUtc":"2019-07-01T22:37:14Z","supportedActions":[{"href":"/rest/v2/invoices/A123/delivery","method":"POST"},{"href":"/rest/v2/invoices/A123","method":"PUT"},{"href":"/rest/v2/invoices/A123/cancelation","method":"POST"}]}
swagger:model GetInvoiceOKBody
*/
type GetInvoiceOKBody struct {

	// links
	Links *GetInvoiceOKBodyLinks `json:"_links,omitempty"`

	// customer information
	CustomerInformation *GetInvoiceOKBodyCustomerInformation `json:"customerInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// invoice history
	InvoiceHistory []*GetInvoiceOKBodyInvoiceHistoryItems0 `json:"invoiceHistory"`

	// invoice information
	InvoiceInformation *GetInvoiceOKBodyInvoiceInformation `json:"invoiceInformation,omitempty"`

	// order information
	OrderInformation *GetInvoiceOKBodyOrderInformation `json:"orderInformation,omitempty"`

	// The status of the invoice.
	//
	// Possible values:
	// - DRAFT
	// - CREATED
	// - SENT
	// - PARTIAL
	// - PAID
	// - CANCELED
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get invoice o k body
func (o *GetInvoiceOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceHistory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBody) validateCustomerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerInformation) { // not required
		return nil
	}

	if o.CustomerInformation != nil {
		if err := o.CustomerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "customerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "customerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBody) validateInvoiceHistory(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceHistory) { // not required
		return nil
	}

	for i := 0; i < len(o.InvoiceHistory); i++ {
		if swag.IsZero(o.InvoiceHistory[i]) { // not required
			continue
		}

		if o.InvoiceHistory[i] != nil {
			if err := o.InvoiceHistory[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceOK" + "." + "invoiceHistory" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceOK" + "." + "invoiceHistory" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetInvoiceOKBody) validateInvoiceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceInformation) { // not required
		return nil
	}

	if o.InvoiceInformation != nil {
		if err := o.InvoiceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "invoiceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "invoiceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get invoice o k body based on the context it is used
func (o *GetInvoiceOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceHistory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBody) contextValidateCustomerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.CustomerInformation != nil {

		if swag.IsZero(o.CustomerInformation) { // not required
			return nil
		}

		if err := o.CustomerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "customerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "customerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBody) contextValidateInvoiceHistory(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.InvoiceHistory); i++ {

		if o.InvoiceHistory[i] != nil {

			if swag.IsZero(o.InvoiceHistory[i]) { // not required
				return nil
			}

			if err := o.InvoiceHistory[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceOK" + "." + "invoiceHistory" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceOK" + "." + "invoiceHistory" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetInvoiceOKBody) contextValidateInvoiceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceInformation != nil {

		if swag.IsZero(o.InvoiceInformation) { // not required
			return nil
		}

		if err := o.InvoiceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "invoiceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "invoiceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBody) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyCustomerInformation Contains all of the customer-related fields for the invoice.
swagger:model GetInvoiceOKBodyCustomerInformation
*/
type GetInvoiceOKBodyCustomerInformation struct {

	// company
	Company *GetInvoiceOKBodyCustomerInformationCompany `json:"company,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customer's contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// Payer name for the invoice.
	// Max Length: 100
	Name string `json:"name,omitempty"`
}

// Validate validates this get invoice o k body customer information
func (o *GetInvoiceOKBodyCustomerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyCustomerInformation) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if o.Company != nil {
		if err := o.Company.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "customerInformation" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "customerInformation" + "." + "company")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyCustomerInformation) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"customerInformation"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyCustomerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"customerInformation"+"."+"merchantCustomerId", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyCustomerInformation) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"customerInformation"+"."+"name", "body", o.Name, 100); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get invoice o k body customer information based on the context it is used
func (o *GetInvoiceOKBodyCustomerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCompany(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyCustomerInformation) contextValidateCompany(ctx context.Context, formats strfmt.Registry) error {

	if o.Company != nil {

		if swag.IsZero(o.Company) { // not required
			return nil
		}

		if err := o.Company.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "customerInformation" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "customerInformation" + "." + "company")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyCustomerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyCustomerInformation) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyCustomerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyCustomerInformationCompany get invoice o k body customer information company
swagger:model GetInvoiceOKBodyCustomerInformationCompany
*/
type GetInvoiceOKBodyCustomerInformationCompany struct {

	// Name of the customer's company.
	//
	// **CyberSource through VisaNet**
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `company_name` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Name string `json:"name,omitempty"`
}

// Validate validates this get invoice o k body customer information company
func (o *GetInvoiceOKBodyCustomerInformationCompany) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyCustomerInformationCompany) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"customerInformation"+"."+"company"+"."+"name", "body", o.Name, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get invoice o k body customer information company based on context it is used
func (o *GetInvoiceOKBodyCustomerInformationCompany) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyCustomerInformationCompany) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyCustomerInformationCompany) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyCustomerInformationCompany
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyInvoiceHistoryItems0 get invoice o k body invoice history items0
swagger:model GetInvoiceOKBodyInvoiceHistoryItems0
*/
type GetInvoiceOKBodyInvoiceHistoryItems0 struct {

	// The date and time when the invoice event was triggered in ISO 8601 format. Format: YYYY-MM-DDThh:mm:ssZ
	//
	// Format: date-time
	Date strfmt.DateTime `json:"date,omitempty"`

	// The event triggered for the invoice.
	//
	// Possible values:
	//  - `CREATE`
	//  - `UPDATE`
	//  - `SEND`
	//  - `RESEND`
	//  - `REMINDER`
	//  - `PAYMENT`
	//  - `CANCEL`
	//
	Event string `json:"event,omitempty"`

	// transaction details
	TransactionDetails *GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails `json:"transactionDetails,omitempty"`
}

// Validate validates this get invoice o k body invoice history items0
func (o *GetInvoiceOKBodyInvoiceHistoryItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyInvoiceHistoryItems0) validateDate(formats strfmt.Registry) error {
	if swag.IsZero(o.Date) { // not required
		return nil
	}

	if err := validate.FormatOf("date", "body", "date-time", o.Date.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyInvoiceHistoryItems0) validateTransactionDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionDetails) { // not required
		return nil
	}

	if o.TransactionDetails != nil {
		if err := o.TransactionDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transactionDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transactionDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get invoice o k body invoice history items0 based on the context it is used
func (o *GetInvoiceOKBodyInvoiceHistoryItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTransactionDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyInvoiceHistoryItems0) contextValidateTransactionDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.TransactionDetails != nil {

		if swag.IsZero(o.TransactionDetails) { // not required
			return nil
		}

		if err := o.TransactionDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("transactionDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("transactionDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyInvoiceHistoryItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyInvoiceHistoryItems0) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyInvoiceHistoryItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails These details are only returned when the invoice event is `payment`.
swagger:model GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails
*/
type GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails struct {

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	Amount string `json:"amount,omitempty"`

	// Payer auth Transaction identifier.
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this get invoice o k body invoice history items0 transaction details
func (o *GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("transactionDetails"+"."+"amount", "body", o.Amount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get invoice o k body invoice history items0 transaction details based on context it is used
func (o *GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyInvoiceHistoryItems0TransactionDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyInvoiceInformation Contains all of the invoice-specific fields, such as the invoice number and due date.
swagger:model GetInvoiceOKBodyInvoiceInformation
*/
type GetInvoiceOKBodyInvoiceInformation struct {

	// If set to `true`, the payer can make a partial invoice payment.
	AllowPartialPayments bool `json:"allowPartialPayments,omitempty"`

	// If set to `None`, the invoice is created, and its status is set to 'CREATED', but no email is sent.
	//
	// Possible values:
	//  - `None`
	//  - `Email`
	//
	DeliveryMode string `json:"deliveryMode,omitempty"`

	// The description included in the invoice.
	// Max Length: 2000
	Description string `json:"description,omitempty"`

	// The invoice due date. This field is required for creating an invoice.
	// Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day
	//
	// Max Length: 10
	// Format: date
	DueDate strfmt.Date `json:"dueDate,omitempty"`

	// Invoice Number.
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Returns the payment link to an invoice when the invoice status is `SENT`, `CREATED`, `PARTIAL`, or `PAID`.
	PaymentLink string `json:"paymentLink,omitempty"`
}

// Validate validates this get invoice o k body invoice information
func (o *GetInvoiceOKBodyInvoiceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDueDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyInvoiceInformation) validateDescription(formats strfmt.Registry) error {
	if swag.IsZero(o.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"invoiceInformation"+"."+"description", "body", o.Description, 2000); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyInvoiceInformation) validateDueDate(formats strfmt.Registry) error {
	if swag.IsZero(o.DueDate) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"invoiceInformation"+"."+"dueDate", "body", o.DueDate.String(), 10); err != nil {
		return err
	}

	if err := validate.FormatOf("getInvoiceOK"+"."+"invoiceInformation"+"."+"dueDate", "body", "date", o.DueDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get invoice o k body invoice information based on context it is used
func (o *GetInvoiceOKBodyInvoiceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyInvoiceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyInvoiceInformation) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyInvoiceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyLinks get invoice o k body links
swagger:model GetInvoiceOKBodyLinks
*/
type GetInvoiceOKBodyLinks struct {

	// cancel
	Cancel *GetInvoiceOKBodyLinksCancel `json:"cancel,omitempty"`

	// deliver
	Deliver *GetInvoiceOKBodyLinksDeliver `json:"deliver,omitempty"`

	// self
	Self *GetInvoiceOKBodyLinksSelf `json:"self,omitempty"`

	// update
	Update *GetInvoiceOKBodyLinksUpdate `json:"update,omitempty"`
}

// Validate validates this get invoice o k body links
func (o *GetInvoiceOKBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCancel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeliver(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUpdate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyLinks) validateCancel(formats strfmt.Registry) error {
	if swag.IsZero(o.Cancel) { // not required
		return nil
	}

	if o.Cancel != nil {
		if err := o.Cancel.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "cancel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "cancel")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyLinks) validateDeliver(formats strfmt.Registry) error {
	if swag.IsZero(o.Deliver) { // not required
		return nil
	}

	if o.Deliver != nil {
		if err := o.Deliver.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "deliver")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "deliver")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyLinks) validateUpdate(formats strfmt.Registry) error {
	if swag.IsZero(o.Update) { // not required
		return nil
	}

	if o.Update != nil {
		if err := o.Update.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "update")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "update")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get invoice o k body links based on the context it is used
func (o *GetInvoiceOKBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCancel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeliver(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateUpdate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyLinks) contextValidateCancel(ctx context.Context, formats strfmt.Registry) error {

	if o.Cancel != nil {

		if swag.IsZero(o.Cancel) { // not required
			return nil
		}

		if err := o.Cancel.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "cancel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "cancel")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyLinks) contextValidateDeliver(ctx context.Context, formats strfmt.Registry) error {

	if o.Deliver != nil {

		if swag.IsZero(o.Deliver) { // not required
			return nil
		}

		if err := o.Deliver.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "deliver")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "deliver")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyLinks) contextValidateUpdate(ctx context.Context, formats strfmt.Registry) error {

	if o.Update != nil {

		if swag.IsZero(o.Update) { // not required
			return nil
		}

		if err := o.Update.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "_links" + "." + "update")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "_links" + "." + "update")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinks) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyLinksCancel get invoice o k body links cancel
swagger:model GetInvoiceOKBodyLinksCancel
*/
type GetInvoiceOKBodyLinksCancel struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this get invoice o k body links cancel
func (o *GetInvoiceOKBodyLinksCancel) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get invoice o k body links cancel based on context it is used
func (o *GetInvoiceOKBodyLinksCancel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksCancel) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksCancel) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyLinksCancel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyLinksDeliver get invoice o k body links deliver
swagger:model GetInvoiceOKBodyLinksDeliver
*/
type GetInvoiceOKBodyLinksDeliver struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this get invoice o k body links deliver
func (o *GetInvoiceOKBodyLinksDeliver) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get invoice o k body links deliver based on context it is used
func (o *GetInvoiceOKBodyLinksDeliver) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksDeliver) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksDeliver) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyLinksDeliver
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyLinksSelf get invoice o k body links self
swagger:model GetInvoiceOKBodyLinksSelf
*/
type GetInvoiceOKBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this get invoice o k body links self
func (o *GetInvoiceOKBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get invoice o k body links self based on context it is used
func (o *GetInvoiceOKBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyLinksUpdate get invoice o k body links update
swagger:model GetInvoiceOKBodyLinksUpdate
*/
type GetInvoiceOKBodyLinksUpdate struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this get invoice o k body links update
func (o *GetInvoiceOKBodyLinksUpdate) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get invoice o k body links update based on context it is used
func (o *GetInvoiceOKBodyLinksUpdate) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksUpdate) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyLinksUpdate) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyLinksUpdate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyOrderInformation Contains all of the order-related fields for the invoice.
swagger:model GetInvoiceOKBodyOrderInformation
*/
type GetInvoiceOKBodyOrderInformation struct {

	// amount details
	AmountDetails *GetInvoiceOKBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// line items
	// Max Items: 30
	LineItems []*GetInvoiceOKBodyOrderInformationLineItemsItems0 `json:"lineItems"`
}

// Validate validates this get invoice o k body order information
func (o *GetInvoiceOKBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	iLineItemsSize := int64(len(o.LineItems))

	if err := validate.MaxItems("getInvoiceOK"+"."+"orderInformation"+"."+"lineItems", "body", iLineItemsSize, 30); err != nil {
		return err
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get invoice o k body order information based on the context it is used
func (o *GetInvoiceOKBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {

			if swag.IsZero(o.LineItems[i]) { // not required
				return nil
			}

			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyOrderInformationAmountDetails Contains all of the amount-related fields in the invoice.
swagger:model GetInvoiceOKBodyOrderInformationAmountDetails
*/
type GetInvoiceOKBodyOrderInformationAmountDetails struct {

	// Remaining balance on the account.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Remaining balance on the prepaid card.
	//
	// Returned by PIN debit purchase.
	//
	// Max Length: 12
	BalanceAmount string `json:"balanceAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Total discount amount applied to the order.
	//
	// Max Length: 15
	DiscountAmount string `json:"discountAmount,omitempty"`

	// The total discount percentage applied to the invoice.
	DiscountPercent float64 `json:"discountPercent,omitempty"`

	// freight
	Freight *GetInvoiceOKBodyOrderInformationAmountDetailsFreight `json:"freight,omitempty"`

	// The minimum partial amount required to pay the invoice.
	MinimumPartialAmount float64 `json:"minimumPartialAmount,omitempty"`

	// Sub-amount of the invoice.
	SubAmount float64 `json:"subAmount,omitempty"`

	// tax details
	TaxDetails *GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails `json:"taxDetails,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this get invoice o k body order information amount details
func (o *GetInvoiceOKBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBalanceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFreight(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) validateBalanceAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.BalanceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"balanceAmount", "body", o.BalanceAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", o.DiscountAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) validateFreight(formats strfmt.Registry) error {
	if swag.IsZero(o.Freight) { // not required
		return nil
	}

	if o.Freight != nil {
		if err := o.Freight.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "freight")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "freight")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	if o.TaxDetails != nil {
		if err := o.TaxDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get invoice o k body order information amount details based on the context it is used
func (o *GetInvoiceOKBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateFreight(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) contextValidateFreight(ctx context.Context, formats strfmt.Registry) error {

	if o.Freight != nil {

		if swag.IsZero(o.Freight) { // not required
			return nil
		}

		if err := o.Freight.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "freight")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "freight")
			}
			return err
		}
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetails) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.TaxDetails != nil {

		if swag.IsZero(o.TaxDetails) { // not required
			return nil
		}

		if err := o.TaxDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getInvoiceOK" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyOrderInformationAmountDetailsFreight Contains all of the shipping-related fields for the invoice.
swagger:model GetInvoiceOKBodyOrderInformationAmountDetailsFreight
*/
type GetInvoiceOKBodyOrderInformationAmountDetailsFreight struct {

	// Total freight or shipping and handling charges for the order. When you include this field in your request, you
	// must also include the **totalAmount** field.
	//
	// For processor-specific information, see the freight_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Shipping Tax rate applied to the freight amount.
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.
	//
	// If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include
	// `invoiceDetails.taxable` in the data it sends to the processor.
	//
	// For processor-specific information, see the `tax_indicator` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	Taxable bool `json:"taxable,omitempty"`
}

// Validate validates this get invoice o k body order information amount details freight
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsFreight) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetailsFreight) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"freight"+"."+"amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetailsFreight) validateTaxRate(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"freight"+"."+"taxRate", "body", o.TaxRate, 7); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get invoice o k body order information amount details freight based on context it is used
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsFreight) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsFreight) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsFreight) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyOrderInformationAmountDetailsFreight
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails Contains all of the tax-related fields for the invoice.
swagger:model GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails
*/
type GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// | ------------- |:-------------:|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of value added tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	// | `green`     | Green tax amount for Korean Processing. |
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	// - `green`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this get invoice o k body order information amount details tax details
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxDetails"+"."+"amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("getInvoiceOK"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxDetails"+"."+"rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get invoice o k body order information amount details tax details based on context it is used
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyOrderInformationAmountDetailsTaxDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetInvoiceOKBodyOrderInformationLineItemsItems0 List of the line items from the order, which are included in an invoice.
swagger:model GetInvoiceOKBodyOrderInformationLineItemsItems0
*/
type GetInvoiceOKBodyOrderInformationLineItemsItems0 struct {

	// Discount applied to the item.
	// Max Length: 13
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Rate the item is discounted. Maximum of 2 decimal places.
	//
	// Example 5.25 (=5.25%)
	//
	// Max Length: 6
	DiscountRate string `json:"discountRate,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is
	// required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSku string `json:"productSku,omitempty"`

	// Number of units for this order. Must be a non-negative integer.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values
	// related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Maximum: 9.99999999e+08
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// Optional field.
	//
	// #### Airlines processing
	// Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s).
	// Format: English characters only.
	// Optional request field for a line item.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Note if you send this field in your tax request, the value in the field will override the tax engine
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Tax rate applied to the item.
	//
	// For details, see `tax_rate` field description in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Tax Calculation
	// Required field for U.S., Canadian, international and value added taxes.
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`
}

// Validate validates this get invoice o k body order information line items items0
func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSku(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("discountAmount", "body", o.DiscountAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateDiscountRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountRate) { // not required
		return nil
	}

	if err := validate.MaxLength("discountRate", "body", o.DiscountRate, 6); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", o.ProductName, 255); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateProductSku(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductSku) { // not required
		return nil
	}

	if err := validate.MaxLength("productSku", "body", o.ProductSku, 255); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {
	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", o.Quantity, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", o.Quantity, 9.99999999e+08, false); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateTaxRate(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRate", "body", o.TaxRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", o.TotalAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", o.UnitPrice, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get invoice o k body order information line items items0 based on context it is used
func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetInvoiceOKBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res GetInvoiceOKBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
