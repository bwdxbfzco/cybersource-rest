// Code generated by go-swagger; DO NOT EDIT.

package invoices

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new invoices API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new invoices API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new invoices API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for invoices API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeApplicationJSONCharsetUTF8 sets the Content-Type header to "application/json;charset=utf-8".
func WithContentTypeApplicationJSONCharsetUTF8(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json;charset=utf-8"}
}

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationHalJSON sets the Accept header to "application/hal+json".
func WithAcceptApplicationHalJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/hal+json"}
}

// WithAcceptApplicationHalJSONCharsetUTF8 sets the Accept header to "application/hal+json;charset=utf-8".
func WithAcceptApplicationHalJSONCharsetUTF8(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/hal+json;charset=utf-8"}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptApplicationJSONCharsetUTF8 sets the Accept header to "application/json;charset=utf-8".
func WithAcceptApplicationJSONCharsetUTF8(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json;charset=utf-8"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	CreateInvoice(params *CreateInvoiceParams, opts ...ClientOption) (*CreateInvoiceCreated, *CreateInvoiceAccepted, error)

	GetAllInvoices(params *GetAllInvoicesParams, opts ...ClientOption) (*GetAllInvoicesOK, error)

	GetInvoice(params *GetInvoiceParams, opts ...ClientOption) (*GetInvoiceOK, error)

	PerformCancelAction(params *PerformCancelActionParams, opts ...ClientOption) (*PerformCancelActionOK, error)

	PerformSendAction(params *PerformSendActionParams, opts ...ClientOption) (*PerformSendActionOK, error)

	UpdateInvoice(params *UpdateInvoiceParams, opts ...ClientOption) (*UpdateInvoiceOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateInvoice creates a new invoice

The invoicing product enables you to bill any customer with an email address and accept digital payments securely from any connected device. You can either use the system generated email or use the invoice payment link in your own communication. You can add discounts and taxes for the entire invoice or for each line item. To customize the invoice to match your brand see [Invoice Settings](https://developer.cybersource.com/api-reference-assets/index.html#invoicing_invoice-settings_update-invoice-settings). The invoice payment page uses Unified Checkout to process the payments.
*/
func (a *Client) CreateInvoice(params *CreateInvoiceParams, opts ...ClientOption) (*CreateInvoiceCreated, *CreateInvoiceAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createInvoice",
		Method:             "POST",
		PathPattern:        "/invoicing/v2/invoices",
		ProducesMediaTypes: []string{"application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateInvoiceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateInvoiceCreated:
		return value, nil, nil
	case *CreateInvoiceAccepted:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateInvoiceDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAllInvoices gets a list of invoices

Provides a (filtered) list of invoices that have been created in your account. You can filter the list based on Invoice Status by setting the status query parameter to one of DRAFT, CREATED, SENT, PARTIAL, PAID or CANCELED.
*/
func (a *Client) GetAllInvoices(params *GetAllInvoicesParams, opts ...ClientOption) (*GetAllInvoicesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAllInvoicesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAllInvoices",
		Method:             "GET",
		PathPattern:        "/invoicing/v2/invoices",
		ProducesMediaTypes: []string{"application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAllInvoicesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAllInvoicesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAllInvoicesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetInvoice gets invoice details

You can retrieve details of a specific invoice. This can be used to check the Invoice status and get a list of invoice payments in the invoice history section of the response. For each payment transaction you can use the Transaction Details API to get more details on the payment transaction.
*/
func (a *Client) GetInvoice(params *GetInvoiceParams, opts ...ClientOption) (*GetInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getInvoice",
		Method:             "GET",
		PathPattern:        "/invoicing/v2/invoices/{id}",
		ProducesMediaTypes: []string{"application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInvoiceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetInvoiceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PerformCancelAction cancels an invoice

You can cancel an invoice if no payment is made to it. You cannot cancel partially or fully paid invoices.
*/
func (a *Client) PerformCancelAction(params *PerformCancelActionParams, opts ...ClientOption) (*PerformCancelActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPerformCancelActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "performCancelAction",
		Method:             "POST",
		PathPattern:        "/invoicing/v2/invoices/{id}/cancelation",
		ProducesMediaTypes: []string{"application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PerformCancelActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PerformCancelActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PerformCancelActionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PerformSendAction sends an invoice

You can send an invoice in draft or created state or resend a sent or partially paid invoice. Fully paid or canceled invoices cannot be resent.
*/
func (a *Client) PerformSendAction(params *PerformSendActionParams, opts ...ClientOption) (*PerformSendActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPerformSendActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "performSendAction",
		Method:             "POST",
		PathPattern:        "/invoicing/v2/invoices/{id}/delivery",
		ProducesMediaTypes: []string{"application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PerformSendActionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PerformSendActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PerformSendActionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateInvoice updates an invoice

You can update all information except the invoice number till any payment is received for an invoice. Invoices that are partially or fully paid or cancelled cannot be updated.
*/
func (a *Client) UpdateInvoice(params *UpdateInvoiceParams, opts ...ClientOption) (*UpdateInvoiceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateInvoiceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateInvoice",
		Method:             "PUT",
		PathPattern:        "/invoicing/v2/invoices/{id}",
		ProducesMediaTypes: []string{"application/json", "application/hal+json", "application/json;charset=utf-8", "application/hal+json;charset=utf-8"},
		ConsumesMediaTypes: []string{"application/json;charset=utf-8"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateInvoiceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateInvoiceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateInvoiceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
