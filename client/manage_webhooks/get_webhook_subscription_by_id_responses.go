// Code generated by go-swagger; DO NOT EDIT.

package manage_webhooks

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// GetWebhookSubscriptionByIDReader is a Reader for the GetWebhookSubscriptionByID structure.
type GetWebhookSubscriptionByIDReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetWebhookSubscriptionByIDReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetWebhookSubscriptionByIDOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 401:
		result := NewGetWebhookSubscriptionByIDUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewGetWebhookSubscriptionByIDNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewGetWebhookSubscriptionByIDInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[GET /notification-subscriptions/v1/webhooks/{webhookId}] getWebhookSubscriptionById", response, response.Code())
	}
}

// NewGetWebhookSubscriptionByIDOK creates a GetWebhookSubscriptionByIDOK with default headers values
func NewGetWebhookSubscriptionByIDOK() *GetWebhookSubscriptionByIDOK {
	return &GetWebhookSubscriptionByIDOK{}
}

/*
GetWebhookSubscriptionByIDOK describes a response with status code 200, with default header values.

Ok
*/
type GetWebhookSubscriptionByIDOK struct {
	Payload *GetWebhookSubscriptionByIDOKBody
}

// IsSuccess returns true when this get webhook subscription by Id o k response has a 2xx status code
func (o *GetWebhookSubscriptionByIDOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get webhook subscription by Id o k response has a 3xx status code
func (o *GetWebhookSubscriptionByIDOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get webhook subscription by Id o k response has a 4xx status code
func (o *GetWebhookSubscriptionByIDOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get webhook subscription by Id o k response has a 5xx status code
func (o *GetWebhookSubscriptionByIDOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get webhook subscription by Id o k response a status code equal to that given
func (o *GetWebhookSubscriptionByIDOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get webhook subscription by Id o k response
func (o *GetWebhookSubscriptionByIDOK) Code() int {
	return 200
}

func (o *GetWebhookSubscriptionByIDOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdOK %s", 200, payload)
}

func (o *GetWebhookSubscriptionByIDOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdOK %s", 200, payload)
}

func (o *GetWebhookSubscriptionByIDOK) GetPayload() *GetWebhookSubscriptionByIDOKBody {
	return o.Payload
}

func (o *GetWebhookSubscriptionByIDOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetWebhookSubscriptionByIDOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetWebhookSubscriptionByIDUnauthorized creates a GetWebhookSubscriptionByIDUnauthorized with default headers values
func NewGetWebhookSubscriptionByIDUnauthorized() *GetWebhookSubscriptionByIDUnauthorized {
	return &GetWebhookSubscriptionByIDUnauthorized{}
}

/*
GetWebhookSubscriptionByIDUnauthorized describes a response with status code 401, with default header values.

Unauthorized
*/
type GetWebhookSubscriptionByIDUnauthorized struct {
}

// IsSuccess returns true when this get webhook subscription by Id unauthorized response has a 2xx status code
func (o *GetWebhookSubscriptionByIDUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get webhook subscription by Id unauthorized response has a 3xx status code
func (o *GetWebhookSubscriptionByIDUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get webhook subscription by Id unauthorized response has a 4xx status code
func (o *GetWebhookSubscriptionByIDUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this get webhook subscription by Id unauthorized response has a 5xx status code
func (o *GetWebhookSubscriptionByIDUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this get webhook subscription by Id unauthorized response a status code equal to that given
func (o *GetWebhookSubscriptionByIDUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the get webhook subscription by Id unauthorized response
func (o *GetWebhookSubscriptionByIDUnauthorized) Code() int {
	return 401
}

func (o *GetWebhookSubscriptionByIDUnauthorized) Error() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdUnauthorized", 401)
}

func (o *GetWebhookSubscriptionByIDUnauthorized) String() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdUnauthorized", 401)
}

func (o *GetWebhookSubscriptionByIDUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewGetWebhookSubscriptionByIDNotFound creates a GetWebhookSubscriptionByIDNotFound with default headers values
func NewGetWebhookSubscriptionByIDNotFound() *GetWebhookSubscriptionByIDNotFound {
	return &GetWebhookSubscriptionByIDNotFound{}
}

/*
GetWebhookSubscriptionByIDNotFound describes a response with status code 404, with default header values.

Not found
*/
type GetWebhookSubscriptionByIDNotFound struct {
}

// IsSuccess returns true when this get webhook subscription by Id not found response has a 2xx status code
func (o *GetWebhookSubscriptionByIDNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get webhook subscription by Id not found response has a 3xx status code
func (o *GetWebhookSubscriptionByIDNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get webhook subscription by Id not found response has a 4xx status code
func (o *GetWebhookSubscriptionByIDNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this get webhook subscription by Id not found response has a 5xx status code
func (o *GetWebhookSubscriptionByIDNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this get webhook subscription by Id not found response a status code equal to that given
func (o *GetWebhookSubscriptionByIDNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the get webhook subscription by Id not found response
func (o *GetWebhookSubscriptionByIDNotFound) Code() int {
	return 404
}

func (o *GetWebhookSubscriptionByIDNotFound) Error() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdNotFound", 404)
}

func (o *GetWebhookSubscriptionByIDNotFound) String() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdNotFound", 404)
}

func (o *GetWebhookSubscriptionByIDNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewGetWebhookSubscriptionByIDInternalServerError creates a GetWebhookSubscriptionByIDInternalServerError with default headers values
func NewGetWebhookSubscriptionByIDInternalServerError() *GetWebhookSubscriptionByIDInternalServerError {
	return &GetWebhookSubscriptionByIDInternalServerError{}
}

/*
GetWebhookSubscriptionByIDInternalServerError describes a response with status code 500, with default header values.

Server error
*/
type GetWebhookSubscriptionByIDInternalServerError struct {
}

// IsSuccess returns true when this get webhook subscription by Id internal server error response has a 2xx status code
func (o *GetWebhookSubscriptionByIDInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get webhook subscription by Id internal server error response has a 3xx status code
func (o *GetWebhookSubscriptionByIDInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get webhook subscription by Id internal server error response has a 4xx status code
func (o *GetWebhookSubscriptionByIDInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this get webhook subscription by Id internal server error response has a 5xx status code
func (o *GetWebhookSubscriptionByIDInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this get webhook subscription by Id internal server error response a status code equal to that given
func (o *GetWebhookSubscriptionByIDInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the get webhook subscription by Id internal server error response
func (o *GetWebhookSubscriptionByIDInternalServerError) Code() int {
	return 500
}

func (o *GetWebhookSubscriptionByIDInternalServerError) Error() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdInternalServerError", 500)
}

func (o *GetWebhookSubscriptionByIDInternalServerError) String() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks/{webhookId}][%d] getWebhookSubscriptionByIdInternalServerError", 500)
}

func (o *GetWebhookSubscriptionByIDInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*
GetWebhookSubscriptionByIDOKBody get webhook subscription by ID o k body
// Example: {"additionalAttributes":[],"createdOn":"2021-02-25T23:25:11.000Z","description":null,"eventTypes":["payments.payments.accept","payments.payments.reject","payments.refunds.accept"],"healthCheckUrl":"https://example.com:443/cybs/healthcheck","name":"Billing Update Webhook","notificationScope":"SELF","organizationId":"\u003cINSERT ORGANIZATION ID HERE\u003e","productId":"payments","retryPolicy":null,"securityPolicy":{"config":{"keyId":"IdFromSecureUSAPI2LookupClientIdAndClientSecret","oAuthTokenExpiry":300,"oAuthTokenType":"Bearer","oAuthUrl":"https://acquirers.authorization-server.com/token"},"securityType":"oAuth"},"status":"INACTIVE","updatedOn":null,"webhookId":"b555a545-58a9-47c7-aef9-10a8e17f201a","webhookUrl":"https://example.com:443/cybs"}
swagger:model GetWebhookSubscriptionByIDOKBody
*/
type GetWebhookSubscriptionByIDOKBody struct {

	// Additional, free form configuration data.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// Date on which webhook was created/registered.
	CreatedOn string `json:"createdOn,omitempty"`

	// Client friendly webhook description.
	Description string `json:"description,omitempty"`

	// The client's health check endpoint (URL). This should be as close as possible to the actual webhookUrl.
	HealthCheckURL string `json:"healthCheckUrl,omitempty"`

	// Client friendly webhook name.
	Name string `json:"name,omitempty"`

	// notification scope
	NotificationScope *GetWebhookSubscriptionByIDOKBodyNotificationScope `json:"notificationScope,omitempty"`

	// Organization ID.
	OrganizationID string `json:"organizationId,omitempty"`

	// products
	Products []*GetWebhookSubscriptionByIDOKBodyProductsItems0 `json:"products"`

	// retry policy
	RetryPolicy *GetWebhookSubscriptionByIDOKBodyRetryPolicy `json:"retryPolicy,omitempty"`

	// security policy
	SecurityPolicy *GetWebhookSubscriptionByIDOKBodySecurityPolicy `json:"securityPolicy,omitempty"`

	// Webhook status.
	Status *string `json:"status,omitempty"`

	// Date on which webhook was most recently updated.
	UpdatedOn string `json:"updatedOn,omitempty"`

	// Webhook Id. This is generated by the server.
	WebhookID string `json:"webhookId,omitempty"`

	// The client's endpoint (URL) to receive webhooks.
	WebhookURL string `json:"webhookUrl,omitempty"`
}

// Validate validates this get webhook subscription by ID o k body
func (o *GetWebhookSubscriptionByIDOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNotificationScope(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRetryPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) validateNotificationScope(formats strfmt.Registry) error {
	if swag.IsZero(o.NotificationScope) { // not required
		return nil
	}

	if o.NotificationScope != nil {
		if err := o.NotificationScope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) validateProducts(formats strfmt.Registry) error {
	if swag.IsZero(o.Products) { // not required
		return nil
	}

	for i := 0; i < len(o.Products); i++ {
		if swag.IsZero(o.Products[i]) { // not required
			continue
		}

		if o.Products[i] != nil {
			if err := o.Products[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "products" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) validateRetryPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.RetryPolicy) { // not required
		return nil
	}

	if o.RetryPolicy != nil {
		if err := o.RetryPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) validateSecurityPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityPolicy) { // not required
		return nil
	}

	if o.SecurityPolicy != nil {
		if err := o.SecurityPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get webhook subscription by ID o k body based on the context it is used
func (o *GetWebhookSubscriptionByIDOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateNotificationScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProducts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRetryPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSecurityPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) contextValidateNotificationScope(ctx context.Context, formats strfmt.Registry) error {

	if o.NotificationScope != nil {

		if swag.IsZero(o.NotificationScope) { // not required
			return nil
		}

		if err := o.NotificationScope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) contextValidateProducts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Products); i++ {

		if o.Products[i] != nil {

			if swag.IsZero(o.Products[i]) { // not required
				return nil
			}

			if err := o.Products[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "products" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) contextValidateRetryPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.RetryPolicy != nil {

		if swag.IsZero(o.RetryPolicy) { // not required
			return nil
		}

		if err := o.RetryPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionByIDOKBody) contextValidateSecurityPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.SecurityPolicy != nil {

		if swag.IsZero(o.SecurityPolicy) { // not required
			return nil
		}

		if err := o.SecurityPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBody) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionByIDOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionByIDOKBodyNotificationScope get webhook subscription by ID o k body notification scope
swagger:model GetWebhookSubscriptionByIDOKBodyNotificationScope
*/
type GetWebhookSubscriptionByIDOKBodyNotificationScope struct {

	// The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. 3. CUSTOM The Webhook is used to deliver webhooks for the OrgIds (or MiDs) explicitly listed in scopeData field
	Scope *string `json:"scope,omitempty"`

	// Applicable only if scope=CUSTOM. This should contains a Set of MIDs or OrgIDs for which this subscription is applicable.
	ScopeData []string `json:"scopeData"`
}

// Validate validates this get webhook subscription by ID o k body notification scope
func (o *GetWebhookSubscriptionByIDOKBodyNotificationScope) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscription by ID o k body notification scope based on context it is used
func (o *GetWebhookSubscriptionByIDOKBodyNotificationScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodyNotificationScope) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodyNotificationScope) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionByIDOKBodyNotificationScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionByIDOKBodyProductsItems0 get webhook subscription by ID o k body products items0
// Example: {"eventTypes":["payments.credits.accept","payments.credits.partial.approval","payments.payments.accept","payments.payments.reject"],"productId":"payments"}
swagger:model GetWebhookSubscriptionByIDOKBodyProductsItems0
*/
type GetWebhookSubscriptionByIDOKBodyProductsItems0 struct {

	// event types
	EventTypes []string `json:"eventTypes"`

	// Product ID.
	ProductID string `json:"productId,omitempty"`
}

// Validate validates this get webhook subscription by ID o k body products items0
func (o *GetWebhookSubscriptionByIDOKBodyProductsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscription by ID o k body products items0 based on context it is used
func (o *GetWebhookSubscriptionByIDOKBodyProductsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodyProductsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodyProductsItems0) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionByIDOKBodyProductsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionByIDOKBodyRetryPolicy Retry policy for the individual webhooks that are a part of your subscription. If a message fails to deliver, it will execute through this retry policy.
//
// Automatic suspend and resume:
//
// If you experience downtime and have `deactivateFlag = true` any new messages will be held in a "SUSPENDED" status.
// When your healthCheckUrl returns healthy again, the subscription will automatically be re-enabled and your messages will be sent.
// We will ping your healthCheckUrl routinely using a POST call with an empty payload to check availability.
// If your endpoint returns an unhealthy status of != 200, we will check the healthCheckUrl at a more frequent rate until it is healthy again.
//
// If you experience downtime and have `deactivateFlag = false` and your message exhausts all retry attempts the message will go to a "FAILED" status.
// Support will be notified and will reach out to suggest you execute the "REPLAY" endpoint at a later date when your server is healthy.
//
//
// Reference the below values for formulas and calculations related to the frequency of retries depending on algorithm and configuration.
//
swagger:model GetWebhookSubscriptionByIDOKBodyRetryPolicy
*/
type GetWebhookSubscriptionByIDOKBodyRetryPolicy struct {

	// Additional data, if any.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// This is used to calculate the Retry Sequence.
	//
	// Sample calculations using firstRetry=10, interval=30, maxNumberOfRetries=3
	// Arithmetic = a+r(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10+30x1 = 40 minutes
	// Retry 3 - 10+30x2 = 70 minutes
	//
	// Geometric = ar^(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10x30^1 = 300 minutes
	// Retry 3 - 10x30^2 = 9,000 minutes
	//
	Algorithm string `json:"algorithm,omitempty"`

	// Deactivate the subscription if your retries fail to deliver.
	//
	// If this is set to `true`, the automatic suspend and resume feature will occur.
	// This would prevent new webhooks from attempting to deliver and to queue up until your healthCheckUrl returns 200 again, then all messages will be sent.
	//
	// If this is set to `false`, new individual messages will continue to retry and exhaust all failures, but the subscription will stay active.
	//
	DeactivateFlag string `json:"deactivateFlag,omitempty"`

	// When to initiate first retry, after the initial call failed. (in mins).
	FirstRetry int64 `json:"firstRetry,omitempty"`

	// The interval between retries (in mins).
	Interval int64 `json:"interval,omitempty"`

	// The number of retries per sequence.
	NumberOfRetries int64 `json:"numberOfRetries,omitempty"`

	// The number of times to repeat the complete retry sequence.
	// 0 => don't repeat the retry sequence
	// 1 => repeat the retry sequence once (R1, R2, R3)+ (R1, R2, R3)
	// 2 => repeat the retry sequence twice (R1, R2, R3) + (R1, R2, R3) + (R1, R2, R3)
	//
	RepeatSequenceCount int64 `json:"repeatSequenceCount,omitempty"`

	// The time to wait to before repeating the complete retry sequence.
	// Amount of time to wait between each sequence.
	// Sample calculation using repeatSequenceWaitTime=10
	// (R1, R2, R3) + (10) + (R1, R2, R3) + (10) + (R1, R2, R3)
	//
	RepeatSequenceWaitTime int64 `json:"repeatSequenceWaitTime,omitempty"`
}

// Validate validates this get webhook subscription by ID o k body retry policy
func (o *GetWebhookSubscriptionByIDOKBodyRetryPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscription by ID o k body retry policy based on context it is used
func (o *GetWebhookSubscriptionByIDOKBodyRetryPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodyRetryPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodyRetryPolicy) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionByIDOKBodyRetryPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionByIDOKBodySecurityPolicy The security option to authenticate with your API or client server.
swagger:model GetWebhookSubscriptionByIDOKBodySecurityPolicy
*/
type GetWebhookSubscriptionByIDOKBodySecurityPolicy struct {

	// config
	Config *GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig `json:"config,omitempty"`

	// Security Policy of the client server.
	SecurityType string `json:"securityType,omitempty"`
}

// Validate validates this get webhook subscription by ID o k body security policy
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicy) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.Config) { // not required
		return nil
	}

	if o.Config != nil {
		if err := o.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get webhook subscription by ID o k body security policy based on the context it is used
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicy) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.Config != nil {

		if swag.IsZero(o.Config) { // not required
			return nil
		}

		if err := o.Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getWebhookSubscriptionByIdOK" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicy) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionByIDOKBodySecurityPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig Optional configuration object for if your API or server requires oAuth for an incoming webhook.
swagger:model GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig
*/
type GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig struct {

	// Token expiration for the oAuth server.
	OAuthTokenExpiry string `json:"oAuthTokenExpiry,omitempty"`

	// Token type for the oAuth config.
	OAuthTokenType string `json:"oAuthTokenType,omitempty"`

	// Client direct endpoint to the oAuth server.
	OAuthURL string `json:"oAuthURL,omitempty"`
}

// Validate validates this get webhook subscription by ID o k body security policy config
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscription by ID o k body security policy config based on context it is used
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionByIDOKBodySecurityPolicyConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
