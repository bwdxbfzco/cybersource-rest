// Code generated by go-swagger; DO NOT EDIT.

package manage_webhooks

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// UpdateWebhookSubscriptionReader is a Reader for the UpdateWebhookSubscription structure.
type UpdateWebhookSubscriptionReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *UpdateWebhookSubscriptionReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewUpdateWebhookSubscriptionOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 401:
		result := NewUpdateWebhookSubscriptionUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewUpdateWebhookSubscriptionNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewUpdateWebhookSubscriptionInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}] updateWebhookSubscription", response, response.Code())
	}
}

// NewUpdateWebhookSubscriptionOK creates a UpdateWebhookSubscriptionOK with default headers values
func NewUpdateWebhookSubscriptionOK() *UpdateWebhookSubscriptionOK {
	return &UpdateWebhookSubscriptionOK{}
}

/*
UpdateWebhookSubscriptionOK describes a response with status code 200, with default header values.

Updated
*/
type UpdateWebhookSubscriptionOK struct {
}

// IsSuccess returns true when this update webhook subscription o k response has a 2xx status code
func (o *UpdateWebhookSubscriptionOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this update webhook subscription o k response has a 3xx status code
func (o *UpdateWebhookSubscriptionOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this update webhook subscription o k response has a 4xx status code
func (o *UpdateWebhookSubscriptionOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this update webhook subscription o k response has a 5xx status code
func (o *UpdateWebhookSubscriptionOK) IsServerError() bool {
	return false
}

// IsCode returns true when this update webhook subscription o k response a status code equal to that given
func (o *UpdateWebhookSubscriptionOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the update webhook subscription o k response
func (o *UpdateWebhookSubscriptionOK) Code() int {
	return 200
}

func (o *UpdateWebhookSubscriptionOK) Error() string {
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionOK", 200)
}

func (o *UpdateWebhookSubscriptionOK) String() string {
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionOK", 200)
}

func (o *UpdateWebhookSubscriptionOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewUpdateWebhookSubscriptionUnauthorized creates a UpdateWebhookSubscriptionUnauthorized with default headers values
func NewUpdateWebhookSubscriptionUnauthorized() *UpdateWebhookSubscriptionUnauthorized {
	return &UpdateWebhookSubscriptionUnauthorized{}
}

/*
UpdateWebhookSubscriptionUnauthorized describes a response with status code 401, with default header values.

Unauthorized
*/
type UpdateWebhookSubscriptionUnauthorized struct {
}

// IsSuccess returns true when this update webhook subscription unauthorized response has a 2xx status code
func (o *UpdateWebhookSubscriptionUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this update webhook subscription unauthorized response has a 3xx status code
func (o *UpdateWebhookSubscriptionUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this update webhook subscription unauthorized response has a 4xx status code
func (o *UpdateWebhookSubscriptionUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this update webhook subscription unauthorized response has a 5xx status code
func (o *UpdateWebhookSubscriptionUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this update webhook subscription unauthorized response a status code equal to that given
func (o *UpdateWebhookSubscriptionUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the update webhook subscription unauthorized response
func (o *UpdateWebhookSubscriptionUnauthorized) Code() int {
	return 401
}

func (o *UpdateWebhookSubscriptionUnauthorized) Error() string {
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionUnauthorized", 401)
}

func (o *UpdateWebhookSubscriptionUnauthorized) String() string {
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionUnauthorized", 401)
}

func (o *UpdateWebhookSubscriptionUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewUpdateWebhookSubscriptionNotFound creates a UpdateWebhookSubscriptionNotFound with default headers values
func NewUpdateWebhookSubscriptionNotFound() *UpdateWebhookSubscriptionNotFound {
	return &UpdateWebhookSubscriptionNotFound{}
}

/*
UpdateWebhookSubscriptionNotFound describes a response with status code 404, with default header values.

Not found
*/
type UpdateWebhookSubscriptionNotFound struct {
	Payload *UpdateWebhookSubscriptionNotFoundBody
}

// IsSuccess returns true when this update webhook subscription not found response has a 2xx status code
func (o *UpdateWebhookSubscriptionNotFound) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this update webhook subscription not found response has a 3xx status code
func (o *UpdateWebhookSubscriptionNotFound) IsRedirect() bool {
	return false
}

// IsClientError returns true when this update webhook subscription not found response has a 4xx status code
func (o *UpdateWebhookSubscriptionNotFound) IsClientError() bool {
	return true
}

// IsServerError returns true when this update webhook subscription not found response has a 5xx status code
func (o *UpdateWebhookSubscriptionNotFound) IsServerError() bool {
	return false
}

// IsCode returns true when this update webhook subscription not found response a status code equal to that given
func (o *UpdateWebhookSubscriptionNotFound) IsCode(code int) bool {
	return code == 404
}

// Code gets the status code for the update webhook subscription not found response
func (o *UpdateWebhookSubscriptionNotFound) Code() int {
	return 404
}

func (o *UpdateWebhookSubscriptionNotFound) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionNotFound %s", 404, payload)
}

func (o *UpdateWebhookSubscriptionNotFound) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionNotFound %s", 404, payload)
}

func (o *UpdateWebhookSubscriptionNotFound) GetPayload() *UpdateWebhookSubscriptionNotFoundBody {
	return o.Payload
}

func (o *UpdateWebhookSubscriptionNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(UpdateWebhookSubscriptionNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewUpdateWebhookSubscriptionInternalServerError creates a UpdateWebhookSubscriptionInternalServerError with default headers values
func NewUpdateWebhookSubscriptionInternalServerError() *UpdateWebhookSubscriptionInternalServerError {
	return &UpdateWebhookSubscriptionInternalServerError{}
}

/*
UpdateWebhookSubscriptionInternalServerError describes a response with status code 500, with default header values.

Server error
*/
type UpdateWebhookSubscriptionInternalServerError struct {
}

// IsSuccess returns true when this update webhook subscription internal server error response has a 2xx status code
func (o *UpdateWebhookSubscriptionInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this update webhook subscription internal server error response has a 3xx status code
func (o *UpdateWebhookSubscriptionInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this update webhook subscription internal server error response has a 4xx status code
func (o *UpdateWebhookSubscriptionInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this update webhook subscription internal server error response has a 5xx status code
func (o *UpdateWebhookSubscriptionInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this update webhook subscription internal server error response a status code equal to that given
func (o *UpdateWebhookSubscriptionInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the update webhook subscription internal server error response
func (o *UpdateWebhookSubscriptionInternalServerError) Code() int {
	return 500
}

func (o *UpdateWebhookSubscriptionInternalServerError) Error() string {
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionInternalServerError", 500)
}

func (o *UpdateWebhookSubscriptionInternalServerError) String() string {
	return fmt.Sprintf("[PATCH /notification-subscriptions/v1/webhooks/{webhookId}][%d] updateWebhookSubscriptionInternalServerError", 500)
}

func (o *UpdateWebhookSubscriptionInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*
UpdateWebhookSubscriptionBody update webhook subscription body
// Example: {"status":"ACTIVE"}
swagger:model UpdateWebhookSubscriptionBody
*/
type UpdateWebhookSubscriptionBody struct {

	// Additional, free form configuration data.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// Client friendly webhook description.\
	Description string `json:"description,omitempty"`

	// Array of the different events for a given product id.
	EventTypes []string `json:"eventTypes"`

	// The client's health check endpoint (URL). This should be as close as possible to the actual webhookUrl.
	HealthCheckURL string `json:"healthCheckUrl,omitempty"`

	// Client friendly webhook name.
	Name string `json:"name,omitempty"`

	// notification scope
	NotificationScope *UpdateWebhookSubscriptionParamsBodyNotificationScope `json:"notificationScope,omitempty"`

	// Organization Id.
	OrganizationID string `json:"organizationId,omitempty"`

	// The product you are receiving a webhook for.
	ProductID string `json:"productId,omitempty"`

	// retry policy
	RetryPolicy *UpdateWebhookSubscriptionParamsBodyRetryPolicy `json:"retryPolicy,omitempty"`

	// security policy
	SecurityPolicy *UpdateWebhookSubscriptionParamsBodySecurityPolicy `json:"securityPolicy,omitempty"`

	// Webhook status.
	Status *string `json:"status,omitempty"`

	// The client's endpoint (URL) to receive webhooks.
	WebhookURL string `json:"webhookUrl,omitempty"`
}

// Validate validates this update webhook subscription body
func (o *UpdateWebhookSubscriptionBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNotificationScope(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRetryPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateWebhookSubscriptionBody) validateNotificationScope(formats strfmt.Registry) error {
	if swag.IsZero(o.NotificationScope) { // not required
		return nil
	}

	if o.NotificationScope != nil {
		if err := o.NotificationScope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateWebhookSubscriptionBody) validateRetryPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.RetryPolicy) { // not required
		return nil
	}

	if o.RetryPolicy != nil {
		if err := o.RetryPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateWebhookSubscriptionBody) validateSecurityPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityPolicy) { // not required
		return nil
	}

	if o.SecurityPolicy != nil {
		if err := o.SecurityPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this update webhook subscription body based on the context it is used
func (o *UpdateWebhookSubscriptionBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateNotificationScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRetryPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSecurityPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateWebhookSubscriptionBody) contextValidateNotificationScope(ctx context.Context, formats strfmt.Registry) error {

	if o.NotificationScope != nil {

		if swag.IsZero(o.NotificationScope) { // not required
			return nil
		}

		if err := o.NotificationScope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateWebhookSubscriptionBody) contextValidateRetryPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.RetryPolicy != nil {

		if swag.IsZero(o.RetryPolicy) { // not required
			return nil
		}

		if err := o.RetryPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *UpdateWebhookSubscriptionBody) contextValidateSecurityPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.SecurityPolicy != nil {

		if swag.IsZero(o.SecurityPolicy) { // not required
			return nil
		}

		if err := o.SecurityPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionBody) UnmarshalBinary(b []byte) error {
	var res UpdateWebhookSubscriptionBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UpdateWebhookSubscriptionNotFoundBody update webhook subscription not found body
swagger:model UpdateWebhookSubscriptionNotFoundBody
*/
type UpdateWebhookSubscriptionNotFoundBody struct {

	// details
	Details []*UpdateWebhookSubscriptionNotFoundBodyDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`

	// reason
	Reason string `json:"reason,omitempty"`
}

// Validate validates this update webhook subscription not found body
func (o *UpdateWebhookSubscriptionNotFoundBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateWebhookSubscriptionNotFoundBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateWebhookSubscriptionNotFound" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateWebhookSubscriptionNotFound" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this update webhook subscription not found body based on the context it is used
func (o *UpdateWebhookSubscriptionNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateWebhookSubscriptionNotFoundBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("updateWebhookSubscriptionNotFound" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("updateWebhookSubscriptionNotFound" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionNotFoundBody) UnmarshalBinary(b []byte) error {
	var res UpdateWebhookSubscriptionNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UpdateWebhookSubscriptionNotFoundBodyDetailsItems0 update webhook subscription not found body details items0
swagger:model UpdateWebhookSubscriptionNotFoundBodyDetailsItems0
*/
type UpdateWebhookSubscriptionNotFoundBodyDetailsItems0 struct {

	// field
	Field string `json:"field,omitempty"`

	// reason
	Reason string `json:"reason,omitempty"`
}

// Validate validates this update webhook subscription not found body details items0
func (o *UpdateWebhookSubscriptionNotFoundBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update webhook subscription not found body details items0 based on context it is used
func (o *UpdateWebhookSubscriptionNotFoundBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionNotFoundBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionNotFoundBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res UpdateWebhookSubscriptionNotFoundBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UpdateWebhookSubscriptionParamsBodyNotificationScope update webhook subscription params body notification scope
swagger:model UpdateWebhookSubscriptionParamsBodyNotificationScope
*/
type UpdateWebhookSubscriptionParamsBodyNotificationScope struct {

	// The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. 3. CUSTOM The Webhook is used to deliver webhooks for the OrgIds (or MiDs) explicitly listed in scopeData field
	Scope *string `json:"scope,omitempty"`

	// Applicable only if scope=CUSTOM. This should contains a Set of MIDs or OrgIDs for which this subscription is applicable.
	ScopeData []string `json:"scopeData"`
}

// Validate validates this update webhook subscription params body notification scope
func (o *UpdateWebhookSubscriptionParamsBodyNotificationScope) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update webhook subscription params body notification scope based on context it is used
func (o *UpdateWebhookSubscriptionParamsBodyNotificationScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodyNotificationScope) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodyNotificationScope) UnmarshalBinary(b []byte) error {
	var res UpdateWebhookSubscriptionParamsBodyNotificationScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UpdateWebhookSubscriptionParamsBodyRetryPolicy Retry policy for the individual webhooks that are a part of your subscription. If a message fails to deliver, it will execute through this retry policy.
//
// Automatic suspend and resume:
//
// If you experience downtime and have `deactivateFlag = true` any new messages will be held in a "SUSPENDED" status.
// When your healthCheckUrl returns healthy again, the subscription will automatically be re-enabled and your messages will be sent.
// We will ping your healthCheckUrl routinely using a POST call with an empty payload to check availability.
// If your endpoint returns an unhealthy status of != 200, we will check the healthCheckUrl at a more frequent rate until it is healthy again.
//
// If you experience downtime and have `deactivateFlag = false` and your message exhausts all retry attempts the message will go to a "FAILED" status.
// Support will be notified and will reach out to suggest you execute the "REPLAY" endpoint at a later date when your server is healthy.
//
//
// Reference the below values for formulas and calculations related to the frequency of retries depending on algorithm and configuration.
//
swagger:model UpdateWebhookSubscriptionParamsBodyRetryPolicy
*/
type UpdateWebhookSubscriptionParamsBodyRetryPolicy struct {

	// Additional data, if any.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// This is used to calculate the Retry Sequence.
	//
	// Sample calculations using firstRetry=10, interval=30, maxNumberOfRetries=3
	// Arithmetic = a+r(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10+30x1 = 40 minutes
	// Retry 3 - 10+30x2 = 70 minutes
	//
	// Geometric = ar^(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10x30^1 = 300 minutes
	// Retry 3 - 10x30^2 = 9,000 minutes
	//
	Algorithm string `json:"algorithm,omitempty"`

	// Deactivate the subscription if your retries fail to deliver.
	//
	// If this is set to `true`, the automatic suspend and resume feature will occur.
	// This would prevent new webhooks from attempting to deliver and to queue up until your healthCheckUrl returns 200 again, then all messages will be sent.
	//
	// If this is set to `false`, new individual messages will continue to retry and exhaust all failures, but the subscription will stay active.
	//
	DeactivateFlag string `json:"deactivateFlag,omitempty"`

	// When to initiate first retry, after the initial call failed. (in mins).
	FirstRetry int64 `json:"firstRetry,omitempty"`

	// The interval between retries (in mins).
	Interval int64 `json:"interval,omitempty"`

	// The number of retries per sequence.
	NumberOfRetries int64 `json:"numberOfRetries,omitempty"`

	// The number of times to repeat the complete retry sequence.
	// 0 => don't repeat the retry sequence
	// 1 => repeat the retry sequence once (R1, R2, R3)+ (R1, R2, R3)
	// 2 => repeat the retry sequence twice (R1, R2, R3) + (R1, R2, R3) + (R1, R2, R3)
	//
	RepeatSequenceCount int64 `json:"repeatSequenceCount,omitempty"`

	// The time to wait to before repeating the complete retry sequence.
	// Amount of time to wait between each sequence.
	// Sample calculation using repeatSequenceWaitTime=10
	// (R1, R2, R3) + (10) + (R1, R2, R3) + (10) + (R1, R2, R3)
	//
	RepeatSequenceWaitTime int64 `json:"repeatSequenceWaitTime,omitempty"`
}

// Validate validates this update webhook subscription params body retry policy
func (o *UpdateWebhookSubscriptionParamsBodyRetryPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update webhook subscription params body retry policy based on context it is used
func (o *UpdateWebhookSubscriptionParamsBodyRetryPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodyRetryPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodyRetryPolicy) UnmarshalBinary(b []byte) error {
	var res UpdateWebhookSubscriptionParamsBodyRetryPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UpdateWebhookSubscriptionParamsBodySecurityPolicy The security option to authenticate with your API or client server.
swagger:model UpdateWebhookSubscriptionParamsBodySecurityPolicy
*/
type UpdateWebhookSubscriptionParamsBodySecurityPolicy struct {

	// config
	Config *UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig `json:"config,omitempty"`

	// Security Policy of the client server.
	SecurityType string `json:"securityType,omitempty"`
}

// Validate validates this update webhook subscription params body security policy
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicy) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.Config) { // not required
		return nil
	}

	if o.Config != nil {
		if err := o.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this update webhook subscription params body security policy based on the context it is used
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicy) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.Config != nil {

		if swag.IsZero(o.Config) { // not required
			return nil
		}

		if err := o.Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateWebhookRequest" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateWebhookRequest" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicy) UnmarshalBinary(b []byte) error {
	var res UpdateWebhookSubscriptionParamsBodySecurityPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig Optional configuration object for if your API or server requires oAuth for an incoming webhook.
swagger:model UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig
*/
type UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig struct {

	// Token expiration for the oAuth server.
	OAuthTokenExpiry string `json:"oAuthTokenExpiry,omitempty"`

	// Token type for the oAuth config.
	OAuthTokenType string `json:"oAuthTokenType,omitempty"`

	// Client direct endpoint to the oAuth server.
	OAuthURL string `json:"oAuthURL,omitempty"`
}

// Validate validates this update webhook subscription params body security policy config
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this update webhook subscription params body security policy config based on context it is used
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig) UnmarshalBinary(b []byte) error {
	var res UpdateWebhookSubscriptionParamsBodySecurityPolicyConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
