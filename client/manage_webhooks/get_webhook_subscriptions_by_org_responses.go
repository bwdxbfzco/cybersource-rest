// Code generated by go-swagger; DO NOT EDIT.

package manage_webhooks

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// GetWebhookSubscriptionsByOrgReader is a Reader for the GetWebhookSubscriptionsByOrg structure.
type GetWebhookSubscriptionsByOrgReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetWebhookSubscriptionsByOrgReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetWebhookSubscriptionsByOrgOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 401:
		result := NewGetWebhookSubscriptionsByOrgUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewGetWebhookSubscriptionsByOrgInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[GET /notification-subscriptions/v1/webhooks] getWebhookSubscriptionsByOrg", response, response.Code())
	}
}

// NewGetWebhookSubscriptionsByOrgOK creates a GetWebhookSubscriptionsByOrgOK with default headers values
func NewGetWebhookSubscriptionsByOrgOK() *GetWebhookSubscriptionsByOrgOK {
	return &GetWebhookSubscriptionsByOrgOK{}
}

/*
GetWebhookSubscriptionsByOrgOK describes a response with status code 200, with default header values.

OK
*/
type GetWebhookSubscriptionsByOrgOK struct {
	Payload []*GetWebhookSubscriptionsByOrgOKBodyItems0
}

// IsSuccess returns true when this get webhook subscriptions by org o k response has a 2xx status code
func (o *GetWebhookSubscriptionsByOrgOK) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this get webhook subscriptions by org o k response has a 3xx status code
func (o *GetWebhookSubscriptionsByOrgOK) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get webhook subscriptions by org o k response has a 4xx status code
func (o *GetWebhookSubscriptionsByOrgOK) IsClientError() bool {
	return false
}

// IsServerError returns true when this get webhook subscriptions by org o k response has a 5xx status code
func (o *GetWebhookSubscriptionsByOrgOK) IsServerError() bool {
	return false
}

// IsCode returns true when this get webhook subscriptions by org o k response a status code equal to that given
func (o *GetWebhookSubscriptionsByOrgOK) IsCode(code int) bool {
	return code == 200
}

// Code gets the status code for the get webhook subscriptions by org o k response
func (o *GetWebhookSubscriptionsByOrgOK) Code() int {
	return 200
}

func (o *GetWebhookSubscriptionsByOrgOK) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks][%d] getWebhookSubscriptionsByOrgOK %s", 200, payload)
}

func (o *GetWebhookSubscriptionsByOrgOK) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks][%d] getWebhookSubscriptionsByOrgOK %s", 200, payload)
}

func (o *GetWebhookSubscriptionsByOrgOK) GetPayload() []*GetWebhookSubscriptionsByOrgOKBodyItems0 {
	return o.Payload
}

func (o *GetWebhookSubscriptionsByOrgOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// response payload
	if err := consumer.Consume(response.Body(), &o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetWebhookSubscriptionsByOrgUnauthorized creates a GetWebhookSubscriptionsByOrgUnauthorized with default headers values
func NewGetWebhookSubscriptionsByOrgUnauthorized() *GetWebhookSubscriptionsByOrgUnauthorized {
	return &GetWebhookSubscriptionsByOrgUnauthorized{}
}

/*
GetWebhookSubscriptionsByOrgUnauthorized describes a response with status code 401, with default header values.

Unauthorized
*/
type GetWebhookSubscriptionsByOrgUnauthorized struct {
}

// IsSuccess returns true when this get webhook subscriptions by org unauthorized response has a 2xx status code
func (o *GetWebhookSubscriptionsByOrgUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get webhook subscriptions by org unauthorized response has a 3xx status code
func (o *GetWebhookSubscriptionsByOrgUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get webhook subscriptions by org unauthorized response has a 4xx status code
func (o *GetWebhookSubscriptionsByOrgUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this get webhook subscriptions by org unauthorized response has a 5xx status code
func (o *GetWebhookSubscriptionsByOrgUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this get webhook subscriptions by org unauthorized response a status code equal to that given
func (o *GetWebhookSubscriptionsByOrgUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the get webhook subscriptions by org unauthorized response
func (o *GetWebhookSubscriptionsByOrgUnauthorized) Code() int {
	return 401
}

func (o *GetWebhookSubscriptionsByOrgUnauthorized) Error() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks][%d] getWebhookSubscriptionsByOrgUnauthorized", 401)
}

func (o *GetWebhookSubscriptionsByOrgUnauthorized) String() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks][%d] getWebhookSubscriptionsByOrgUnauthorized", 401)
}

func (o *GetWebhookSubscriptionsByOrgUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewGetWebhookSubscriptionsByOrgInternalServerError creates a GetWebhookSubscriptionsByOrgInternalServerError with default headers values
func NewGetWebhookSubscriptionsByOrgInternalServerError() *GetWebhookSubscriptionsByOrgInternalServerError {
	return &GetWebhookSubscriptionsByOrgInternalServerError{}
}

/*
GetWebhookSubscriptionsByOrgInternalServerError describes a response with status code 500, with default header values.

Server error
*/
type GetWebhookSubscriptionsByOrgInternalServerError struct {
}

// IsSuccess returns true when this get webhook subscriptions by org internal server error response has a 2xx status code
func (o *GetWebhookSubscriptionsByOrgInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this get webhook subscriptions by org internal server error response has a 3xx status code
func (o *GetWebhookSubscriptionsByOrgInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this get webhook subscriptions by org internal server error response has a 4xx status code
func (o *GetWebhookSubscriptionsByOrgInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this get webhook subscriptions by org internal server error response has a 5xx status code
func (o *GetWebhookSubscriptionsByOrgInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this get webhook subscriptions by org internal server error response a status code equal to that given
func (o *GetWebhookSubscriptionsByOrgInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the get webhook subscriptions by org internal server error response
func (o *GetWebhookSubscriptionsByOrgInternalServerError) Code() int {
	return 500
}

func (o *GetWebhookSubscriptionsByOrgInternalServerError) Error() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks][%d] getWebhookSubscriptionsByOrgInternalServerError", 500)
}

func (o *GetWebhookSubscriptionsByOrgInternalServerError) String() string {
	return fmt.Sprintf("[GET /notification-subscriptions/v1/webhooks][%d] getWebhookSubscriptionsByOrgInternalServerError", 500)
}

func (o *GetWebhookSubscriptionsByOrgInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*
GetWebhookSubscriptionsByOrgOKBodyItems0 get webhook subscriptions by org o k body items0
// Example: {"additionalAttributes":[],"createdOn":"2021-02-25T23:25:11.000Z","description":null,"eventTypes":["payments.payments.accept","payments.payments.reject","payments.refunds.accept"],"healthCheckUrl":"https://example.com:443/cybs/healthcheck","name":"Billing Update Webhook","notificationScope":"SELF","organizationId":"\u003cINSERT ORGANIZATION ID HERE\u003e","productId":"payments","retryPolicy":null,"securityPolicy":{"config":{"keyId":"IdFromSecureUSAPI2LookupClientIdAndClientSecret","oAuthTokenExpiry":300,"oAuthTokenType":"Bearer","oAuthUrl":"https://acquirers.authorization-server.com/token"},"securityType":"oAuth"},"status":"INACTIVE","updatedOn":null,"webhookId":"b555a545-58a9-47c7-aef9-10a8e17f201a","webhookUrl":"https://example.com:443/cybs"}
swagger:model GetWebhookSubscriptionsByOrgOKBodyItems0
*/
type GetWebhookSubscriptionsByOrgOKBodyItems0 struct {

	// Additional, free form configuration data.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// Date on which webhook was created/registered.
	CreatedOn string `json:"createdOn,omitempty"`

	// Client friendly webhook description.
	Description string `json:"description,omitempty"`

	// The client's health check endpoint (URL). This should be as close as possible to the actual webhookUrl.
	HealthCheckURL string `json:"healthCheckUrl,omitempty"`

	// Client friendly webhook name.
	Name string `json:"name,omitempty"`

	// notification scope
	NotificationScope *GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope `json:"notificationScope,omitempty"`

	// Organization ID.
	OrganizationID string `json:"organizationId,omitempty"`

	// products
	Products []*GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0 `json:"products"`

	// retry policy
	RetryPolicy *GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy `json:"retryPolicy,omitempty"`

	// security policy
	SecurityPolicy *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy `json:"securityPolicy,omitempty"`

	// Webhook status.
	Status *string `json:"status,omitempty"`

	// Date on which webhook was most recently updated.
	UpdatedOn string `json:"updatedOn,omitempty"`

	// Webhook Id. This is generated by the server.
	WebhookID string `json:"webhookId,omitempty"`

	// The client's endpoint (URL) to receive webhooks.
	WebhookURL string `json:"webhookUrl,omitempty"`
}

// Validate validates this get webhook subscriptions by org o k body items0
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNotificationScope(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRetryPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) validateNotificationScope(formats strfmt.Registry) error {
	if swag.IsZero(o.NotificationScope) { // not required
		return nil
	}

	if o.NotificationScope != nil {
		if err := o.NotificationScope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) validateProducts(formats strfmt.Registry) error {
	if swag.IsZero(o.Products) { // not required
		return nil
	}

	for i := 0; i < len(o.Products); i++ {
		if swag.IsZero(o.Products[i]) { // not required
			continue
		}

		if o.Products[i] != nil {
			if err := o.Products[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("products" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) validateRetryPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.RetryPolicy) { // not required
		return nil
	}

	if o.RetryPolicy != nil {
		if err := o.RetryPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) validateSecurityPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityPolicy) { // not required
		return nil
	}

	if o.SecurityPolicy != nil {
		if err := o.SecurityPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("securityPolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get webhook subscriptions by org o k body items0 based on the context it is used
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateNotificationScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProducts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRetryPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSecurityPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) contextValidateNotificationScope(ctx context.Context, formats strfmt.Registry) error {

	if o.NotificationScope != nil {

		if swag.IsZero(o.NotificationScope) { // not required
			return nil
		}

		if err := o.NotificationScope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) contextValidateProducts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Products); i++ {

		if o.Products[i] != nil {

			if swag.IsZero(o.Products[i]) { // not required
				return nil
			}

			if err := o.Products[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("products" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("products" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) contextValidateRetryPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.RetryPolicy != nil {

		if swag.IsZero(o.RetryPolicy) { // not required
			return nil
		}

		if err := o.RetryPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) contextValidateSecurityPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.SecurityPolicy != nil {

		if swag.IsZero(o.SecurityPolicy) { // not required
			return nil
		}

		if err := o.SecurityPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("securityPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionsByOrgOKBodyItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope get webhook subscriptions by org o k body items0 notification scope
swagger:model GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope
*/
type GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope struct {

	// The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. 3. CUSTOM The Webhook is used to deliver webhooks for the OrgIds (or MiDs) explicitly listed in scopeData field
	Scope *string `json:"scope,omitempty"`

	// Applicable only if scope=CUSTOM. This should contains a Set of MIDs or OrgIDs for which this subscription is applicable.
	ScopeData []string `json:"scopeData"`
}

// Validate validates this get webhook subscriptions by org o k body items0 notification scope
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscriptions by org o k body items0 notification scope based on context it is used
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionsByOrgOKBodyItems0NotificationScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0 get webhook subscriptions by org o k body items0 products items0
// Example: {"eventTypes":["payments.credits.accept","payments.credits.partial.approval","payments.payments.accept","payments.payments.reject"],"productId":"payments"}
swagger:model GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0
*/
type GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0 struct {

	// event types
	EventTypes []string `json:"eventTypes"`

	// Product ID.
	ProductID string `json:"productId,omitempty"`
}

// Validate validates this get webhook subscriptions by org o k body items0 products items0
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscriptions by org o k body items0 products items0 based on context it is used
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionsByOrgOKBodyItems0ProductsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy Retry policy for the individual webhooks that are a part of your subscription. If a message fails to deliver, it will execute through this retry policy.
//
// Automatic suspend and resume:
//
// If you experience downtime and have `deactivateFlag = true` any new messages will be held in a "SUSPENDED" status.
// When your healthCheckUrl returns healthy again, the subscription will automatically be re-enabled and your messages will be sent.
// We will ping your healthCheckUrl routinely using a POST call with an empty payload to check availability.
// If your endpoint returns an unhealthy status of != 200, we will check the healthCheckUrl at a more frequent rate until it is healthy again.
//
// If you experience downtime and have `deactivateFlag = false` and your message exhausts all retry attempts the message will go to a "FAILED" status.
// Support will be notified and will reach out to suggest you execute the "REPLAY" endpoint at a later date when your server is healthy.
//
//
// Reference the below values for formulas and calculations related to the frequency of retries depending on algorithm and configuration.
//
swagger:model GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy
*/
type GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy struct {

	// Additional data, if any.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// This is used to calculate the Retry Sequence.
	//
	// Sample calculations using firstRetry=10, interval=30, maxNumberOfRetries=3
	// Arithmetic = a+r(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10+30x1 = 40 minutes
	// Retry 3 - 10+30x2 = 70 minutes
	//
	// Geometric = ar^(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10x30^1 = 300 minutes
	// Retry 3 - 10x30^2 = 9,000 minutes
	//
	Algorithm string `json:"algorithm,omitempty"`

	// Deactivate the subscription if your retries fail to deliver.
	//
	// If this is set to `true`, the automatic suspend and resume feature will occur.
	// This would prevent new webhooks from attempting to deliver and to queue up until your healthCheckUrl returns 200 again, then all messages will be sent.
	//
	// If this is set to `false`, new individual messages will continue to retry and exhaust all failures, but the subscription will stay active.
	//
	DeactivateFlag string `json:"deactivateFlag,omitempty"`

	// When to initiate first retry, after the initial call failed. (in mins).
	FirstRetry int64 `json:"firstRetry,omitempty"`

	// The interval between retries (in mins).
	Interval int64 `json:"interval,omitempty"`

	// The number of retries per sequence.
	NumberOfRetries int64 `json:"numberOfRetries,omitempty"`

	// The number of times to repeat the complete retry sequence.
	// 0 => don't repeat the retry sequence
	// 1 => repeat the retry sequence once (R1, R2, R3)+ (R1, R2, R3)
	// 2 => repeat the retry sequence twice (R1, R2, R3) + (R1, R2, R3) + (R1, R2, R3)
	//
	RepeatSequenceCount int64 `json:"repeatSequenceCount,omitempty"`

	// The time to wait to before repeating the complete retry sequence.
	// Amount of time to wait between each sequence.
	// Sample calculation using repeatSequenceWaitTime=10
	// (R1, R2, R3) + (10) + (R1, R2, R3) + (10) + (R1, R2, R3)
	//
	RepeatSequenceWaitTime int64 `json:"repeatSequenceWaitTime,omitempty"`
}

// Validate validates this get webhook subscriptions by org o k body items0 retry policy
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscriptions by org o k body items0 retry policy based on context it is used
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionsByOrgOKBodyItems0RetryPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy The security option to authenticate with your API or client server.
swagger:model GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy
*/
type GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy struct {

	// config
	Config *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig `json:"config,omitempty"`

	// Security Policy of the client server.
	SecurityType string `json:"securityType,omitempty"`
}

// Validate validates this get webhook subscriptions by org o k body items0 security policy
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.Config) { // not required
		return nil
	}

	if o.Config != nil {
		if err := o.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get webhook subscriptions by org o k body items0 security policy based on the context it is used
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.Config != nil {

		if swag.IsZero(o.Config) { // not required
			return nil
		}

		if err := o.Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig Optional configuration object for if your API or server requires oAuth for an incoming webhook.
swagger:model GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig
*/
type GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig struct {

	// Token expiration for the oAuth server.
	OAuthTokenExpiry string `json:"oAuthTokenExpiry,omitempty"`

	// Token type for the oAuth config.
	OAuthTokenType string `json:"oAuthTokenType,omitempty"`

	// Client direct endpoint to the oAuth server.
	OAuthURL string `json:"oAuthURL,omitempty"`
}

// Validate validates this get webhook subscriptions by org o k body items0 security policy config
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get webhook subscriptions by org o k body items0 security policy config based on context it is used
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig) UnmarshalBinary(b []byte) error {
	var res GetWebhookSubscriptionsByOrgOKBodyItems0SecurityPolicyConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
