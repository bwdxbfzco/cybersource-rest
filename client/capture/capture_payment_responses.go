// Code generated by go-swagger; DO NOT EDIT.

package capture

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CapturePaymentReader is a Reader for the CapturePayment structure.
type CapturePaymentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CapturePaymentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCapturePaymentCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCapturePaymentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewCapturePaymentBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[POST /pts/v2/payments/{id}/captures] capturePayment", response, response.Code())
	}
}

// NewCapturePaymentCreated creates a CapturePaymentCreated with default headers values
func NewCapturePaymentCreated() *CapturePaymentCreated {
	return &CapturePaymentCreated{}
}

/*
CapturePaymentCreated describes a response with status code 201, with default header values.

Successful response.
*/
type CapturePaymentCreated struct {
	Payload *CapturePaymentCreatedBody
}

// IsSuccess returns true when this capture payment created response has a 2xx status code
func (o *CapturePaymentCreated) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this capture payment created response has a 3xx status code
func (o *CapturePaymentCreated) IsRedirect() bool {
	return false
}

// IsClientError returns true when this capture payment created response has a 4xx status code
func (o *CapturePaymentCreated) IsClientError() bool {
	return false
}

// IsServerError returns true when this capture payment created response has a 5xx status code
func (o *CapturePaymentCreated) IsServerError() bool {
	return false
}

// IsCode returns true when this capture payment created response a status code equal to that given
func (o *CapturePaymentCreated) IsCode(code int) bool {
	return code == 201
}

// Code gets the status code for the capture payment created response
func (o *CapturePaymentCreated) Code() int {
	return 201
}

func (o *CapturePaymentCreated) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentCreated %s", 201, payload)
}

func (o *CapturePaymentCreated) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentCreated %s", 201, payload)
}

func (o *CapturePaymentCreated) GetPayload() *CapturePaymentCreatedBody {
	return o.Payload
}

func (o *CapturePaymentCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CapturePaymentCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCapturePaymentBadRequest creates a CapturePaymentBadRequest with default headers values
func NewCapturePaymentBadRequest() *CapturePaymentBadRequest {
	return &CapturePaymentBadRequest{}
}

/*
CapturePaymentBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type CapturePaymentBadRequest struct {
	Payload *CapturePaymentBadRequestBody
}

// IsSuccess returns true when this capture payment bad request response has a 2xx status code
func (o *CapturePaymentBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this capture payment bad request response has a 3xx status code
func (o *CapturePaymentBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this capture payment bad request response has a 4xx status code
func (o *CapturePaymentBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this capture payment bad request response has a 5xx status code
func (o *CapturePaymentBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this capture payment bad request response a status code equal to that given
func (o *CapturePaymentBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the capture payment bad request response
func (o *CapturePaymentBadRequest) Code() int {
	return 400
}

func (o *CapturePaymentBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentBadRequest %s", 400, payload)
}

func (o *CapturePaymentBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentBadRequest %s", 400, payload)
}

func (o *CapturePaymentBadRequest) GetPayload() *CapturePaymentBadRequestBody {
	return o.Payload
}

func (o *CapturePaymentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CapturePaymentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCapturePaymentBadGateway creates a CapturePaymentBadGateway with default headers values
func NewCapturePaymentBadGateway() *CapturePaymentBadGateway {
	return &CapturePaymentBadGateway{}
}

/*
CapturePaymentBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type CapturePaymentBadGateway struct {
	Payload *CapturePaymentBadGatewayBody
}

// IsSuccess returns true when this capture payment bad gateway response has a 2xx status code
func (o *CapturePaymentBadGateway) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this capture payment bad gateway response has a 3xx status code
func (o *CapturePaymentBadGateway) IsRedirect() bool {
	return false
}

// IsClientError returns true when this capture payment bad gateway response has a 4xx status code
func (o *CapturePaymentBadGateway) IsClientError() bool {
	return false
}

// IsServerError returns true when this capture payment bad gateway response has a 5xx status code
func (o *CapturePaymentBadGateway) IsServerError() bool {
	return true
}

// IsCode returns true when this capture payment bad gateway response a status code equal to that given
func (o *CapturePaymentBadGateway) IsCode(code int) bool {
	return code == 502
}

// Code gets the status code for the capture payment bad gateway response
func (o *CapturePaymentBadGateway) Code() int {
	return 502
}

func (o *CapturePaymentBadGateway) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentBadGateway %s", 502, payload)
}

func (o *CapturePaymentBadGateway) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentBadGateway %s", 502, payload)
}

func (o *CapturePaymentBadGateway) GetPayload() *CapturePaymentBadGatewayBody {
	return o.Payload
}

func (o *CapturePaymentBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CapturePaymentBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
CapturePaymentBadGatewayBody ptsV2PaymentsCapturesPost502Response
swagger:model CapturePaymentBadGatewayBody
*/
type CapturePaymentBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this capture payment bad gateway body
func (o *CapturePaymentBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment bad gateway body based on context it is used
func (o *CapturePaymentBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentBadRequestBody ptsV2PaymentsCapturesPost400Response
swagger:model CapturePaymentBadRequestBody
*/
type CapturePaymentBadRequestBody struct {

	// details
	Details []*CapturePaymentBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - EXCEEDS_AUTH_AMOUNT
	//  - AUTH_ALREADY_REVERSED
	//  - TRANSACTION_ALREADY_SETTLED
	//  - INVALID_AMOUNT
	//  - MISSING_AUTH
	//  - TRANSACTION_ALREADY_REVERSED_OR_SETTLED
	//  - NOT_SUPPORTED
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this capture payment bad request body
func (o *CapturePaymentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this capture payment bad request body based on the context it is used
func (o *CapturePaymentBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentBadRequestBodyDetailsItems0 capture payment bad request body details items0
swagger:model CapturePaymentBadRequestBodyDetailsItems0
*/
type CapturePaymentBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this capture payment bad request body details items0
func (o *CapturePaymentBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment bad request body details items0 based on context it is used
func (o *CapturePaymentBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentBody capture payment body
// Example: {"clientReferenceInformation":{"code":"TC50171_3"},"orderInformation":{"amountDetails":{"currency":"USD","totalAmount":"102.21"}}}
swagger:model CapturePaymentBody
*/
type CapturePaymentBody struct {

	// aggregator information
	AggregatorInformation *CapturePaymentParamsBodyAggregatorInformation `json:"aggregatorInformation,omitempty"`

	// buyer information
	BuyerInformation *CapturePaymentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CapturePaymentParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// device information
	DeviceInformation *CapturePaymentParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// installment information
	InstallmentInformation *CapturePaymentParamsBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// The object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*CapturePaymentParamsBodyMerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// merchant defined secure information
	MerchantDefinedSecureInformation *CapturePaymentParamsBodyMerchantDefinedSecureInformation `json:"merchantDefinedSecureInformation,omitempty"`

	// merchant information
	MerchantInformation *CapturePaymentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *CapturePaymentParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CapturePaymentParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CapturePaymentParamsBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CapturePaymentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// promotion information
	PromotionInformation *CapturePaymentParamsBodyPromotionInformation `json:"promotionInformation,omitempty"`

	// travel information
	TravelInformation *CapturePaymentParamsBodyTravelInformation `json:"travelInformation,omitempty"`
}

// Validate validates this capture payment body
func (o *CapturePaymentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedSecureInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePromotionInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTravelInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentBody) validateAggregatorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AggregatorInformation) { // not required
		return nil
	}

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateDeviceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateInstallmentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentBody) validateMerchantDefinedSecureInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDefinedSecureInformation) { // not required
		return nil
	}

	if o.MerchantDefinedSecureInformation != nil {
		if err := o.MerchantDefinedSecureInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantDefinedSecureInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantDefinedSecureInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validatePointOfSaleInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validatePromotionInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PromotionInformation) { // not required
		return nil
	}

	if o.PromotionInformation != nil {
		if err := o.PromotionInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "promotionInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "promotionInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateTravelInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TravelInformation) { // not required
		return nil
	}

	if o.TravelInformation != nil {
		if err := o.TravelInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment body based on the context it is used
func (o *CapturePaymentBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAggregatorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeviceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstallmentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantDefinedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantDefinedSecureInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePointOfSaleInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePromotionInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTravelInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentBody) contextValidateAggregatorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AggregatorInformation != nil {

		if swag.IsZero(o.AggregatorInformation) { // not required
			return nil
		}

		if err := o.AggregatorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {

		if swag.IsZero(o.BuyerInformation) { // not required
			return nil
		}

		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateDeviceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.DeviceInformation != nil {

		if swag.IsZero(o.DeviceInformation) { // not required
			return nil
		}

		if err := o.DeviceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateInstallmentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.InstallmentInformation != nil {

		if swag.IsZero(o.InstallmentInformation) { // not required
			return nil
		}

		if err := o.InstallmentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateMerchantDefinedInformation(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {

		if o.MerchantDefinedInformation[i] != nil {

			if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
				return nil
			}

			if err := o.MerchantDefinedInformation[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentBody) contextValidateMerchantDefinedSecureInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDefinedSecureInformation != nil {

		if swag.IsZero(o.MerchantDefinedSecureInformation) { // not required
			return nil
		}

		if err := o.MerchantDefinedSecureInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantDefinedSecureInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantDefinedSecureInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {

		if swag.IsZero(o.MerchantInformation) { // not required
			return nil
		}

		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {

		if swag.IsZero(o.PaymentInformation) { // not required
			return nil
		}

		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidatePointOfSaleInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PointOfSaleInformation != nil {

		if swag.IsZero(o.PointOfSaleInformation) { // not required
			return nil
		}

		if err := o.PointOfSaleInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidatePromotionInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PromotionInformation != nil {

		if swag.IsZero(o.PromotionInformation) { // not required
			return nil
		}

		if err := o.PromotionInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "promotionInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "promotionInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) contextValidateTravelInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TravelInformation != nil {

		if swag.IsZero(o.TravelInformation) { // not required
			return nil
		}

		if err := o.TravelInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBody ptsV2PaymentsCapturesPost201Response
// Example: {"_links":{"refund":{"href":"/pts/v2/captures/4963014519526177701545/refunds","method":"POST"},"self":{"href":"/pts/v2/captures/4963014519526177701545","method":"GET"},"void":{"href":"/pts/v2/captures/4963014519526177701545/voids","method":"POST"}},"clientReferenceInformation":{"code":"TC50171_3"},"id":"4963014519526177701545","orderInformation":{"amountDetails":{"currency":"USD","totalAmount":"102.21"}},"reconciliationId":"39570715X3E1LBQA","status":"200","statusInformation":{"message":"Successful transaction.","reason":"SUCCESS"},"submitTimeUtc":"2017-06-01T071731Z"}
swagger:model CapturePaymentCreatedBody
*/
type CapturePaymentCreatedBody struct {

	// links
	Links *CapturePaymentCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *CapturePaymentCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// order information
	OrderInformation *CapturePaymentCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CapturePaymentCreatedBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CapturePaymentCreatedBodyProcessingInformation `json:"processingInformation,omitempty"`

	// processor information
	ProcessorInformation *CapturePaymentCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// Reference number for the transaction.
	// Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource.
	// The actual value used in the request to the processor is provided back to you by Cybersource in the response.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - PENDING
	//  - TRANSMITTED (Only for Online Capture enabled merchants)
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this capture payment created body
func (o *CapturePaymentCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validatePointOfSaleInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment created body based on the context it is used
func (o *CapturePaymentCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePointOfSaleInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) contextValidatePointOfSaleInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PointOfSaleInformation != nil {

		if swag.IsZero(o.PointOfSaleInformation) { // not required
			return nil
		}

		if err := o.PointOfSaleInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) contextValidateProcessorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessorInformation != nil {

		if swag.IsZero(o.ProcessorInformation) { // not required
			return nil
		}

		if err := o.ProcessorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyClientReferenceInformation capture payment created body client reference information
swagger:model CapturePaymentCreatedBodyClientReferenceInformation
*/
type CapturePaymentCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Merchant ID that was used to create the subscription or customer profile for which the service was requested.
	//
	// If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using
	// subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using
	// profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	OwnerMerchantID string `json:"ownerMerchantId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds
	//
	// #### PIN Debit
	// Optional field for PIN Debit purchase and credit requests.
	//
	// Max Length: 14
	SubmitLocalDateTime string `json:"submitLocalDateTime,omitempty"`
}

// Validate validates this capture payment created body client reference information
func (o *CapturePaymentCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBodyClientReferenceInformation) validateSubmitLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.SubmitLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"clientReferenceInformation"+"."+"submitLocalDateTime", "body", o.SubmitLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment created body client reference information based on context it is used
func (o *CapturePaymentCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyLinks capture payment created body links
swagger:model CapturePaymentCreatedBodyLinks
*/
type CapturePaymentCreatedBodyLinks struct {

	// refund
	Refund *CapturePaymentCreatedBodyLinksRefund `json:"refund,omitempty"`

	// self
	Self *CapturePaymentCreatedBodyLinksSelf `json:"self,omitempty"`

	// void
	Void *CapturePaymentCreatedBodyLinksVoid `json:"void,omitempty"`
}

// Validate validates this capture payment created body links
func (o *CapturePaymentCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRefund(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVoid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyLinks) validateRefund(formats strfmt.Registry) error {
	if swag.IsZero(o.Refund) { // not required
		return nil
	}

	if o.Refund != nil {
		if err := o.Refund.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "refund")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "refund")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyLinks) validateVoid(formats strfmt.Registry) error {
	if swag.IsZero(o.Void) { // not required
		return nil
	}

	if o.Void != nil {
		if err := o.Void.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "void")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment created body links based on the context it is used
func (o *CapturePaymentCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRefund(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateVoid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyLinks) contextValidateRefund(ctx context.Context, formats strfmt.Registry) error {

	if o.Refund != nil {

		if swag.IsZero(o.Refund) { // not required
			return nil
		}

		if err := o.Refund.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "refund")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "refund")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyLinks) contextValidateVoid(ctx context.Context, formats strfmt.Registry) error {

	if o.Void != nil {

		if swag.IsZero(o.Void) { // not required
			return nil
		}

		if err := o.Void.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "void")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyLinksRefund capture payment created body links refund
swagger:model CapturePaymentCreatedBodyLinksRefund
*/
type CapturePaymentCreatedBodyLinksRefund struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this capture payment created body links refund
func (o *CapturePaymentCreatedBodyLinksRefund) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment created body links refund based on context it is used
func (o *CapturePaymentCreatedBodyLinksRefund) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksRefund) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksRefund) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinksRefund
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyLinksSelf capture payment created body links self
swagger:model CapturePaymentCreatedBodyLinksSelf
*/
type CapturePaymentCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this capture payment created body links self
func (o *CapturePaymentCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment created body links self based on context it is used
func (o *CapturePaymentCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyLinksVoid capture payment created body links void
swagger:model CapturePaymentCreatedBodyLinksVoid
*/
type CapturePaymentCreatedBodyLinksVoid struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this capture payment created body links void
func (o *CapturePaymentCreatedBodyLinksVoid) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment created body links void based on context it is used
func (o *CapturePaymentCreatedBodyLinksVoid) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksVoid) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksVoid) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinksVoid
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyOrderInformation capture payment created body order information
swagger:model CapturePaymentCreatedBodyOrderInformation
*/
type CapturePaymentCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *CapturePaymentCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// invoice details
	InvoiceDetails *CapturePaymentCreatedBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`
}

// Validate validates this capture payment created body order information
func (o *CapturePaymentCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment created body order information based on the context it is used
func (o *CapturePaymentCreatedBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {

		if swag.IsZero(o.InvoiceDetails) { // not required
			return nil
		}

		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyOrderInformationAmountDetails capture payment created body order information amount details
swagger:model CapturePaymentCreatedBodyOrderInformationAmountDetails
*/
type CapturePaymentCreatedBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// The fee decided by the PSP/Processor per transaction.
	// Max Length: 15
	ProcessorTransactionFee string `json:"processorTransactionFee,omitempty"`

	// Amount you requested for the capture.
	//
	// Max Length: 15
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this capture payment created body order information amount details
func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorTransactionFee(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) validateProcessorTransactionFee(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorTransactionFee) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"processorTransactionFee", "body", o.ProcessorTransactionFee, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment created body order information amount details based on context it is used
func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyOrderInformationInvoiceDetails capture payment created body order information invoice details
swagger:model CapturePaymentCreatedBodyOrderInformationInvoiceDetails
*/
type CapturePaymentCreatedBodyOrderInformationInvoiceDetails struct {

	// Indicates whether CyberSource sent the Level III information to the processor. The possible values are:
	//
	// If your account is not enabled for Level III data or if you did not include the purchasing level field in your
	// request, CyberSource does not include the Level III data in the request sent to the processor.
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	Level3TransmissionStatus bool `json:"level3TransmissionStatus,omitempty"`
}

// Validate validates this capture payment created body order information invoice details
func (o *CapturePaymentCreatedBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment created body order information invoice details based on context it is used
func (o *CapturePaymentCreatedBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyPointOfSaleInformation capture payment created body point of sale information
swagger:model CapturePaymentCreatedBodyPointOfSaleInformation
*/
type CapturePaymentCreatedBodyPointOfSaleInformation struct {

	// Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.
	//
	// #### CyberSource through VisaNet
	// A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for
	// your CyberSource account, the value you send for this field is validated against the list each time you include
	// the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.
	//
	// When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.
	//
	// #### FDC Nashville Global
	// To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.
	//
	// #### For Payouts
	// This field is applicable for CyberSource through VisaNet.
	//
	// #### GPX
	// Identifier for the terminal at your retail location. A list of all possible values is stored in your account.
	// If terminal ID validation is enabled for your account, the value you send for this field is validated against
	// the list each time you include the field in a request. To enable or disable terminal ID validation, contact
	// customer support.
	//
	// When you do not include this field in a request, the default value that is defined in your account is used.
	//
	// Optional for authorizations.
	//
	// #### Used by
	// **Authorization**
	// Optional for the following processors. When you do not include this field in a request, the default value that is
	// defined in your account is used.
	//   - American Express Direct
	//   - Credit Mutuel-CIC
	//   - FDC Nashville Global
	//   - SIX
	// - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`.
	// - FDMS Nashville: The default value that is defined in your account is used.
	// - GPX
	// - OmniPay Direct: Optional field.
	//
	// For the following processors, this field is not used.
	// - GPN
	// - JCN Gateway
	// - RBS WorldPay Atlanta
	// - TSYS Acquiring Solutions
	// - Worldpay VAP
	//
	// #### Card Present reply
	// Terminal identifier assigned by the acquirer. This value must be printed on the receipt.
	//
	// Max Length: 8
	TerminalID string `json:"terminalId,omitempty"`
}

// Validate validates this capture payment created body point of sale information
func (o *CapturePaymentCreatedBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTerminalID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyPointOfSaleInformation) validateTerminalID(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"pointOfSaleInformation"+"."+"terminalId", "body", o.TerminalID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment created body point of sale information based on context it is used
func (o *CapturePaymentCreatedBodyPointOfSaleInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyProcessingInformation capture payment created body processing information
swagger:model CapturePaymentCreatedBodyProcessingInformation
*/
type CapturePaymentCreatedBodyProcessingInformation struct {

	// The possible values for the reply field are:
	// - `true` : the airline data was included in the request to the processor.
	// - `false` : the airline data was not included in the request to the processor.
	//
	// Returned by authorization, capture, or credit services.
	//
	EnhancedDataEnabled bool `json:"enhancedDataEnabled,omitempty"`
}

// Validate validates this capture payment created body processing information
func (o *CapturePaymentCreatedBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment created body processing information based on context it is used
func (o *CapturePaymentCreatedBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentCreatedBodyProcessorInformation capture payment created body processor information
swagger:model CapturePaymentCreatedBodyProcessorInformation
*/
type CapturePaymentCreatedBodyProcessorInformation struct {

	// Network Transaction Identifier
	// Applicable for online capture transactions only.
	//
	NetworkTransactionID string `json:"networkTransactionId,omitempty"`

	// Processor response to the API request.
	//
	ProviderResponse string `json:"providerResponse,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	//
	// #### PIN debit
	// Response value that is returned by the processor or bank.
	// **Important** Do not use this field to evaluate the results of the transaction request.
	//
	// Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or response code received from the processor separated by a colon.
	// Format: [status code]:E[error code] or [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field.
	// String (3)
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// The processor code that describes why the transaction state is pending or reversed.
	//
	// Max Length: 60
	ResponseDetails string `json:"responseDetails,omitempty"`

	// Processor transaction ID.
	//
	// This value identifies the transaction on a host system. This value is supported only for Moneris. It contains
	// this information:
	//
	//  - Terminal used to process the transaction
	//  - Shift during which the transaction took place
	//  - Batch number
	//  - Transaction number within the batch
	//
	// You must store this value. If you give the customer a receipt, display this value on the receipt.
	//
	// Example For the value 66012345001069003:
	//
	//  - Terminal ID = 66012345
	//  - Shift number = 001
	//  - Batch number = 069
	//  - Transaction number = 003
	//
	// Max Length: 18
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this capture payment created body processor information
func (o *CapturePaymentCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"processorInformation"+"."+"responseCode", "body", o.ResponseCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBodyProcessorInformation) validateResponseDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"processorInformation"+"."+"responseDetails", "body", o.ResponseDetails, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"processorInformation"+"."+"transactionId", "body", o.TransactionID, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment created body processor information based on context it is used
func (o *CapturePaymentCreatedBodyProcessorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyAggregatorInformation capture payment params body aggregator information
swagger:model CapturePaymentParamsBodyAggregatorInformation
*/
type CapturePaymentParamsBodyAggregatorInformation struct {

	// Value that identifies you as a payment aggregator. Get this value from the
	// processor.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR6
	// - Position: 95-105
	// - Field: Payment Facilitator ID
	//
	// This field is supported for Visa, Mastercard and Discover Transactions.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the `aggregator_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AggregatorID string `json:"aggregatorId,omitempty"`

	// Your payment aggregator business name.
	//
	// **American Express Direct**\
	// The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the aggregator_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// sub merchant
	SubMerchant *CapturePaymentParamsBodyAggregatorInformationSubMerchant `json:"subMerchant,omitempty"`
}

// Validate validates this capture payment params body aggregator information
func (o *CapturePaymentParamsBodyAggregatorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubMerchant(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformation) validateAggregatorID(formats strfmt.Registry) error {
	if swag.IsZero(o.AggregatorID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"aggregatorId", "body", o.AggregatorID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformation) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformation) validateSubMerchant(formats strfmt.Registry) error {
	if swag.IsZero(o.SubMerchant) { // not required
		return nil
	}

	if o.SubMerchant != nil {
		if err := o.SubMerchant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment params body aggregator information based on the context it is used
func (o *CapturePaymentParamsBodyAggregatorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSubMerchant(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformation) contextValidateSubMerchant(ctx context.Context, formats strfmt.Registry) error {

	if o.SubMerchant != nil {

		if swag.IsZero(o.SubMerchant) { // not required
			return nil
		}

		if err := o.SubMerchant.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyAggregatorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyAggregatorInformationSubMerchant capture payment params body aggregator information sub merchant
swagger:model CapturePaymentParamsBodyAggregatorInformationSubMerchant
*/
type CapturePaymentParamsBodyAggregatorInformationSubMerchant struct {

	// First line of the sub-merchant's street address.
	//
	// For processor-specific details, see `submerchant_street` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 38
	Address1 string `json:"address1,omitempty"`

	// Sub-merchant's state or province.
	//
	// For possible values and also aggregator support, see `submerchant_state` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Sub-merchant's country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// For details, see the `submerchant_country` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Sub-merchant's email address.
	//
	// **Maximum length for processors**
	//
	//  - American Express Direct: 40
	//  - CyberSource through VisaNet: 40
	//  - FDC Compass: 40
	//  - FDC Nashville Global: 19
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 25-64
	// - Field: American Express Seller E-mail Address
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant's acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Max Length: 40
	Email string `json:"email,omitempty"`

	// The ID you assigned to your sub-merchant.
	// CyberSource through VisaNet: For American Express transaction, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 65-84
	// - Field: American Express Seller ID
	// For  Mastercard transactions, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 117-131
	// - Field: Sub-Merchant ID
	// FDC Compass: This value must consist of uppercase characters.
	//
	// American Express Direct: String (20)
	// CyberSource through VisaNet with American Express: String (20)
	// CyberSource through VisaNet with Visa,Mastercard and Discover: String (15)
	// FDC Compass: String (20)
	// FDC Nashville Global: String (14)
	//
	// Max Length: 20
	ID string `json:"id,omitempty"`

	// Sub-merchant's city.
	//
	// For processor-specific details, see `submerchant_city` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 21
	Locality string `json:"locality,omitempty"`

	// Sub-merchant's business name.
	//
	// #### American Express Direct
	// The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// #### FDC Nashville Global
	// With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name:
	// - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21.
	// - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17.
	// - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12.
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// Sub-merchant's telephone number.
	//
	// **Maximum length for procesors**
	//
	//  - American Express Direct: 20
	//  - CyberSource through VisaNet: 20
	//  - FDC Compass: 13
	//  - FDC Nashville Global: 10
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCRB
	// - Position: 5-24
	// - Field: American Express Seller Telephone Number
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters. Use one of these recommended formats:\
	// `NNN-NNN-NNNN`\
	// `NNN-AAAAAAA`
	//
	// Max Length: 20
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Partial postal code for the sub-merchant's address.
	//
	// For processor-specific details, see `submerchant_postal_code` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body aggregator information sub merchant
func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"address1", "body", o.Address1, 38); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"administrativeArea", "body", o.AdministrativeArea, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"email", "body", o.Email, 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"id", "body", o.ID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"locality", "body", o.Locality, 21); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"phoneNumber", "body", o.PhoneNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"postalCode", "body", o.PostalCode, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body aggregator information sub merchant based on context it is used
func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyAggregatorInformationSubMerchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyBuyerInformation capture payment params body buyer information
swagger:model CapturePaymentParamsBodyBuyerInformation
*/
type CapturePaymentParamsBodyBuyerInformation struct {

	// Recipient's date of birth. **Format**: `YYYYMMDD`.
	//
	// This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters
	// but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field
	// is not required for the transaction, CyberSource does not forward it to the processor.
	//
	// For more details, see `recipient_date_of_birth` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 8
	DateOfBirth string `json:"dateOfBirth,omitempty"`

	// Customer's gender. Possible values are F (female), M (male),O (other).
	// Max Length: 3
	Gender string `json:"gender,omitempty"`

	// language setting of the user
	// Max Length: 2
	Language string `json:"language,omitempty"`

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customer's contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// personal identification
	PersonalIdentification []*CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`

	// Customer's government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this capture payment params body buyer information
func (o *CapturePaymentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGender(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"buyerInformation"+"."+"dateOfBirth", "body", o.DateOfBirth, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validateGender(formats strfmt.Registry) error {
	if swag.IsZero(o.Gender) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"buyerInformation"+"."+"gender", "body", o.Gender, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validateLanguage(formats strfmt.Registry) error {
	if swag.IsZero(o.Language) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"buyerInformation"+"."+"language", "body", o.Language, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body buyer information based on the context it is used
func (o *CapturePaymentParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {

			if swag.IsZero(o.PersonalIdentification[i]) { // not required
				return nil
			}

			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 capture payment params body buyer information personal identification items0
swagger:model CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0
*/
type CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type. This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// If `type = PASSPORT`, this is the cardholder's passport number.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`
}

// Validate validates this capture payment params body buyer information personal identification items0
func (o *CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body buyer information personal identification items0 based on context it is used
func (o *CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyClientReferenceInformation capture payment params body client reference information
swagger:model CapturePaymentParamsBodyClientReferenceInformation
*/
type CapturePaymentParamsBodyClientReferenceInformation struct {

	// The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource.
	//
	ApplicationName string `json:"applicationName,omitempty"`

	// The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method.
	//
	ApplicationUser string `json:"applicationUser,omitempty"`

	// Version of the CyberSource application or integration used for a transaction.
	//
	ApplicationVersion string `json:"applicationVersion,omitempty"`

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *CapturePaymentParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call.
	//
	// Max Length: 26
	PausedRequestID string `json:"pausedRequestId,omitempty"`

	// Reference number for the transaction.
	// Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource.
	// The actual value used in the request to the processor is provided back to you by Cybersource in the response.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.
	//
	// **Note** Use this field only if you want to support merchant-initiated reversal and void operations.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, and Void**
	// Optional field.
	//
	// #### PIN Debit
	// For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier.
	// Optional field for PIN debit purchase or credit requests.
	//
	// Max Length: 30
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this capture payment params body client reference information
func (o *CapturePaymentParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePausedRequestID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) validatePausedRequestID(formats strfmt.Registry) error {
	if swag.IsZero(o.PausedRequestID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"pausedRequestId", "body", o.PausedRequestID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"transactionId", "body", o.TransactionID, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body client reference information based on the context it is used
func (o *CapturePaymentParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {

		if swag.IsZero(o.Partner) { // not required
			return nil
		}

		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyClientReferenceInformationPartner capture payment params body client reference information partner
swagger:model CapturePaymentParamsBodyClientReferenceInformationPartner
*/
type CapturePaymentParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminal's software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal's
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`

	// Value that identifies the application vendor and application version for a third party gateway.
	// CyberSource provides you with this value during testing and validation.
	// This field is supported only on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, Incremental Authorization, and Void**
	// Optional field.
	//
	// #### PIN debit
	// Required field for PIN debit credit, PIN debit purchase, or PIN debit reversal request.
	//
	// Max Length: 12
	ThirdPartyCertificationNumber string `json:"thirdPartyCertificationNumber,omitempty"`
}

// Validate validates this capture payment params body client reference information partner
func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThirdPartyCertificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", o.OriginalTransactionID, 32); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) validateThirdPartyCertificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ThirdPartyCertificationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"thirdPartyCertificationNumber", "body", o.ThirdPartyCertificationNumber, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body client reference information partner based on context it is used
func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyDeviceInformation capture payment params body device information
swagger:model CapturePaymentParamsBodyDeviceInformation
*/
type CapturePaymentParamsBodyDeviceInformation struct {

	// DNS resolved hostname from `ipAddress`.
	// Max Length: 60
	HostName string `json:"hostName,omitempty"`

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 45
	IPAddress string `json:"ipAddress,omitempty"`

	// Customer's browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies
	// the Netscape browser.
	//
	// Max Length: 40
	UserAgent string `json:"userAgent,omitempty"`
}

// Validate validates this capture payment params body device information
func (o *CapturePaymentParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyDeviceInformation) validateHostName(formats strfmt.Registry) error {
	if swag.IsZero(o.HostName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"deviceInformation"+"."+"hostName", "body", o.HostName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", o.IPAddress, 45); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyDeviceInformation) validateUserAgent(formats strfmt.Registry) error {
	if swag.IsZero(o.UserAgent) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"deviceInformation"+"."+"userAgent", "body", o.UserAgent, 40); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body device information based on context it is used
func (o *CapturePaymentParamsBodyDeviceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyInstallmentInformation capture payment params body installment information
swagger:model CapturePaymentParamsBodyInstallmentInformation
*/
type CapturePaymentParamsBodyInstallmentInformation struct {

	// Additional costs charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 128-139
	// - Field: Total Other Costs
	//
	// Max Length: 12
	AdditionalCosts string `json:"additionalCosts,omitempty"`

	// Additional costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 140-143
	// - Field: Percent of Total Other Costs
	//
	// Max Length: 4
	AdditionalCostsPercentage string `json:"additionalCostsPercentage,omitempty"`

	// Amount for the current installment payment.
	//
	// This field is supported only for CyberSource through VisaNet.
	//
	// For details, see `installment_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Amount funded.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 48-59
	// - Field: Total Amount Funded
	//
	// Max Length: 12
	AmountFunded string `json:"amountFunded,omitempty"`

	// Amount requested divided by the amount funded.
	//
	// For example:
	// - A value of 90.0 specifies 90%.
	// - A value of 93.7 specifies 93.7%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 60-63
	// - Field: Percent of Amount Requested
	//
	// Max Length: 4
	AmountRequestedPercentage string `json:"amountRequestedPercentage,omitempty"`

	// Annual cost of financing the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 158-164
	// - Field: Annual Total Cost of Financing
	//
	// Max Length: 7
	AnnualFinancingCost string `json:"annualFinancingCost,omitempty"`

	// Annual interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 151-157
	// - Field: Annual Interest Rate
	//
	// Max Length: 7
	AnnualInterestRate string `json:"annualInterestRate,omitempty"`

	// Expenses charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 64-75
	// - Field: Total Expenses
	//
	// Max Length: 12
	Expenses string `json:"expenses,omitempty"`

	// Expenses divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 76-79
	// - Field: Percent of Total Expenses
	//
	// Max Length: 4
	ExpensesPercentage string `json:"expensesPercentage,omitempty"`

	// Fees charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 80-91
	// - Field: Total Fees
	//
	// Max Length: 12
	Fees string `json:"fees,omitempty"`

	// Fees divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 92-95
	// - Field: Percent of Total Fees
	//
	// Max Length: 4
	FeesPercentage string `json:"feesPercentage,omitempty"`

	// Amount of the first installment payment. The issuer provides this value when the first installment payment is successful.
	// This field is supported for Mastercard installment payments on CyberSource through VisaNet in all countries except Brazil,Croatia, Georgia, and Greece.
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR5
	// - Position: 23-34
	// - Field: Amount of Each Installment
	//
	// Max Length: 13
	FirstInstallmentAmount string `json:"firstInstallmentAmount,omitempty"`

	// Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR9
	// - Position: 42-47
	// - Field: Date of First Installment
	//
	// Max Length: 6
	FirstInstallmentDate string `json:"firstInstallmentDate,omitempty"`

	// Frequency of the installment payments. When you do not include this field in a request for a
	// Crediario installment payment, CyberSource sends a space character to the processor.
	//
	// For details, see `installment_frequency` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for CyberSource through VisaNet. Possible values:
	// - `B`: Biweekly
	// - `M`: Monthly
	// - `W`: Weekly
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR9
	// - Position: 41
	// - Field: Installment Frequency
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	Frequency string `json:"frequency,omitempty"`

	// Insurance charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 112-123
	// - Field: Total Insurance
	//
	// Max Length: 12
	Insurance string `json:"insurance,omitempty"`

	// Insurance costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 124-127
	// - Field: Percent Of Total Insurance
	//
	// Max Length: 4
	InsurancePercentage string `json:"insurancePercentage,omitempty"`

	// Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is
	// the same for all installment payments for one purchase.
	//
	// This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR4
	// - Position: 51-70
	// - Field: Purchase Identification
	//
	// Max Length: 20
	InvoiceData string `json:"invoiceData,omitempty"`

	// Monthly interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 144-150
	// - Field: Monthly Interest Rate
	//
	// Max Length: 7
	MonthlyInterestRate string `json:"monthlyInterestRate,omitempty"`

	// Payment plan for the installments.
	//
	// Possible values:
	// - 0 (default): Regular installment. This value is not allowed for airline transactions.
	// - 1: Installment payment with down payment.
	// - 2: Installment payment without down payment. This value is supported only for airline transactions.
	// - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions.
	// - 4: Down payment only; regular installment payment will follow.
	// - 5: Boarding fee only. This value is supported only for airline transactions.
	//
	// This field is supported only for installment payments with Visa on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 9
	// - Field: Merchant Installment Supporting Information
	//
	// Max Length: 1
	PaymentType string `json:"paymentType,omitempty"`

	// #### American Express Direct, Cielo, and CyberSource Latin American Processing
	// Flag that indicates the type of funding for the installment plan associated with the payment.
	//
	// Possible values:
	// - `1`: Merchant-funded installment plan
	// - `2`: Issuer-funded installment plan
	// If you do not include this field in the request, CyberSource uses the value in your CyberSource account.
	//
	// To change the value in your CyberSource account, contact CyberSource Customer Service.
	// For details, see `installment_plan_type` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet and American Express
	// Defined code that indicates the type of installment plan for this transaction.
	//
	// Contact American Express for:
	// - Information about the kinds of installment plans that American Express provides
	// - Values for this field
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 5-6
	// - Field: Plan Type
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant's acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// #### CyberSource through VisaNet with Visa or Mastercard
	// Flag indicating the type of funding for the installment plan associated with the payment.
	// Possible values:
	// - 1 or 01: Merchant-funded installment plan
	// - 2 or 02: Issuer-funded installment plan
	// - 43: Crediario installment plan—only with Visa in Brazil
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 5-6
	// - Field: Installment Type
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR5
	// - Position: 39-40
	// - Field: Installment Plan Type (Issuer or Merchant)
	//
	// Max Length: 1
	PlanType string `json:"planType,omitempty"`

	// Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 38-40
	// - Field: Installment Payment Number
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant's acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	Sequence int64 `json:"sequence,omitempty"`

	// Taxes collected by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 96-107
	// - Field: Total Taxes
	//
	// Max Length: 12
	Taxes string `json:"taxes,omitempty"`

	// Taxes divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 108-111
	// - Field: Percent of Total Taxes
	//
	// Max Length: 4
	TaxesPercentage string `json:"taxesPercentage,omitempty"`

	// Total amount of the loan that is being paid in installments. This field is supported only for CyberSource
	// through VisaNet.
	//
	// For details, see "Installment Payments" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 12
	TotalAmount string `json:"totalAmount,omitempty"`

	// Total number of installments when making payments in installments.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	//
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### American Express Direct, Cielo, and Comercio Latino
	// This value is the total number of installments you approved.
	//
	// #### CyberSource Latin American Processing in Brazil
	// This value is the total number of installments that you approved. The default is 1.
	//
	// #### All Other Processors
	// This value is used along with _sequence_ to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as _sequence_ = 2 and _totalCount_ = 5.
	//
	// #### CyberSource through VisaNet
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 23-25
	// - Field: Number of Installments
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR1
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR5
	// - Position: 20-22
	// - Field: Installment Total Count
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant's acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	TotalCount int64 `json:"totalCount,omitempty"`
}

// Validate validates this capture payment params body installment information
func (o *CapturePaymentParamsBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCosts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdditionalCostsPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountFunded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountRequestedPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualFinancingCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpenses(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpensesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFees(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFeesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurancePercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMonthlyInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlanType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSequence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAdditionalCosts(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCosts) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"additionalCosts", "body", o.AdditionalCosts, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAdditionalCostsPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCostsPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"additionalCostsPercentage", "body", o.AdditionalCostsPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"amount", "body", o.Amount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAmountFunded(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountFunded) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"amountFunded", "body", o.AmountFunded, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAmountRequestedPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountRequestedPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"amountRequestedPercentage", "body", o.AmountRequestedPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAnnualFinancingCost(formats strfmt.Registry) error {
	if swag.IsZero(o.AnnualFinancingCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"annualFinancingCost", "body", o.AnnualFinancingCost, 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAnnualInterestRate(formats strfmt.Registry) error {
	if swag.IsZero(o.AnnualInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"annualInterestRate", "body", o.AnnualInterestRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateExpenses(formats strfmt.Registry) error {
	if swag.IsZero(o.Expenses) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"expenses", "body", o.Expenses, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateExpensesPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpensesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"expensesPercentage", "body", o.ExpensesPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFees(formats strfmt.Registry) error {
	if swag.IsZero(o.Fees) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"fees", "body", o.Fees, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFeesPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.FeesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"feesPercentage", "body", o.FeesPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFirstInstallmentAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstInstallmentAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"firstInstallmentAmount", "body", o.FirstInstallmentAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFirstInstallmentDate(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstInstallmentDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"firstInstallmentDate", "body", o.FirstInstallmentDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFrequency(formats strfmt.Registry) error {
	if swag.IsZero(o.Frequency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"frequency", "body", o.Frequency, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateInsurance(formats strfmt.Registry) error {
	if swag.IsZero(o.Insurance) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"insurance", "body", o.Insurance, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateInsurancePercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.InsurancePercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"insurancePercentage", "body", o.InsurancePercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateInvoiceData(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceData) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"invoiceData", "body", o.InvoiceData, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateMonthlyInterestRate(formats strfmt.Registry) error {
	if swag.IsZero(o.MonthlyInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"monthlyInterestRate", "body", o.MonthlyInterestRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validatePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"paymentType", "body", o.PaymentType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validatePlanType(formats strfmt.Registry) error {
	if swag.IsZero(o.PlanType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"planType", "body", o.PlanType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateSequence(formats strfmt.Registry) error {
	if swag.IsZero(o.Sequence) { // not required
		return nil
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"installmentInformation"+"."+"sequence", "body", o.Sequence, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateTaxes(formats strfmt.Registry) error {
	if swag.IsZero(o.Taxes) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"taxes", "body", o.Taxes, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateTaxesPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"taxesPercentage", "body", o.TaxesPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"totalAmount", "body", o.TotalAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateTotalCount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalCount) { // not required
		return nil
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"installmentInformation"+"."+"totalCount", "body", o.TotalCount, 99, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body installment information based on context it is used
func (o *CapturePaymentParamsBodyInstallmentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyMerchantDefinedInformationItems0 capture payment params body merchant defined information items0
swagger:model CapturePaymentParamsBodyMerchantDefinedInformationItems0
*/
type CapturePaymentParamsBodyMerchantDefinedInformationItems0 struct {

	// The number you assign for as the key for your merchant-defined data field. Valid values are 0 to 100.
	//
	// For example, to set or access the key for the 2nd merchant-defined data field in the array, you would reference `merchantDefinedInformation[1].key`.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].key` and
	// `merchantDefinedInformation[1].key` for data that you want to provide to the issuer to identify the
	// transaction.
	//
	// For details, see the `merchant_defined_data1` request-level field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 50
	Key string `json:"key,omitempty"`

	// The value you assign for your merchant-defined data field.
	//
	// For details, see `merchant_defined_data1` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not
	// limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV,
	// CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].value` and
	// `merchantDefinedInformation[1].value` for data that you want to provide to the issuer to identify the
	// transaction. For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For installment payments with Mastercard in Brazil:
	// - The value for merchantDefinedInformation[0].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 25-44
	//   - Field: Reference Field 2
	// - The value for merchantDefinedInformation[1].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 45-64
	//   - Field: Reference Field 3
	//
	// Max Length: 255
	Value string `json:"value,omitempty"`
}

// Validate validates this capture payment params body merchant defined information items0
func (o *CapturePaymentParamsBodyMerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantDefinedInformationItems0) validateKey(formats strfmt.Registry) error {
	if swag.IsZero(o.Key) { // not required
		return nil
	}

	if err := validate.MaxLength("key", "body", o.Key, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", o.Value, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body merchant defined information items0 based on context it is used
func (o *CapturePaymentParamsBodyMerchantDefinedInformationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyMerchantDefinedSecureInformation The object containing the secure data that the merchant defines.
//
swagger:model CapturePaymentParamsBodyMerchantDefinedSecureInformation
*/
type CapturePaymentParamsBodyMerchantDefinedSecureInformation struct {

	// The value you assign for your merchant-secure data field 1.
	//
	// Max Length: 2048
	Secure1 string `json:"secure1,omitempty"`

	// The value you assign for your merchant-secure data field 2.
	//
	// Max Length: 2048
	Secure2 string `json:"secure2,omitempty"`

	// The value you assign for your merchant-secure data field 3.
	//
	// Max Length: 2048
	Secure3 string `json:"secure3,omitempty"`

	// The value you assign for your merchant-secure data field 4.
	//
	// Max Length: 2048
	Secure4 string `json:"secure4,omitempty"`
}

// Validate validates this capture payment params body merchant defined secure information
func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSecure1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecure2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecure3(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecure4(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) validateSecure1(formats strfmt.Registry) error {
	if swag.IsZero(o.Secure1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantDefinedSecureInformation"+"."+"secure1", "body", o.Secure1, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) validateSecure2(formats strfmt.Registry) error {
	if swag.IsZero(o.Secure2) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantDefinedSecureInformation"+"."+"secure2", "body", o.Secure2, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) validateSecure3(formats strfmt.Registry) error {
	if swag.IsZero(o.Secure3) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantDefinedSecureInformation"+"."+"secure3", "body", o.Secure3, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) validateSecure4(formats strfmt.Registry) error {
	if swag.IsZero(o.Secure4) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantDefinedSecureInformation"+"."+"secure4", "body", o.Secure4, 2048); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body merchant defined secure information based on context it is used
func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantDefinedSecureInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantDefinedSecureInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyMerchantInformation capture payment params body merchant information
swagger:model CapturePaymentParamsBodyMerchantInformation
*/
type CapturePaymentParamsBodyMerchantInformation struct {

	// Reference number that facilitates card acceptor/corporation communication and record keeping.
	//
	// For processor-specific information, see the `card_acceptor_ref_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	CardAcceptorReferenceNumber string `json:"cardAcceptorReferenceNumber,omitempty"`

	// The value for this field is a four-digit number that the payment card industry uses to classify
	// merchants into market segments. A payment card company assigned one or more of these values to your business when you started
	// accepting the payment card company's cards. When you do not include this field in your request, CyberSource uses the value in your
	// CyberSource account.
	//
	// For processor-specific information, see the `merchant_category_code` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR4
	// - Position: 150-153
	// - Field: Merchant Category Code
	//
	// Maximum: 9999
	CategoryCode int64 `json:"categoryCode,omitempty"`

	// merchant descriptor
	MerchantDescriptor *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// service fee descriptor
	ServiceFeeDescriptor *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor `json:"serviceFeeDescriptor,omitempty"`

	// Your Cadastro Nacional da Pessoa Jurídica (CNPJ) number.
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR6
	// - Position: 40-59
	// - Field: BNDES Reference Field 1
	//
	// For details, see `bill_merchant_tax_id` field description in the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Your government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Required field for value added tax only. Not applicable to U.S. and Canadian taxes.
	//
	// #### CyberSource through VisaNet
	// For CtV processors, the maximum length is 20.
	//
	// For other processor-specific information, see the `merchant_vat_registration_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 21
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this capture payment params body merchant information
func (o *CapturePaymentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardAcceptorReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateCardAcceptorReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CardAcceptorReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"cardAcceptorReferenceNumber", "body", o.CardAcceptorReferenceNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"merchantInformation"+"."+"categoryCode", "body", o.CategoryCode, 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateServiceFeeDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.ServiceFeeDescriptor) { // not required
		return nil
	}

	if o.ServiceFeeDescriptor != nil {
		if err := o.ServiceFeeDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 21); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body merchant information based on the context it is used
func (o *CapturePaymentParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateServiceFeeDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {

		if swag.IsZero(o.MerchantDescriptor) { // not required
			return nil
		}

		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) contextValidateServiceFeeDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.ServiceFeeDescriptor != nil {

		if swag.IsZero(o.ServiceFeeDescriptor) { // not required
			return nil
		}

		if err := o.ServiceFeeDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyMerchantInformationMerchantDescriptor capture payment params body merchant information merchant descriptor
swagger:model CapturePaymentParamsBodyMerchantInformationMerchantDescriptor
*/
type CapturePaymentParamsBodyMerchantInformationMerchantDescriptor struct {

	// First line of merchant's address. For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_street` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// The state where the merchant is located.
	//
	// #### PIN debit
	// State code or region code for your business. Use the Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) This value might be displayed on the cardholder's statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// An alternate name for the merchant.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_alternate` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`

	// For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_contact` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	// Contact information for the merchant.
	//
	// **Note** These are the maximum data lengths for the following payment processors:
	// - FDCCompass (13)
	// - Paymentech (13)
	//
	// Max Length: 14
	Contact string `json:"contact,omitempty"`

	// Merchant's country.
	//
	// #### PIN debit
	// Country code for your business location. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	// This value might be displayed on the cardholder's statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	// **Note** If your business is located in the U.S. or Canada and you include this field in a
	// request, you must also include `merchantInformation.merchantDescriptor.administrativeArea`.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// #### Visa Platform Connect
	// This field will indicate merchant country of origin
	//
	// Max Length: 2
	CountryOfOrigin string `json:"countryOfOrigin,omitempty"`

	// #### Visa Platform Connect
	// Indicates customer service phone number of Merchant.
	//
	// Max Length: 27
	CustomerServicePhoneNumber string `json:"customerServicePhoneNumber,omitempty"`

	// Merchant's City.
	//
	// #### PIN debit
	// City for your business location. This value might be displayed on the cardholder's statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// Max Length: 13
	Locality string `json:"locality,omitempty"`

	// Your merchant name.
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	// #### PIN debit
	// Your business name. This name is displayed on the cardholder's statement. When you
	// include more than one consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// #### Airline processing
	// Your merchant name. This name is displayed on the cardholder's statement. When you include more than one consecutive space, extra spaces are removed.
	//
	// **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.
	//
	// **Important** This value must consist of English characters.
	//
	// Required for captures and credits.
	//
	Name string `json:"name,omitempty"`

	// Merchant phone as contact information for CNP transactions
	//
	// Max Length: 13
	Phone string `json:"phone,omitempty"`

	// Merchant's postal code.
	//
	// #### PIN debit
	// Postal code for your business location. This value might be displayed on the cardholder's statement.
	//
	// If your business is domiciled in the U.S., you can use a 5-digit or 9-digit postal code. A 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	// Example: `12345-6789`
	//
	// If your business is domiciled in Canada, you can use a 6-digit or 9-digit postal code. A 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space]
	// [numeric][alpha][numeric]
	// Example: `A1B 2C3`
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	// **Important** Mastercard requires a postal code for any country that uses postal codes.
	// You can provide the postal code in your account or you can include this field in your request.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 14
	PostalCode string `json:"postalCode,omitempty"`

	// The identifier of the store.
	//
	// Max Length: 50
	StoreID string `json:"storeId,omitempty"`

	// The name of the store.
	//
	// Max Length: 50
	StoreName string `json:"storeName,omitempty"`

	// Address of company's website provided by merchant
	//
	// Max Length: 255
	URL string `json:"url,omitempty"`
}

// Validate validates this capture payment params body merchant information merchant descriptor
func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountryOfOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerServicePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStoreID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStoreName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateContact(formats strfmt.Registry) error {
	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"contact", "body", o.Contact, 14); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateCountryOfOrigin(formats strfmt.Registry) error {
	if swag.IsZero(o.CountryOfOrigin) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"countryOfOrigin", "body", o.CountryOfOrigin, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateCustomerServicePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerServicePhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"customerServicePhoneNumber", "body", o.CustomerServicePhoneNumber, 27); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"locality", "body", o.Locality, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validatePhone(formats strfmt.Registry) error {
	if swag.IsZero(o.Phone) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"phone", "body", o.Phone, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"postalCode", "body", o.PostalCode, 14); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateStoreID(formats strfmt.Registry) error {
	if swag.IsZero(o.StoreID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"storeId", "body", o.StoreID, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateStoreName(formats strfmt.Registry) error {
	if swag.IsZero(o.StoreName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"storeName", "body", o.StoreName, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(o.URL) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"url", "body", o.URL, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body merchant information merchant descriptor based on context it is used
func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor capture payment params body merchant information service fee descriptor
swagger:model CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor
*/
type CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor struct {

	// Contact information for the service provider that is collecting the service fee. when you include more than one
	// consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholder's statement.
	//
	// Max Length: 11
	Contact string `json:"contact,omitempty"`

	// Name of the service provider that is collecting the service fee. The service provider name must consist of
	// 3, 7, or 12 characters followed by an asterisk (*). This value must also include the words "Service Fee."
	//
	// When you include more than one consecutive space, extra spaces are removed. Use one of the following formats
	// for this value:
	// - <3-character name>*Service Fee
	// - <7-character name>*Service Fee
	// - <12-character name>*Service Fee
	//
	// When payments are made in installments, this value must also include installment information such as
	// "1 of 5" or "3 of 7." For installment payments, use one of the following formats for this value:
	// - <3-character name>*Service Fee*<N> of <M>
	// - <7-character name>*Service Fee*<N> of <M>
	// - <12-character name>*Service Fee*<N> of <M>
	//
	// where <N> is the payment number and <M> is the total number of payments.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource
	// account.
	//
	// This value might be displayed on the cardholder's statement.
	//
	// Max Length: 22
	Name string `json:"name,omitempty"`

	// State or territory in which the service provider is located.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholder's statement.
	//
	// Max Length: 20
	State string `json:"state,omitempty"`
}

// Validate validates this capture payment params body merchant information service fee descriptor
func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateContact(formats strfmt.Registry) error {
	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"contact", "body", o.Contact, 11); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"name", "body", o.Name, 22); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"state", "body", o.State, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body merchant information service fee descriptor based on context it is used
func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformation capture payment params body order information
swagger:model CapturePaymentParamsBodyOrderInformation
*/
type CapturePaymentParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *CapturePaymentParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *CapturePaymentParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// invoice details
	InvoiceDetails *CapturePaymentParamsBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// line items
	LineItems []*CapturePaymentParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// ship to
	ShipTo *CapturePaymentParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// shipping details
	ShippingDetails *CapturePaymentParamsBodyOrderInformationShippingDetails `json:"shippingDetails,omitempty"`
}

// Validate validates this capture payment params body order information
func (o *CapturePaymentParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateShippingDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingDetails) { // not required
		return nil
	}

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment params body order information based on the context it is used
func (o *CapturePaymentParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {

		if swag.IsZero(o.InvoiceDetails) { // not required
			return nil
		}

		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {

			if swag.IsZero(o.LineItems[i]) { // not required
				return nil
			}

			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {

		if swag.IsZero(o.ShipTo) { // not required
			return nil
		}

		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) contextValidateShippingDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingDetails != nil {

		if swag.IsZero(o.ShippingDetails) { // not required
			return nil
		}

		if err := o.ShippingDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationAmountDetails capture payment params body order information amount details
swagger:model CapturePaymentParamsBodyOrderInformationAmountDetails
*/
type CapturePaymentParamsBodyOrderInformationAmountDetails struct {

	// amex additional amounts
	AmexAdditionalAmounts []*CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 `json:"amexAdditionalAmounts"`

	// Cashback amount in the acquirer's currency. If a cashback amount is included in the request, it must be included
	// in the `orderInformation.amountDetails.totalAmount` value.
	//
	// This field is supported only on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization**
	// Optional.
	// **Authorization Reversal**
	// Optional.
	//
	// #### PIN debit
	// Optional field for PIN debit purchase, PIN debit credit or PIN debit reversal.
	//
	// Max Length: 13
	CashbackAmount string `json:"cashbackAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Total discount amount applied to the order.
	//
	// Max Length: 15
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Total charges for any import or export duties included in the order.
	//
	// Max Length: 15
	DutyAmount string `json:"dutyAmount,omitempty"`

	// Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places.
	//
	// For details, see `exchange_rate` request-level field description in the [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf)
	//
	// Max Length: 13
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// Time stamp for the exchange rate. This value is returned by the DCC service.
	//
	// Format: `YYYYMMDD~HH:MM`  where ~ denotes a space.
	//
	// Max Length: 14
	ExchangeRateTimeStamp string `json:"exchangeRateTimeStamp,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	ForeignAmount string `json:"foreignAmount,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	//
	// Max Length: 5
	ForeignCurrency string `json:"foreignCurrency,omitempty"`

	// Total freight or shipping and handling charges for the order. When you include this field in your request, you
	// must also include the **totalAmount** field.
	//
	// For processor-specific information, see the freight_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 13
	FreightAmount string `json:"freightAmount,omitempty"`

	// Gratuity or tip amount for restaurants. Allowed only when industryDatatype=restaurant.
	// When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not
	// submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the
	// issuer has chargeback rights for the excess amount.
	//
	// Used by **Capture**
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Restaurant data is supported only on CyberSource through VisaNet when card is present.
	//
	// Max Length: 13
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Flag that indicates whether a national tax is included in the order total.
	//
	// Possible values:
	//
	//  - **0**: national tax not included
	//  - **1**: national tax included
	//
	// Max Length: 1
	NationalTaxIncluded string `json:"nationalTaxIncluded,omitempty"`

	// Your local pricing currency code.
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// Max Length: 15
	OriginalCurrency string `json:"originalCurrency,omitempty"`

	// Service fee. Required for service fee transactions.
	//
	// Max Length: 15
	ServiceFeeAmount string `json:"serviceFeeAmount,omitempty"`

	// Total tax amount for all the items in the order.
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag that indicates how the merchant manages discounts.
	//
	// Possible values:
	//
	//  - **0**: no invoice level discount included
	//  - **1**: tax calculated on the postdiscount invoice total
	//  - **2**: tax calculated on the prediscount invoice total
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// Flag that indicates how you calculate tax.
	//
	// Possible values:
	//
	//  - **0**: net prices with tax calculated at line item level
	//  - **1**: net prices with tax calculated at invoice level
	//  - **2**: gross prices with tax provided at line item level
	//  - **3**: gross prices with tax provided at invoice level
	//  - **4**: no tax applies on the invoice for the transaction
	//
	// Max Length: 1
	TaxAppliedLevel string `json:"taxAppliedLevel,omitempty"`

	// tax details
	TaxDetails []*CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 `json:"taxDetails"`

	// For tax amounts that can be categorized as one tax type.
	//
	// This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.
	//
	// Possible values:
	//
	//  - **056**: sales tax (U.S only)
	//  - **TX~**: all taxes (Canada only)   Note ~ = space.
	//
	// Max Length: 3
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this capture payment params body order information amount details
func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexAdditionalAmounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCashbackAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDutyAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRateTimeStamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFreightAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalTaxIncluded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateAmexAdditionalAmounts(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexAdditionalAmounts) { // not required
		return nil
	}

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {
		if swag.IsZero(o.AmexAdditionalAmounts[i]) { // not required
			continue
		}

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateCashbackAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.CashbackAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"cashbackAmount", "body", o.CashbackAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", o.DiscountAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateDutyAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DutyAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"dutyAmount", "body", o.DutyAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRate(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRate", "body", o.ExchangeRate, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRateTimeStamp(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeRateTimeStamp) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRateTimeStamp", "body", o.ExchangeRateTimeStamp, 14); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateForeignAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignAmount", "body", o.ForeignAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateForeignCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignCurrency", "body", o.ForeignCurrency, 5); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateFreightAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FreightAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"freightAmount", "body", o.FreightAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateGratuityAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"gratuityAmount", "body", o.GratuityAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateNationalTaxIncluded(formats strfmt.Registry) error {
	if swag.IsZero(o.NationalTaxIncluded) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"nationalTaxIncluded", "body", o.NationalTaxIncluded, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateOriginalCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalCurrency", "body", o.OriginalCurrency, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateServiceFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ServiceFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"serviceFeeAmount", "body", o.ServiceFeeAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAmount", "body", o.TaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedAfterDiscount", "body", o.TaxAppliedAfterDiscount, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedLevel", "body", o.TaxAppliedLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxTypeCode(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxTypeCode", "body", o.TaxTypeCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body order information amount details based on the context it is used
func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmexAdditionalAmounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) contextValidateAmexAdditionalAmounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {

		if o.AmexAdditionalAmounts[i] != nil {

			if swag.IsZero(o.AmexAdditionalAmounts[i]) { // not required
				return nil
			}

			if err := o.AmexAdditionalAmounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {

			if swag.IsZero(o.TaxDetails[i]) { // not required
				return nil
			}

			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 capture payment params body order information amount details amex additional amounts items0
swagger:model CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
*/
type CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 struct {

	// Additional amount. This field is supported only for **American Express Direct**.
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Additional amount type. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the `additional_amount_type0` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`
}

// Validate validates this capture payment params body order information amount details amex additional amounts items0
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information amount details amex additional amounts items0 based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 capture payment params body order information amount details tax details items0
swagger:model CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
*/
type CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// | ------------- |:-------------:|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of value added tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	// | `green`     | Green tax amount for Korean Processing. |
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	// - `green`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this capture payment params body order information amount details tax details items0
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information amount details tax details items0 based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationBillTo capture payment params body order information bill to
swagger:model CapturePaymentParamsBodyOrderInformationBillTo
*/
type CapturePaymentParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer's records.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_,
	// it must be sent as _1 1st Street_.
	//
	// Required if keyed; not used if swiped.
	//
	// String (20)
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional.
	// String (60)
	//
	// #### For Payouts
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Used for additional address information. For example: _Attention: Accounts Payable_
	// Optional field.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### FDMS Nashville
	// `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters.
	// String (20)
	//
	// #### All Other Processors
	// String (60)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// company
	Company *CapturePaymentParamsBodyOrderInformationBillToCompany `json:"company,omitempty"`

	// Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### SEPA/BACS
	// Required for Create Mandate and Import Mandate
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// U.S. county if available.
	// Max Length: 50
	County string `json:"county,omitempty"`

	// Customer's neighborhood, community, or region (a barrio in Brazil) within the city or municipality. This
	// field is available only on **Cielo**.
	//
	// Max Length: 50
	District string `json:"district,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customer's first name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	// #### BACS
	// Required for Import Mandate
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer's last name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	// #### BACS
	// Required for Import Mandate
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### RBS WorldPay Atlanta
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer's middle name.
	//
	// Max Length: 60
	MiddleName string `json:"middleName,omitempty"`

	// Customer's phone number.
	//
	// It is recommended that you include the country code when the order is from outside the U.S.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Optional field.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### SEPA
	// Required for Create Mandate and Import Mandate
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada.
	// Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada.
	// Not used if swiped.
	//
	// #### RBS WorldPay Atlanta:
	// For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional field.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`

	// Title.
	//
	// Max Length: 60
	Title string `json:"title,omitempty"`
}

// Validate validates this capture payment params body order information bill to
func (o *CapturePaymentParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCounty(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistrict(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiddleName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if o.Company != nil {
		if err := o.Company.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateCounty(formats strfmt.Registry) error {
	if swag.IsZero(o.County) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"county", "body", o.County, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateDistrict(formats strfmt.Registry) error {
	if swag.IsZero(o.District) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"district", "body", o.District, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateMiddleName(formats strfmt.Registry) error {
	if swag.IsZero(o.MiddleName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"middleName", "body", o.MiddleName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateTitle(formats strfmt.Registry) error {
	if swag.IsZero(o.Title) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"title", "body", o.Title, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body order information bill to based on the context it is used
func (o *CapturePaymentParamsBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCompany(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) contextValidateCompany(ctx context.Context, formats strfmt.Registry) error {

	if o.Company != nil {

		if swag.IsZero(o.Company) { // not required
			return nil
		}

		if err := o.Company.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationBillToCompany capture payment params body order information bill to company
swagger:model CapturePaymentParamsBodyOrderInformationBillToCompany
*/
type CapturePaymentParamsBodyOrderInformationBillToCompany struct {

	// First line in the street address of the company purchasing the product.
	// Max Length: 40
	Address1 string `json:"address1,omitempty"`

	// Additional address information for the company purchasing the product.
	// Max Length: 40
	Address2 string `json:"address2,omitempty"`

	// State or province in the address of the company purchasing the product. Use the State, Province, and Territory
	// Codes for the United States and Canada.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country in the address of the company purchasing the product. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// City in the address of the company purchasing the product.
	// Max Length: 30
	Locality string `json:"locality,omitempty"`

	// Name of the customer's company.
	//
	// **CyberSource through VisaNet**
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `company_name` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Name string `json:"name,omitempty"`

	// Postal code in the address of the company purchasing the product. The postal code must consist of 5 to 9 digits.
	//
	// When the company country is the U.S., the 9-digit postal code must follow this format:
	// **[5 digits][dash][4 digits]**
	// #### Example
	// `12345-6789`
	//
	// When the company country is Canada, the 6-digit postal code must follow this format:
	// **[alpha][numeric][alpha][space][numeric][alpha][numeric]**
	// #### Example
	// `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body order information bill to company
func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"address1", "body", o.Address1, 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"address2", "body", o.Address2, 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"locality", "body", o.Locality, 30); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"name", "body", o.Name, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information bill to company based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationBillToCompany) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationBillToCompany
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationInvoiceDetails capture payment params body order information invoice details
swagger:model CapturePaymentParamsBodyOrderInformationInvoiceDetails
*/
type CapturePaymentParamsBodyOrderInformationInvoiceDetails struct {

	// International description code of the overall order's goods or services or the Categorizes purchases for VAT
	// reporting. Contact your acquirer for a list of codes.
	//
	// For processor-specific information, see the `summary_commodity_code` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 4
	CommodityCode string `json:"commodityCode,omitempty"`

	// The name of the individual or the company contacted for company authorized purchases.
	//
	// For processor-specific information, see the `authorized_contact_name` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 36
	PurchaseContactName string `json:"purchaseContactName,omitempty"`

	// Date the order was processed. `Format: YYYY-MM-DD`.
	//
	// For processor-specific information, see the `purchaser_order_date` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 10
	PurchaseOrderDate string `json:"purchaseOrderDate,omitempty"`

	// Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource
	// recommends that you do not populate the field with all zeros or nines.
	//
	// For processor-specific information, see the `user_po` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	PurchaseOrderNumber string `json:"purchaseOrderNumber,omitempty"`

	// Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.
	//
	// If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include
	// `invoiceDetails.taxable` in the data it sends to the processor.
	//
	// For processor-specific information, see the `tax_indicator` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	Taxable bool `json:"taxable,omitempty"`

	// transaction advice addendum
	TransactionAdviceAddendum []*CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 `json:"transactionAdviceAddendum"`

	// VAT invoice number associated with the transaction.
	//
	// For processor-specific information, see the `vat_invoice_ref_number` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	VatInvoiceReferenceNumber string `json:"vatInvoiceReferenceNumber,omitempty"`
}

// Validate validates this capture payment params body order information invoice details
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseContactName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionAdviceAddendum(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatInvoiceReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"commodityCode", "body", o.CommodityCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseContactName(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseContactName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseContactName", "body", o.PurchaseContactName, 36); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderDate(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderDate", "body", o.PurchaseOrderDate, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOrderNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderNumber", "body", o.PurchaseOrderNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validateTransactionAdviceAddendum(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionAdviceAddendum) { // not required
		return nil
	}

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {
		if swag.IsZero(o.TransactionAdviceAddendum[i]) { // not required
			continue
		}

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validateVatInvoiceReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatInvoiceReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"vatInvoiceReferenceNumber", "body", o.VatInvoiceReferenceNumber, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body order information invoice details based on the context it is used
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTransactionAdviceAddendum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) contextValidateTransactionAdviceAddendum(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {

		if o.TransactionAdviceAddendum[i] != nil {

			if swag.IsZero(o.TransactionAdviceAddendum[i]) { // not required
				return nil
			}

			if err := o.TransactionAdviceAddendum[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 capture payment params body order information invoice details transaction advice addendum items0
swagger:model CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
*/
type CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 struct {

	// Four Transaction Advice Addendum (TAA) fields. These fields are used to display descriptive information
	// about a transaction on the customer's American Express card statement. When you send TAA fields, start
	// with amexdata_taa1, then ...taa2, and so on. Skipping a TAA field causes subsequent TAA fields to be
	// ignored.
	//
	// To use these fields, contact CyberSource Customer Support to have your account enabled for this feature.
	//
	// Max Length: 40
	Data string `json:"data,omitempty"`
}

// Validate validates this capture payment params body order information invoice details transaction advice addendum items0
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) validateData(formats strfmt.Registry) error {
	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := validate.MaxLength("data", "body", o.Data, 40); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information invoice details transaction advice addendum items0 based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationLineItemsItems0 capture payment params body order information line items items0
swagger:model CapturePaymentParamsBodyOrderInformationLineItemsItems0
*/
type CapturePaymentParamsBodyOrderInformationLineItemsItems0 struct {

	// allowed export countries
	AllowedExportCountries []string `json:"allowedExportCountries"`

	// Flag that indicates whether the tax amount is included in the Line Item Total.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	AmountIncludesTax bool `json:"amountIncludesTax,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Discount applied to the item.
	// Max Length: 13
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Flag that indicates whether the amount is discounted.
	//
	// If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets
	// this field to **true**.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	DiscountApplied bool `json:"discountApplied,omitempty"`

	// Rate the item is discounted. Maximum of 2 decimal places.
	//
	// Example 5.25 (=5.25%)
	//
	// Max Length: 6
	DiscountRate string `json:"discountRate,omitempty"`

	// Information about the product code used for the line item.
	// Possible values:
	// - `E`: The product code is `electronic_software`.
	// - `P`: The product code is not `electronic_software`.
	//
	// For details, see the `fulfillmentType` field description in [Business Center Reporting User Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/reporting_and_reconciliation/Reporting_User/html/)
	//
	FulfillmentType string `json:"fulfillmentType,omitempty"`

	// This field is only used in DM service.
	//
	// Determines whether to assign risk to the order if the billing and shipping addresses specify different cities,
	// states, or countries. This field can contain one of the following values:
	// - true: Orders are assigned only slight additional risk if billing and shipping addresses are different.
	// - false: Orders are assigned higher additional risk if billing and shipping addresses are different.
	//
	Gift bool `json:"gift,omitempty"`

	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the
	// currency used for the gift card purchase.
	//
	// For details, see `pa_gift_card_currency` field description in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/Payer_Authentication_SCMP_API.pdf)
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	GiftCardCurrency int64 `json:"giftCardCurrency,omitempty"`

	// Field to support an invoice number for a transaction. You must specify the number of line items that will
	// include an invoice number. By default, the first line item will include an invoice number field. The invoice
	// number field can be included for up to 10 line items.
	//
	// Max Length: 23
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// passenger
	Passenger *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger `json:"passenger,omitempty"`

	// Type of product. The value for this field is used to identify the product category (electronic, handling, physical,
	// service, or shipping). The default value is `default`.
	//
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set
	// this field to a value other than `default` or one of the values related to shipping and/or handling, then
	// `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and
	// `orderInformation.lineItems[].productSku` fields are required.
	//
	// Optional field.
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don't send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you've indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields].
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// Brief description of item.
	ProductDescription string `json:"productDescription,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is
	// required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSku string `json:"productSku,omitempty"`

	// Number of units for this order. Must be a non-negative integer.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values
	// related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Maximum: 9.99999999e+08
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// Code that identifies the value of the corresponding `orderInformation.lineItems[].referenceDataNumber` field.
	//
	// Possible values:
	// - AN: Client-defined asset code
	// - MG: Manufacturer's part number
	// - PO: Purchase order number
	// - SK: Supplier stock keeping unit number
	// - UP: Universal product code
	// - VC: Supplier catalog number
	// - VP: Vendor part number
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// For details, see `reference_data_#_code` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 150
	ReferenceDataCode string `json:"referenceDataCode,omitempty"`

	// Reference number.
	//
	// The meaning of this value is identified by the value of the corresponding `referenceDataCode` field.
	// See Numbered Elements.
	//
	// The maximum length for this field depends on the value of the corresponding `referenceDataCode` field:
	// - When the code is `PO`, the maximum length for the reference number is 22.
	// - When the code is `VC`, the maximum length for the reference number is 20.
	// - For all other codes, the maximum length for the reference number is 30.
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 30
	ReferenceDataNumber string `json:"referenceDataNumber,omitempty"`

	// restricted export countries
	RestrictedExportCountries []string `json:"restrictedExportCountries"`

	// Destination to where the item will be shipped. Example: Commercial, Residential, Store
	//
	// Max Length: 50
	ShippingDestinationTypes string `json:"shippingDestinationTypes,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// Optional field.
	//
	// #### Airlines processing
	// Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s).
	// Format: English characters only.
	// Optional request field for a line item.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Note if you send this field in your tax request, the value in the field will override the tax engine
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag to indicate how you handle discount at the line item level.
	//
	//  - 0: no line level discount provided
	//  - 1: tax was calculated on the post-discount line item total
	//  - 2: tax was calculated on the pre-discount line item total
	//
	// `Note` Visa will inset 0 (zero) if an invalid value is included in this field.
	//
	// This field relates to the value in the _lineItems[].discountAmount_ field.
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// tax details
	TaxDetails []*CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 `json:"taxDetails"`

	// Tax rate applied to the item.
	//
	// For details, see `tax_rate` field description in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Flag to indicate whether tax is exempted or not included.
	//
	//  - 0: tax not included
	//  - 1: tax included
	//  - 2: transaction is not subject to tax
	//
	// Max Length: 1
	TaxStatusIndicator string `json:"taxStatusIndicator,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Flag to indicate whether the purchase is categorized as goods or services.
	// Possible values:
	//
	//  - 00: goods
	//  - 01: services
	//
	// Max Length: 2
	TypeOfSupply string `json:"typeOfSupply,omitempty"`

	// Unit of measure, or unit of measure code, for the item.
	//
	// Max Length: 12
	UnitOfMeasure string `json:"unitOfMeasure,omitempty"`

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Tax Calculation
	// Required field for U.S., Canadian, international and value added taxes.
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`

	// Per-item tax amount of the product.
	// Note The amount value must be a non-negative number containing 2 decimal places and limited to 7 digits before the decimal point.
	//
	// Max Length: 15
	UnitTaxAmount string `json:"unitTaxAmount,omitempty"`

	// Weight of the item.
	//
	// For details, see `weight_amount` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 9
	Weight string `json:"weight,omitempty"`

	// Type of weight.
	//
	// Possible values:
	// - B: Billed weight
	// - N: Actual net weight
	//
	// For details, see `weight_identifier` offer-level field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	WeightIdentifier string `json:"weightIdentifier,omitempty"`

	// Code that specifies the unit of measurement for the weight amount. For example, `OZ` specifies ounce and `LB` specifies pound. The possible values are defined by the ANSI Accredited Standards Committee (ASC).
	//
	// For details, see `weight_unit_measurement` offer-level field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 2
	WeightUnit string `json:"weightUnit,omitempty"`
}

// Validate validates this capture payment params body order information line items items0
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassenger(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSku(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDestinationTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxStatusIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTypeOfSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitOfMeasure(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeight(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("commodityCode", "body", o.CommodityCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("discountAmount", "body", o.DiscountAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountRate) { // not required
		return nil
	}

	if err := validate.MaxLength("discountRate", "body", o.DiscountRate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateInvoiceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("invoiceNumber", "body", o.InvoiceNumber, 23); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validatePassenger(formats strfmt.Registry) error {
	if swag.IsZero(o.Passenger) { // not required
		return nil
	}

	if o.Passenger != nil {
		if err := o.Passenger.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("passenger")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("passenger")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", o.ProductCode, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", o.ProductName, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateProductSku(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductSku) { // not required
		return nil
	}

	if err := validate.MaxLength("productSku", "body", o.ProductSku, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {
	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", o.Quantity, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", o.Quantity, 9.99999999e+08, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceDataCode) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataCode", "body", o.ReferenceDataCode, 150); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceDataNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataNumber", "body", o.ReferenceDataNumber, 30); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateShippingDestinationTypes(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingDestinationTypes) { // not required
		return nil
	}

	if err := validate.MaxLength("shippingDestinationTypes", "body", o.ShippingDestinationTypes, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAppliedAfterDiscount", "body", o.TaxAppliedAfterDiscount, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxRate(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRate", "body", o.TaxRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxStatusIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxStatusIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("taxStatusIndicator", "body", o.TaxStatusIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxTypeCode(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxTypeCode", "body", o.TaxTypeCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", o.TotalAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTypeOfSupply(formats strfmt.Registry) error {
	if swag.IsZero(o.TypeOfSupply) { // not required
		return nil
	}

	if err := validate.MaxLength("typeOfSupply", "body", o.TypeOfSupply, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitOfMeasure(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitOfMeasure) { // not required
		return nil
	}

	if err := validate.MaxLength("unitOfMeasure", "body", o.UnitOfMeasure, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", o.UnitPrice, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("unitTaxAmount", "body", o.UnitTaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateWeight(formats strfmt.Registry) error {
	if swag.IsZero(o.Weight) { // not required
		return nil
	}

	if err := validate.MaxLength("weight", "body", o.Weight, 9); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.WeightIdentifier) { // not required
		return nil
	}

	if err := validate.MaxLength("weightIdentifier", "body", o.WeightIdentifier, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightUnit(formats strfmt.Registry) error {
	if swag.IsZero(o.WeightUnit) { // not required
		return nil
	}

	if err := validate.MaxLength("weightUnit", "body", o.WeightUnit, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body order information line items items0 based on the context it is used
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePassenger(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) contextValidatePassenger(ctx context.Context, formats strfmt.Registry) error {

	if o.Passenger != nil {

		if swag.IsZero(o.Passenger) { // not required
			return nil
		}

		if err := o.Passenger.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("passenger")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("passenger")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {

			if swag.IsZero(o.TaxDetails[i]) { // not required
				return nil
			}

			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger Contains travel-related passenger details used by DM service only.
swagger:model CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger
*/
type CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger struct {

	// Passenger's email address, including the full domain name, such as jdoe@example.com.
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Passenger's first name.
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// ID of the passenger to whom the ticket was issued. For example, you can use this field for the frequent flyer
	// number.
	//
	// Max Length: 40
	ID string `json:"id,omitempty"`

	// Passenger's last name.
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Passenger's nationality country. Use the two character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	// Max Length: 2
	Nationality string `json:"nationality,omitempty"`

	// Passenger's phone number. If the order is from outside the U.S., CyberSource recommends that you include
	// the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 15
	Phone string `json:"phone,omitempty"`

	// Your company's passenger classification, such as with a frequent flyer program. In this case, you might use
	// values such as `standard`, `gold`, or `platinum`.
	//
	// Max Length: 32
	Status string `json:"status,omitempty"`

	// Passenger classification associated with the price of the ticket. You can use one of the following values:
	// - `ADT`: Adult
	// - `CNN`: Child
	// - `INF`: Infant
	// - `YTH`: Youth
	// - `STU`: Student
	// - `SCR`: Senior Citizen
	// - `MIL`: Military
	//
	// Max Length: 32
	Type string `json:"type,omitempty"`
}

// Validate validates this capture payment params body order information line items items0 passenger
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"id", "body", o.ID, 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateNationality(formats strfmt.Registry) error {
	if swag.IsZero(o.Nationality) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"nationality", "body", o.Nationality, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validatePhone(formats strfmt.Registry) error {
	if swag.IsZero(o.Phone) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"phone", "body", o.Phone, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.Status) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"status", "body", o.Status, 32); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"type", "body", o.Type, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information line items items0 passenger based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationLineItemsItems0Passenger
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 capture payment params body order information line items items0 tax details items0
swagger:model CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
*/
type CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// | ------------- |:-------------:|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of value added tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	// | `green`     | Green tax amount for Korean Processing. |
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	// - `green`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this capture payment params body order information line items items0 tax details items0
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information line items items0 tax details items0 based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationShipTo capture payment params body order information ship to
swagger:model CapturePaymentParamsBodyOrderInformationShipTo
*/
type CapturePaymentParamsBodyOrderInformationShipTo struct {

	// State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S.
	// or Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// U.S. county if available.
	// Max Length: 50
	County string `json:"county,omitempty"`

	// Email of the recipient.
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// Required field for authorization if any shipping address information is included in the request and
	// shipping to the U.S. or Canada; otherwise, optional.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the
	// remaining value is longer than nine characters, the value is truncated starting from the right side.
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body order information ship to
func (o *CapturePaymentParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCounty(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validateCounty(formats strfmt.Registry) error {
	if swag.IsZero(o.County) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"county", "body", o.County, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information ship to based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyOrderInformationShippingDetails capture payment params body order information shipping details
swagger:model CapturePaymentParamsBodyOrderInformationShippingDetails
*/
type CapturePaymentParamsBodyOrderInformationShippingDetails struct {

	// Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is
	// the postal code associated with your CyberSource account.
	//
	// The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code
	// must follow this format:
	//
	// `[5 digits][dash][4 digits]`
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	//
	// `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`
	//
	// Example A1B 2C3
	//
	// This field is frequently used for Level II and Level III transactions.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`
}

// Validate validates this capture payment params body order information shipping details
func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) validateShipFromPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromPostalCode", "body", o.ShipFromPostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body order information shipping details based on context it is used
func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationShippingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPaymentInformation capture payment params body payment information
swagger:model CapturePaymentParamsBodyPaymentInformation
*/
type CapturePaymentParamsBodyPaymentInformation struct {

	// card
	Card *CapturePaymentParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *CapturePaymentParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// payment type
	PaymentType *CapturePaymentParamsBodyPaymentInformationPaymentType `json:"paymentType,omitempty"`
}

// Validate validates this capture payment params body payment information
func (o *CapturePaymentParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformation) validatePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if o.PaymentType != nil {
		if err := o.PaymentType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment params body payment information based on the context it is used
func (o *CapturePaymentParamsBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {

		if swag.IsZero(o.Customer) { // not required
			return nil
		}

		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformation) contextValidatePaymentType(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentType != nil {

		if swag.IsZero(o.PaymentType) { // not required
			return nil
		}

		if err := o.PaymentType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPaymentInformationCard capture payment params body payment information card
swagger:model CapturePaymentParamsBodyPaymentInformationCard
*/
type CapturePaymentParamsBodyPaymentInformationCard struct {

	// Flag that specifies the type of account associated with the card.
	// The cardholder provides this information during the payment process.
	//
	// This field is required in the following cases:
	//   - Debit transactions on Cielo and Comercio Latino.
	//   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.
	//   - Applicable only for CyberSource through VisaNet (CtV).
	//
	// **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank
	// identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or
	// credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends
	// that you include this field for combo card transactions.
	//
	// Possible values include the following.
	//
	//  - `CH`: Checking account
	//  - `CR`: Credit card account
	//  - `SA`: Saving account
	//  - `LI`: Line of credit or credit portion of combo card
	//  - `PP`: Prepaid card account or prepaid portion of combo card
	//  - `UA`: Universal account
	//
	// If useAs is set to credit/debit and there is a value in SourceAccountType, the value in the SourceAccountType field will take precedence.
	// If useAs is set to CR/DB and there is a value in SourceAccountType, the value in the useAs field will take precedence.
	//
	// Max Length: 20
	SourceAccountType string `json:"sourceAccountType,omitempty"`

	// Type of account that is being used when the value for the override_payment_method field is line of credit (LI) or prepaid card (PP).
	// Possible values for line of credit:
	// - `AGRC`: Visa Agro Custeio
	// - `AGRE`: Visa Agro Electron
	// - `AGRI`: Visa Agro Investimento
	// - `AGRO`: Visa Agro
	// Possible values for prepaid card:
	// - `VVA`: Visa Vale Alimentacao
	// - `VVF`: Visa Vale Flex
	// - `VVR`: Visa Vale Refeicao
	// This field is supported only for combo card transactions in Brazil on CyberSource through VisaNet.
	//
	// Max Length: 4
	SourceAccountTypeDetails string `json:"sourceAccountTypeDetails,omitempty"`
}

// Validate validates this capture payment params body payment information card
func (o *CapturePaymentParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSourceAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSourceAccountTypeDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformationCard) validateSourceAccountType(formats strfmt.Registry) error {
	if swag.IsZero(o.SourceAccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"sourceAccountType", "body", o.SourceAccountType, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformationCard) validateSourceAccountTypeDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.SourceAccountTypeDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"sourceAccountTypeDetails", "body", o.SourceAccountTypeDetails, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body payment information card based on context it is used
func (o *CapturePaymentParamsBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPaymentInformationCustomer capture payment params body payment information customer
swagger:model CapturePaymentParamsBodyPaymentInformationCustomer
*/
type CapturePaymentParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumer's card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	CustomerID string `json:"customerId,omitempty"`

	// Unique identifier for the Customer token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this capture payment params body payment information customer
func (o *CapturePaymentParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformationCustomer) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("capturePaymentRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body payment information customer based on context it is used
func (o *CapturePaymentParamsBodyPaymentInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPaymentInformationPaymentType capture payment params body payment information payment type
swagger:model CapturePaymentParamsBodyPaymentInformationPaymentType
*/
type CapturePaymentParamsBodyPaymentInformationPaymentType struct {

	// method
	Method *CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod `json:"method,omitempty"`
}

// Validate validates this capture payment params body payment information payment type
func (o *CapturePaymentParamsBodyPaymentInformationPaymentType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformationPaymentType) validateMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.Method) { // not required
		return nil
	}

	if o.Method != nil {
		if err := o.Method.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment params body payment information payment type based on the context it is used
func (o *CapturePaymentParamsBodyPaymentInformationPaymentType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMethod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformationPaymentType) contextValidateMethod(ctx context.Context, formats strfmt.Registry) error {

	if o.Method != nil {

		if swag.IsZero(o.Method) { // not required
			return nil
		}

		if err := o.Method.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationPaymentType) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationPaymentType) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPaymentInformationPaymentType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod capture payment params body payment information payment type method
swagger:model CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod
*/
type CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod struct {

	// A Payment Type is enabled through a Method. Examples: Visa, Master Card, ApplePay, iDeal, 7Eleven, alfamart, etc
	//
	// For Japan Payment Processing Valid Values:
	// - 1 Banking Data
	// - 2 Authorization Data
	//
	// #### Via KCP
	// - `KCP` : Local Card, Bank Transfer and Carrier Billing.
	// - `PAYCO`
	// - `KAKAOPAY`
	// - `NAVERPAY`
	//
	Name string `json:"name,omitempty"`
}

// Validate validates this capture payment params body payment information payment type method
func (o *CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this capture payment params body payment information payment type method based on context it is used
func (o *CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPaymentInformationPaymentTypeMethod
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPointOfSaleInformation capture payment params body point of sale information
swagger:model CapturePaymentParamsBodyPointOfSaleInformation
*/
type CapturePaymentParamsBodyPointOfSaleInformation struct {

	// Point-of-sale details for the transaction. This value is returned only for **American Express Direct**.
	// CyberSource generates this value, which consists of a series of codes that identify terminal capability,
	// security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN
	// requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on
	// credits.
	//
	// When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from
	// the authorization service to the subsequent services for you. However, when you perform authorizations through
	// CyberSource and perform subsequent services through other financial institutions, you must ensure that your
	// requests for captures and credits include this value.
	//
	// For details, see `auth_pos_data` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	AmexCapnData string `json:"amexCapnData,omitempty"`

	// emv
	Emv *CapturePaymentParamsBodyPointOfSaleInformationEmv `json:"emv,omitempty"`
}

// Validate validates this capture payment params body point of sale information
func (o *CapturePaymentParamsBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexCapnData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPointOfSaleInformation) validateAmexCapnData(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexCapnData) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"pointOfSaleInformation"+"."+"amexCapnData", "body", o.AmexCapnData, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {
	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment params body point of sale information based on the context it is used
func (o *CapturePaymentParamsBodyPointOfSaleInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmv(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPointOfSaleInformation) contextValidateEmv(ctx context.Context, formats strfmt.Registry) error {

	if o.Emv != nil {

		if swag.IsZero(o.Emv) { // not required
			return nil
		}

		if err := o.Emv.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPointOfSaleInformationEmv capture payment params body point of sale information emv
swagger:model CapturePaymentParamsBodyPointOfSaleInformationEmv
*/
type CapturePaymentParamsBodyPointOfSaleInformationEmv struct {

	// Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a
	// technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:
	//
	//  1. Swipe the card or key the credit card information into the POS terminal.
	//  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.
	//
	//
	// Possible values:
	// - `true`: Fallback method was used.
	// - `false` (default): Fallback method was not used.
	//
	// This field is supported only on American Express Direct, Chase Paymentech Solutions, CyberSource through VisaNet,
	// FDC Nashville Global, GPN, JCN Gateway, OmniPay Direct, and SIX.
	//
	Fallback bool `json:"fallback,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For information about the individual tags, see the "Application Specification" section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.
	// All other card present information applies only to credit card processing. PIN debit processing is available only
	// on FDC Nashville Global.
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - `56`: Track 1 equivalent data
	//  - `57`: Track 2 equivalent data
	//  - `5A`: Application PAN
	//  - `5F20`: Cardholder name
	//  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)
	//  - `99`: Transaction PIN
	//  - `9F0B`: Cardholder name (extended)
	//  - `9F1F`: Track 1 discretionary data
	//  - `9F20`: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - `95`: Terminal verification results
	//  - `9F10`: Issuer application data
	//  - `9F26`: Application cryptogram
	//
	//
	// #### CyberSource through VisaNet
	// - In Japan: 199 bytes
	// - In other countries: String (252)
	//
	// For Mastercard Transactions, Optionally Tag 9F60 (Authenticated Application Data) and
	// Tag 96 (Kernel Identifier - Terminal) can be included in the Field.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// #### JCN Gateway
	// The following tags must be included:
	// - `4F`: Application identifier
	// - `84`: Dedicated file name
	//
	// Data length: 199 bytes
	//
	// #### All other processors:
	// String (999)
	//
	// #### Used by
	// Authorization: Optional
	// Authorization Reversal: Optional
	// Credit: Optional
	// PIN Debit processing (purchase, credit and reversal): Optional
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this capture payment params body point of sale information emv
func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", o.Tags, 1998); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body point of sale information emv based on context it is used
func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyProcessingInformation capture payment params body processing information
swagger:model CapturePaymentParamsBodyProcessingInformation
*/
type CapturePaymentParamsBodyProcessingInformation struct {

	// Array of actions (one or more) to be included in the capture to invoke bundled services along with capture.
	//
	// Possible values :
	//
	//  - `AP_CAPTURE`: Use this when Alternative Payment Capture service is requested.
	//
	ActionList []string `json:"actionList"`

	// authorization options
	AuthorizationOptions *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`

	// capture options
	CaptureOptions *CapturePaymentParamsBodyProcessingInformationCaptureOptions `json:"captureOptions,omitempty"`

	// Indicates that the transaction includes industry-specific data.
	//
	// Possible Values:
	// - `airline`
	// - `restaurant`
	// - `lodging`
	// - `auto_rental`
	// - `transit`
	// - `healthcare_medical`
	// - `healthcare_transit`
	// - `transit`
	//
	// #### Card Present, Airlines and Auto Rental
	// You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this
	// field is not set to `airline` or is not included in the request, no airline data is sent to the processor.
	//
	// You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field
	// is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.
	//
	// You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this
	// field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.
	//
	// Restaurant data is supported only on CyberSource through VisaNet.
	//
	// Max Length: 20
	IndustryDataType string `json:"industryDataType,omitempty"`

	// issuer
	Issuer *CapturePaymentParamsBodyProcessingInformationIssuer `json:"issuer,omitempty"`

	// Value that links the current authorization request to the original authorization request. Set this value
	// to the ID that was returned in the reply message from the original authorization request.
	//
	// This value is used for:
	//
	// - Partial authorizations
	// - Split shipments
	//
	// For details, see `link_to_request` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 26
	LinkID string `json:"linkId,omitempty"`

	// loan options
	LoanOptions *CapturePaymentParamsBodyProcessingInformationLoanOptions `json:"loanOptions,omitempty"`

	// Flag that indicates if the transaction is pay by points transaction
	// true: Transaction uses loyalty points
	// false: Transaction does not use loyalty points
	// Default: false
	//
	PayByPointsIndicator bool `json:"payByPointsIndicator,omitempty"`

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//  - `013`: Cybersource P2PE Decryption
	//  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `027`: Click to Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Set this field to 3 to indicate that the request includes Level III data.
	// Max Length: 1
	PurchaseLevel string `json:"purchaseLevel,omitempty"`

	// Please check with Cybersource customer support to see if your merchant account is configured correctly so you
	// can include this field in your request.
	// * For Payouts: max length for FDCCompass is String (22).
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**.
	//
	// For details, see `report_group` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 25
	ReportGroup string `json:"reportGroup,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`
}

// Validate validates this capture payment params body processing information
func (o *CapturePaymentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCaptureOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIndustryDataType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinkID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLoanOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReportGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateCaptureOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.CaptureOptions) { // not required
		return nil
	}

	if o.CaptureOptions != nil {
		if err := o.CaptureOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateIndustryDataType(formats strfmt.Registry) error {
	if swag.IsZero(o.IndustryDataType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"industryDataType", "body", o.IndustryDataType, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateLinkID(formats strfmt.Registry) error {
	if swag.IsZero(o.LinkID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"linkId", "body", o.LinkID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateLoanOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.LoanOptions) { // not required
		return nil
	}

	if o.LoanOptions != nil {
		if err := o.LoanOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", o.PaymentSolution, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validatePurchaseLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"purchaseLevel", "body", o.PurchaseLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateReportGroup(formats strfmt.Registry) error {
	if swag.IsZero(o.ReportGroup) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"reportGroup", "body", o.ReportGroup, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {
	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", o.VisaCheckoutID, 48); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body processing information based on the context it is used
func (o *CapturePaymentParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCaptureOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLoanOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {

		if swag.IsZero(o.AuthorizationOptions) { // not required
			return nil
		}

		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) contextValidateCaptureOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.CaptureOptions != nil {

		if swag.IsZero(o.CaptureOptions) { // not required
			return nil
		}

		if err := o.CaptureOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {

		if swag.IsZero(o.Issuer) { // not required
			return nil
		}

		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) contextValidateLoanOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.LoanOptions != nil {

		if swag.IsZero(o.LoanOptions) { // not required
			return nil
		}

		if err := o.LoanOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyProcessingInformationAuthorizationOptions capture payment params body processing information authorization options
swagger:model CapturePaymentParamsBodyProcessingInformationAuthorizationOptions
*/
type CapturePaymentParamsBodyProcessingInformationAuthorizationOptions struct {

	// Authorization type. Possible values:
	//
	//  - `AUTOCAPTURE`: automatic capture.
	//  - `STANDARDCAPTURE`: standard capture.
	//  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.
	//
	// #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing
	// Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture. For more information, see the `auth_type` field description in [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Forced Capture
	// Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.
	//
	// #### Verbal Authorization
	// Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization. For more information, see "Verbal Authorizations" in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// Max Length: 15
	AuthType string `json:"authType,omitempty"`

	// Authorization code.
	//
	// #### Forced Capture
	// Use this field to send the authorization code you received from a payment that you authorized
	// outside the CyberSource system.
	//
	// #### PIN debit
	// Authorization code that is returned by the processor.
	//
	// Returned by PIN debit purchase.
	//
	// #### Verbal Authorization
	// Use this field in CAPTURE API to send the verbally received authorization code.
	//
	// For processor-specific information, see the `auth_code` field description in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// Max Length: 7
	VerbalAuthCode string `json:"verbalAuthCode,omitempty"`

	// Transaction ID (TID).
	//
	// #### FDMS South
	// This field is required for verbal authorizations and forced captures with the American Express card type to comply
	// with the CAPN requirements:
	// - Forced capture: Obtain the value for this field from the authorization response.
	// - Verbal authorization: You cannot obtain a value for this field so CyberSource uses the default value of `000000000000000` (15
	// zeros).
	//
	// Max Length: 15
	VerbalAuthTransactionID string `json:"verbalAuthTransactionId,omitempty"`
}

// Validate validates this capture payment params body processing information authorization options
func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) validateAuthType(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"authType", "body", o.AuthType, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthCode(formats strfmt.Registry) error {
	if swag.IsZero(o.VerbalAuthCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthCode", "body", o.VerbalAuthCode, 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.VerbalAuthTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthTransactionId", "body", o.VerbalAuthTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body processing information authorization options based on context it is used
func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyProcessingInformationCaptureOptions capture payment params body processing information capture options
swagger:model CapturePaymentParamsBodyProcessingInformationCaptureOptions
*/
type CapturePaymentParamsBodyProcessingInformationCaptureOptions struct {

	// Capture number when requesting multiple partial captures for one authorization.
	// Used along with `totalCaptureCount` to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber_ = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	CaptureSequenceNumber int64 `json:"captureSequenceNumber,omitempty"`

	// Indicates whether to release the authorization hold on the remaining funds.
	// Possible Values:
	// - `true`
	// - `false`
	//
	// Max Length: 5
	IsFinal string `json:"isFinal,omitempty"`

	// Total number of captures when requesting multiple partial captures for one payment.
	// Used along with `captureSequenceNumber` field to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	TotalCaptureCount int64 `json:"totalCaptureCount,omitempty"`
}

// Validate validates this capture payment params body processing information capture options
func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCaptureSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIsFinal(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCaptureCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) validateCaptureSequenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CaptureSequenceNumber) { // not required
		return nil
	}

	if err := validate.MinimumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", o.CaptureSequenceNumber, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", o.CaptureSequenceNumber, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) validateIsFinal(formats strfmt.Registry) error {
	if swag.IsZero(o.IsFinal) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"isFinal", "body", o.IsFinal, 5); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) validateTotalCaptureCount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalCaptureCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", o.TotalCaptureCount, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", o.TotalCaptureCount, 99, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body processing information capture options based on context it is used
func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformationCaptureOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyProcessingInformationIssuer capture payment params body processing information issuer
swagger:model CapturePaymentParamsBodyProcessingInformationIssuer
*/
type CapturePaymentParamsBodyProcessingInformationIssuer struct {

	// Data defined by the issuer.
	//
	// The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.
	//
	// This field is supported only for Visa transactions on **CyberSource through VisaNet**.
	//
	// For details, see `issuer_additional_data` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 255
	DiscretionaryData string `json:"discretionaryData,omitempty"`
}

// Validate validates this capture payment params body processing information issuer
func (o *CapturePaymentParamsBodyProcessingInformationIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDiscretionaryData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationIssuer) validateDiscretionaryData(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscretionaryData) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"issuer"+"."+"discretionaryData", "body", o.DiscretionaryData, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body processing information issuer based on context it is used
func (o *CapturePaymentParamsBodyProcessingInformationIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationIssuer) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformationIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyProcessingInformationLoanOptions capture payment params body processing information loan options
swagger:model CapturePaymentParamsBodyProcessingInformationLoanOptions
*/
type CapturePaymentParamsBodyProcessingInformationLoanOptions struct {

	// Indicates whether a loan is for a recoverable item or a non-recoverable item.
	// Possible values:
	// - `N`: non-recoverable item
	// - `R`: recoverable item
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	//  Record: CP07 TCR2, Position: 26, Field: Asset Indicator
	//
	// Max Length: 1
	AssetType string `json:"assetType,omitempty"`

	// Type of loan based on an agreement between you and the issuer.
	// Examples: AGROCUSTEIO, AGRO-INVEST, BNDES-Type1, CBN, FINAME.
	// This field is supported only for these kinds of payments:
	// - BNDES transactions on CyberSource through VisaNet.
	// - Installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// See ""Installment Payments on CyberSource through VisaNet,"" in the SCMP/SO guide
	//
	// For BNDES transactions, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP07 TCR2, Position: 27-46, Field: Loan Type
	//
	// For installment payments with Mastercard in Brazil, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP07 TCR4, Position: 5-24,Field: Financing Type
	//
	// Max Length: 20
	Type string `json:"type,omitempty"`
}

// Validate validates this capture payment params body processing information loan options
func (o *CapturePaymentParamsBodyProcessingInformationLoanOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssetType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationLoanOptions) validateAssetType(formats strfmt.Registry) error {
	if swag.IsZero(o.AssetType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"loanOptions"+"."+"assetType", "body", o.AssetType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationLoanOptions) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"loanOptions"+"."+"type", "body", o.Type, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body processing information loan options based on context it is used
func (o *CapturePaymentParamsBodyProcessingInformationLoanOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationLoanOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationLoanOptions) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformationLoanOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyPromotionInformation capture payment params body promotion information
swagger:model CapturePaymentParamsBodyPromotionInformation
*/
type CapturePaymentParamsBodyPromotionInformation struct {

	// Additional rental agency marketed coupons for consumers to discount the rate of the vehicle rental agreement.
	//
	// Max Length: 12
	AdditionalCode string `json:"additionalCode,omitempty"`

	// Code for a promotion or discount.
	//
	// Max Length: 12
	Code string `json:"code,omitempty"`
}

// Validate validates this capture payment params body promotion information
func (o *CapturePaymentParamsBodyPromotionInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPromotionInformation) validateAdditionalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"promotionInformation"+"."+"additionalCode", "body", o.AdditionalCode, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyPromotionInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"promotionInformation"+"."+"code", "body", o.Code, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body promotion information based on context it is used
func (o *CapturePaymentParamsBodyPromotionInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPromotionInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPromotionInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPromotionInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformation capture payment params body travel information
swagger:model CapturePaymentParamsBodyTravelInformation
*/
type CapturePaymentParamsBodyTravelInformation struct {

	// agency
	Agency *CapturePaymentParamsBodyTravelInformationAgency `json:"agency,omitempty"`

	// auto rental
	AutoRental *CapturePaymentParamsBodyTravelInformationAutoRental `json:"autoRental,omitempty"`

	// Duration of the auto rental or lodging rental.
	//
	// #### Auto rental
	// This field is supported for Visa, MasterCard, and American Express.
	// **Important** If this field is not included when the `processingInformation.industryDataType` is auto rental,
	// the transaction is declined.
	//
	// Max Length: 2
	Duration string `json:"duration,omitempty"`

	// lodging
	Lodging *CapturePaymentParamsBodyTravelInformationLodging `json:"lodging,omitempty"`

	// transit
	Transit *CapturePaymentParamsBodyTravelInformationTransit `json:"transit,omitempty"`

	// vehicle data
	VehicleData *CapturePaymentParamsBodyTravelInformationVehicleData `json:"vehicleData,omitempty"`
}

// Validate validates this capture payment params body travel information
func (o *CapturePaymentParamsBodyTravelInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAgency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAutoRental(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLodging(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) validateAgency(formats strfmt.Registry) error {
	if swag.IsZero(o.Agency) { // not required
		return nil
	}

	if o.Agency != nil {
		if err := o.Agency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "agency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "agency")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) validateAutoRental(formats strfmt.Registry) error {
	if swag.IsZero(o.AutoRental) { // not required
		return nil
	}

	if o.AutoRental != nil {
		if err := o.AutoRental.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(o.Duration) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"duration", "body", o.Duration, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) validateLodging(formats strfmt.Registry) error {
	if swag.IsZero(o.Lodging) { // not required
		return nil
	}

	if o.Lodging != nil {
		if err := o.Lodging.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) validateTransit(formats strfmt.Registry) error {
	if swag.IsZero(o.Transit) { // not required
		return nil
	}

	if o.Transit != nil {
		if err := o.Transit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) validateVehicleData(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleData) { // not required
		return nil
	}

	if o.VehicleData != nil {
		if err := o.VehicleData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "vehicleData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "vehicleData")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment params body travel information based on the context it is used
func (o *CapturePaymentParamsBodyTravelInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAgency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAutoRental(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLodging(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTransit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateVehicleData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) contextValidateAgency(ctx context.Context, formats strfmt.Registry) error {

	if o.Agency != nil {

		if swag.IsZero(o.Agency) { // not required
			return nil
		}

		if err := o.Agency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "agency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "agency")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) contextValidateAutoRental(ctx context.Context, formats strfmt.Registry) error {

	if o.AutoRental != nil {

		if swag.IsZero(o.AutoRental) { // not required
			return nil
		}

		if err := o.AutoRental.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) contextValidateLodging(ctx context.Context, formats strfmt.Registry) error {

	if o.Lodging != nil {

		if swag.IsZero(o.Lodging) { // not required
			return nil
		}

		if err := o.Lodging.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) contextValidateTransit(ctx context.Context, formats strfmt.Registry) error {

	if o.Transit != nil {

		if swag.IsZero(o.Transit) { // not required
			return nil
		}

		if err := o.Transit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformation) contextValidateVehicleData(ctx context.Context, formats strfmt.Registry) error {

	if o.VehicleData != nil {

		if swag.IsZero(o.VehicleData) { // not required
			return nil
		}

		if err := o.VehicleData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "vehicleData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "vehicleData")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationAgency capture payment params body travel information agency
swagger:model CapturePaymentParamsBodyTravelInformationAgency
*/
type CapturePaymentParamsBodyTravelInformationAgency struct {

	// International Air Transport Association (IATA) code of travel agency that made the vehicle rental reservation.
	//
	// Max Length: 8
	Code string `json:"code,omitempty"`

	// Name of travel agency that made the reservation.
	//
	// Max Length: 25
	Name string `json:"name,omitempty"`
}

// Validate validates this capture payment params body travel information agency
func (o *CapturePaymentParamsBodyTravelInformationAgency) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAgency) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"agency"+"."+"code", "body", o.Code, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAgency) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"agency"+"."+"name", "body", o.Name, 25); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information agency based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationAgency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAgency) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAgency) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationAgency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationAutoRental capture payment params body travel information auto rental
swagger:model CapturePaymentParamsBodyTravelInformationAutoRental
*/
type CapturePaymentParamsBodyTravelInformationAutoRental struct {

	// Adjusted Amount indicates whether any miscellaneous charges were incurred after the vehicle was returned.
	//
	// For authorizations, this field is supported only for American Express.
	//
	// For captures, this field is supported only for MasterCard and American Express.
	// **NOTE** For American Express, this field is required if the `travelInformation.autoRental.adjustedAmountIndicator` field
	// is included in the request and has a value; otherwise, this field is optional.
	//
	// For all other card types, this field is ignored.
	//
	// Max Length: 12
	AdjustedAmount string `json:"adjustedAmount,omitempty"`

	// For **MasterCard** and **Discover**:
	// Adjusted amount indicator code that indicates
	// any miscellaneous charges incurred after the
	// auto was returned. Possible values:
	// - `A` - Drop-off charges
	// - `B` - Delivery charges
	// - `C` - Parking expenses
	// - `D` - Extra hours
	// - `E` - Violations
	// - `X` - More than one of the above charges
	//
	// For **American Express**:
	// Audit indicator code that indicates any
	// adjustment for mileage, fuel, auto damage,
	// etc. made to a rental agreement and whether
	// the cardholder was notified.
	//
	// Possible value for the authorization service:
	// - `A` (default): adjustment amount greater than 0 (zero)
	//
	// Possible values for the capture service:
	// - `X` - Multiple adjustments
	// - `Y` - One adjustment only; Cardmember notified
	// - `Z` - One adjustment only; Cardmember not notified. This value is used as the default if the request does not include this field and includes an adjustment amount greater than 0 (zero).
	// This is an optional field.
	//
	// Max Length: 1
	AdjustedAmountIndicator string `json:"adjustedAmountIndicator,omitempty"`

	// When merchant wants to send the affiliate name.
	//
	// Max Length: 50
	AffiliateName string `json:"affiliateName,omitempty"`

	// Auto rental agency's agreement (invoice) number provided to the customer. It is used to trace any inquiries about transactions.
	// This field is supported for Visa, MasterCard, and American Express.
	// This Merchant-defined value, which may be composed of any combination of characters and/or numerals, may become
	// part of the descriptive bill on the Cardmember's statement.
	//
	// Max Length: 25
	AgreementNumber string `json:"agreementNumber,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Corporate Identifier provides the unique identifier of the corporation or entity renting the vehicle:
	//
	// |Card Specific Validation|VISA|MasterCard|Discover|AMEX|
	// |--- |--- |--- |--- |
	// | Filed Length| NA| 12| NA| NA|
	// | Field Type| NA| AN| NA| NA|
	// | M/O/C| NA| O| NA| NA|
	//
	// Max Length: 12
	CompanyID string `json:"companyId,omitempty"`

	// Merchant to send their auto rental company name
	//
	// Max Length: 50
	CompanyName string `json:"companyName,omitempty"`

	// Name of the individual making the rental agreement.
	//
	// Valid data lengths by card:
	//
	// |Card Specific Validation|VISA|MasterCard|Discover|AMEX|
	// |--- |--- |--- |--- |
	// | Filed Length| 40| 40| 29| 26|
	// | Field Type| AN| ANS| AN| AN|
	// | M/O/C| O| M| M| M|
	//
	// Max Length: 40
	CustomerName string `json:"customerName,omitempty"`

	// Customer service telephone number that is used to resolve questions or disputes. Include the area code, exchange, and number.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 17
	CustomerServicePhoneNumber string `json:"customerServicePhoneNumber,omitempty"`

	// Daily auto rental rate charged.
	// This field is supported only for MasterCard and American Express.
	//
	// Field - Time Period needs to be populated with Daily if this field is present
	//
	// Max Length: 12
	DailyRentalRate string `json:"dailyRentalRate,omitempty"`

	// Total number of miles driven by the customer.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 5
	DistanceTravelled string `json:"distanceTravelled,omitempty"`

	// Miles/Kilometers Indicator shows whether the "miles" fields are expressed in miles or kilometers.
	//
	// Allowed values:
	// - `K` - Kilometers
	// - `M` - Miles
	//
	// Max Length: 1
	DistanceUnit string `json:"distanceUnit,omitempty"`

	// Age of the driver renting the vehicle.
	//
	// Max Length: 3
	DriverAge string `json:"driverAge,omitempty"`

	// (Extra Charges) provides the extra charges associated with the vehicle rental.
	//
	// Max Length: 12
	ExtraCharge string `json:"extraCharge,omitempty"`

	// Extra mileage charges that extend beyond the basic rental agreement.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	ExtraMileageCharge string `json:"extraMileageCharge,omitempty"`

	// Extra gasoline charges that extend beyond the basic rental agreement.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	FuelCharges string `json:"fuelCharges,omitempty"`

	// Amount charged for renting a Global Positioning Service (GPS).
	//
	// Max Length: 12
	GpsCharge string `json:"gpsCharge,omitempty"`

	// Insurance charges.
	// Field is conditional and can include decimal point.
	//
	// Max Length: 12
	InsuranceAmount string `json:"insuranceAmount,omitempty"`

	// Used for MC and Discover
	//
	// Valid values:
	// - `true` - Yes (insurance was purchased)
	// - `false` - No (insurance was not purchased)
	//
	InsuranceIndicator bool `json:"insuranceIndicator,omitempty"`

	// Extra charges related to a late return of the rented auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	LateFeeAmount string `json:"lateFeeAmount,omitempty"`

	// Maximum number of free miles or kilometers allowed to a customer for the duration of the auto rental agreement.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 4
	MaxFreeDistance string `json:"maxFreeDistance,omitempty"`

	// Regular Mileage Charge provides the amount charged for regular miles traveled during vehicle rental. Two decimal places
	//
	// Max Length: 12
	MileageCharge string `json:"mileageCharge,omitempty"`

	// No Show Indicator provides an indicator noting that the individual did not show up after making a reservation for a vehicle.
	// Possible values:
	// - true
	// - false
	//
	NoShowIndicator bool `json:"noShowIndicator,omitempty"`

	// The number of additional drivers included on the rental agreement not including the individual who signed the rental agreement.
	//
	// Max Length: 1
	NumberOfAdditionalDrivers string `json:"numberOfAdditionalDrivers,omitempty"`

	// Odometer reading at time of vehicle rental.
	//
	// Max Length: 8
	OdometerReading string `json:"odometerReading,omitempty"`

	// Extra charges incurred for a one-way rental agreement for the auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	OneWayDropOffAmount string `json:"oneWayDropOffAmount,omitempty"`

	// Total amount charged for all other miscellaneous charges not previously defined.
	//
	// Max Length: 12
	OtherCharges string `json:"otherCharges,omitempty"`

	// Extra charges incurred due to a parking violation for the auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	ParkingViolationCharge string `json:"parkingViolationCharge,omitempty"`

	// Additional charges incurred for phone usage included on the total bill.
	//
	// Max Length: 12
	PhoneCharge string `json:"phoneCharge,omitempty"`

	// Used to identify special circumstances applicable to the Card Transaction or Cardholder, such as "renter" or "show".
	//
	// This code is `2 digit` value agreed by Merchant and processor.
	//
	// Max Length: 2
	ProgramCode string `json:"programCode,omitempty"`

	// Rate charged for each mile.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 12
	RatePerMile string `json:"ratePerMile,omitempty"`

	// rental address
	RentalAddress *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress `json:"rentalAddress,omitempty"`

	// Date/time the auto was picked up from the rental agency.
	// Format: `yyyy-MM-dd HH-mm-ss z`
	// This field is supported for Visa, MasterCard, and American Express.
	//
	// Max Length: 21
	RentalDateTime string `json:"rentalDateTime,omitempty"`

	// return address
	ReturnAddress *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress `json:"returnAddress,omitempty"`

	// Date/time the auto was returned to the rental agency.
	// Format: ``yyyy-MM-dd HH-mm-ss z``
	// This field is supported for Visa, MasterCard, and American Express.
	//
	// Max Length: 21
	ReturnDateTime string `json:"returnDateTime,omitempty"`

	// Program code used to identify special circumstances, such as "frequent renter" or "no show" status for the renter.
	// Possible values:
	// - `0`: not applicable (default)
	// - `1`: frequent renter
	// - `2`: no show
	//
	// For authorizations, this field is supported only for Visa.
	//
	// For captures, this field is supported for Visa, MasterCard, and American Express.
	//
	// Code for special programs applicable to the Card Transaction or the Cardholder.
	//
	// Max Length: 2
	SpecialProgramCode string `json:"specialProgramCode,omitempty"`

	// tax details
	TaxDetails *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails `json:"taxDetails,omitempty"`

	// Indicates the time period for which the vehicle rental rate applies (e.g., daily, weekly or monthly). Daily, Weekly and Monthly are valid values.
	//
	// Max Length: 7
	TimePeriod string `json:"timePeriod,omitempty"`

	// (Towing Charges) provides the amount charged to tow the rental vehicle.
	//
	// Max Length: 4
	TowingCharge string `json:"towingCharge,omitempty"`

	// Classification of the rented auto.
	//
	// **NOTE** For VISA, this is a 2-byte optional code.
	//
	// Valid values for American Express & MasterCard:
	//
	// |American Express |MasterCard |Description|
	// |--- |--- |--- |
	// | 0001| 0001| Mini|
	// | 0002| 0002| Subcompact|
	// | 0003| 0003| Economy|
	// | 0004| 0004| Compact|
	// | 0005| 0005| Midsize|
	// | 0006| 0006| Intermediate|
	// | 0007| 0007| Standard|
	// | 0008| 0008| Fulll size|
	// | 0009| 0009| Luxury|
	// | 0010| 0010| Premium|
	// | 0011| 0011| Minivan|
	// | 0012| 0012| 12-passenger van|
	// | 0013| 0013| Moving van|
	// | 0014| 0014| 15-passenger van|
	// | 0015| 0015| Cargo van|
	// | 0016| 0016| 12-foot truck|
	// | 0017| 0017| 20-foot truck|
	// | 0018| 0018| 24-foot truck|
	// | 0019| 0019| 26-foot truck|
	// | 0020| 0020| Moped|
	// | 0021| 0021| Stretch|
	// | 0022| 0022| Regular|
	// | 0023| 0023| Unique|
	// | 0024| 0024| Exotic|
	// | 0025| 0025| Small/medium truck|
	// | 0026| 0026| Large truck|
	// | 0027| 0027| Small SUV|
	// | 0028| 0028| Medium SUV|
	// | 0029| 0029| Large SUV|
	// | 0030| 0030| Exotic SUV|
	// | 9999| 9999| Miscellaneous|
	//
	// Additional Values allowed **only** for `American Express`:
	//
	// |American Express|MasterCard|Description|
	// |--- |--- |--- |
	// | 0031| NA| Four Wheel Drive|
	// | 0032| NA| Special|
	// | 0099| NA| Taxi|
	//
	// Max Length: 4
	VehicleClass string `json:"vehicleClass,omitempty"`

	// This field contains a unique identifier assigned by the company to the vehicle.
	//
	// Max Length: 20
	VehicleIdentificationNumber string `json:"vehicleIdentificationNumber,omitempty"`

	// Make of the vehicle being rented (e.g., Chevrolet or Ford).
	//
	// Max Length: 10
	VehicleMake string `json:"vehicleMake,omitempty"`

	// Model of the vehicle being rented (e.g., Cavalier or Focus).
	//
	// Max Length: 10
	VehicleModel string `json:"vehicleModel,omitempty"`

	// Weekly Rental Amount provides the amount charged for a seven-day rental period. Field - Time Period needs to be populated with Weekly if this field is present
	//
	// Max Length: 12
	WeeklyRentalRate string `json:"weeklyRentalRate,omitempty"`
}

// Validate validates this capture payment params body travel information auto rental
func (o *CapturePaymentParamsBodyTravelInformationAutoRental) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdjustedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdjustedAmountIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAffiliateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAgreementNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompanyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompanyName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerServicePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDailyRentalRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistanceTravelled(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistanceUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDriverAge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtraCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtraMileageCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFuelCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGpsCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsuranceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLateFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMaxFreeDistance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMileageCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfAdditionalDrivers(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOdometerReading(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOneWayDropOffAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOtherCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateParkingViolationCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRatePerMile(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRentalAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRentalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReturnAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReturnDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpecialProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimePeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTowingCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleClass(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleIdentificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleMake(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleModel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeeklyRentalRate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateAdjustedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"adjustedAmount", "body", o.AdjustedAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateAdjustedAmountIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustedAmountIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"adjustedAmountIndicator", "body", o.AdjustedAmountIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateAffiliateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AffiliateName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"affiliateName", "body", o.AffiliateName, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateAgreementNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.AgreementNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"agreementNumber", "body", o.AgreementNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"commodityCode", "body", o.CommodityCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateCompanyID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"companyId", "body", o.CompanyID, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateCompanyName(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"companyName", "body", o.CompanyName, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateCustomerName(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"customerName", "body", o.CustomerName, 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateCustomerServicePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerServicePhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"customerServicePhoneNumber", "body", o.CustomerServicePhoneNumber, 17); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateDailyRentalRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DailyRentalRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"dailyRentalRate", "body", o.DailyRentalRate, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateDistanceTravelled(formats strfmt.Registry) error {
	if swag.IsZero(o.DistanceTravelled) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"distanceTravelled", "body", o.DistanceTravelled, 5); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateDistanceUnit(formats strfmt.Registry) error {
	if swag.IsZero(o.DistanceUnit) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"distanceUnit", "body", o.DistanceUnit, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateDriverAge(formats strfmt.Registry) error {
	if swag.IsZero(o.DriverAge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"driverAge", "body", o.DriverAge, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateExtraCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtraCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"extraCharge", "body", o.ExtraCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateExtraMileageCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtraMileageCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"extraMileageCharge", "body", o.ExtraMileageCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateFuelCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.FuelCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"fuelCharges", "body", o.FuelCharges, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateGpsCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.GpsCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"gpsCharge", "body", o.GpsCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateInsuranceAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.InsuranceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"insuranceAmount", "body", o.InsuranceAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateLateFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.LateFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"lateFeeAmount", "body", o.LateFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateMaxFreeDistance(formats strfmt.Registry) error {
	if swag.IsZero(o.MaxFreeDistance) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"maxFreeDistance", "body", o.MaxFreeDistance, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateMileageCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.MileageCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"mileageCharge", "body", o.MileageCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateNumberOfAdditionalDrivers(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfAdditionalDrivers) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"numberOfAdditionalDrivers", "body", o.NumberOfAdditionalDrivers, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateOdometerReading(formats strfmt.Registry) error {
	if swag.IsZero(o.OdometerReading) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"odometerReading", "body", o.OdometerReading, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateOneWayDropOffAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OneWayDropOffAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"oneWayDropOffAmount", "body", o.OneWayDropOffAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateOtherCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.OtherCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"otherCharges", "body", o.OtherCharges, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateParkingViolationCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ParkingViolationCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"parkingViolationCharge", "body", o.ParkingViolationCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validatePhoneCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"phoneCharge", "body", o.PhoneCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"programCode", "body", o.ProgramCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateRatePerMile(formats strfmt.Registry) error {
	if swag.IsZero(o.RatePerMile) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"ratePerMile", "body", o.RatePerMile, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateRentalAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.RentalAddress) { // not required
		return nil
	}

	if o.RentalAddress != nil {
		if err := o.RentalAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateRentalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.RentalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalDateTime", "body", o.RentalDateTime, 21); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateReturnAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ReturnAddress) { // not required
		return nil
	}

	if o.ReturnAddress != nil {
		if err := o.ReturnAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateReturnDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.ReturnDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnDateTime", "body", o.ReturnDateTime, 21); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateSpecialProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SpecialProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"specialProgramCode", "body", o.SpecialProgramCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	if o.TaxDetails != nil {
		if err := o.TaxDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateTimePeriod(formats strfmt.Registry) error {
	if swag.IsZero(o.TimePeriod) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"timePeriod", "body", o.TimePeriod, 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateTowingCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.TowingCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"towingCharge", "body", o.TowingCharge, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateVehicleClass(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleClass) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleClass", "body", o.VehicleClass, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateVehicleIdentificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleIdentificationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleIdentificationNumber", "body", o.VehicleIdentificationNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateVehicleMake(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleMake) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleMake", "body", o.VehicleMake, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateVehicleModel(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleModel) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleModel", "body", o.VehicleModel, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) validateWeeklyRentalRate(formats strfmt.Registry) error {
	if swag.IsZero(o.WeeklyRentalRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"weeklyRentalRate", "body", o.WeeklyRentalRate, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body travel information auto rental based on the context it is used
func (o *CapturePaymentParamsBodyTravelInformationAutoRental) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRentalAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateReturnAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) contextValidateRentalAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.RentalAddress != nil {

		if swag.IsZero(o.RentalAddress) { // not required
			return nil
		}

		if err := o.RentalAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) contextValidateReturnAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ReturnAddress != nil {

		if swag.IsZero(o.ReturnAddress) { // not required
			return nil
		}

		if err := o.ReturnAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRental) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.TaxDetails != nil {

		if swag.IsZero(o.TaxDetails) { // not required
			return nil
		}

		if err := o.TaxDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRental) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRental) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationAutoRental
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress capture payment params body travel information auto rental rental address
swagger:model CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress
*/
type CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress struct {

	// Address from where the vehicle was rented.
	//
	// Max Length: 13
	Address1 string `json:"address1,omitempty"`

	// Address from where the vehicle was rented.
	//
	// Max Length: 13
	Address2 string `json:"address2,omitempty"`

	// City in which the auto was rented.
	//
	// For authorizations, this field is supported for Visa, MasterCard, and American Express.
	//
	// For captures, this field is supported only for American Express.
	//
	// For all other card types, this field is ignored.
	//
	// Max Length: 25
	City string `json:"city,omitempty"`

	// Country where the auto was rented. Use the [ISO Standard Country Codes.](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	// This field is supported only for American Express.
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// This field contains the location where a taxi passenger was picked up or where an auto rental vehicle was picked up. In most cases, this is the rental agency's business name that appears on the storefront and/or customer receipts, commonly referred to as the DBA (Doing Business As) name. However, if the vehicle was picked up at another location (e.g., a hotel,auto dealership, repair shop, etc.), the name of that location should be used. This entry must be easily recognized by the Cardmember to avoid unnecessary inquiries. If the name is more than 38  characters, use proper and meaningful abbreviation, when possible.
	//
	// Max Length: 38
	Location string `json:"location,omitempty"`

	// The agency code, address, phone number, etc., used to identify the location where the vehicle was rented.
	//
	// Max Length: 10
	LocationID string `json:"locationId,omitempty"`

	// When merchant wants to send the rental address's postal code.
	//
	// Max Length: 50
	PostalCode string `json:"postalCode,omitempty"`

	// State in which the auto was rented. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// Max Length: 3
	State string `json:"state,omitempty"`
}

// Validate validates this capture payment params body travel information auto rental rental address
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"address1", "body", o.Address1, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"address2", "body", o.Address2, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(o.City) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"city", "body", o.City, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.Location) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"location", "body", o.Location, 38); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateLocationID(formats strfmt.Registry) error {
	if swag.IsZero(o.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"locationId", "body", o.LocationID, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"postalCode", "body", o.PostalCode, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"state", "body", o.State, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information auto rental rental address based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationAutoRentalRentalAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress capture payment params body travel information auto rental return address
swagger:model CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress
*/
type CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress struct {

	// When merchant wants to send the rental address's street address.
	//
	// Max Length: 50
	Address1 string `json:"address1,omitempty"`

	// City where the auto was returned to the rental agency.
	//
	// Max Length: 25
	City string `json:"city,omitempty"`

	// Country where the auto was returned to the rental agency. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// This field contains the location where the taxi passenger was dropped off or where the auto rental vehicle was returned.
	//
	// Max Length: 38
	Location string `json:"location,omitempty"`

	// Code, address, phone number, etc. used to identify the location of the auto rental return.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 10
	LocationID string `json:"locationId,omitempty"`

	// When merchant wants to send the return address's postal code.
	//
	// Max Length: 50
	PostalCode string `json:"postalCode,omitempty"`

	// State in which the auto was returned to the rental agency. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For authorizations, this field is supported for Visa, MasterCard, and American Express.
	//
	// For captures, this field is supported only for MasterCard and American Express.
	//
	// Max Length: 3
	State string `json:"state,omitempty"`
}

// Validate validates this capture payment params body travel information auto rental return address
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"address1", "body", o.Address1, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(o.City) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"city", "body", o.City, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.Location) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"location", "body", o.Location, 38); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateLocationID(formats strfmt.Registry) error {
	if swag.IsZero(o.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"locationId", "body", o.LocationID, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"postalCode", "body", o.PostalCode, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"state", "body", o.State, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information auto rental return address based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationAutoRentalReturnAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails capture payment params body travel information auto rental tax details
swagger:model CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails
*/
type CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the tax amount (`travelInformation.autoRental.taxDetails.amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: tax amount is not included in the request.
	// - `true`:  tax amount is included in the request.
	//
	Applied bool `json:"applied,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Summary of all tax types
	//
	// Max Length: 12
	TaxSummary string `json:"taxSummary,omitempty"`

	// Different taxes the rental agency applies to the rental agreement such as tourist tax, airport tax, or rental tax.
	//
	// Max Length: 10
	TaxType string `json:"taxType,omitempty"`
}

// Validate validates this capture payment params body travel information auto rental tax details
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateTaxSummary(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxSummary) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"taxSummary", "body", o.TaxSummary, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateTaxType(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"taxType", "body", o.TaxType, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information auto rental tax details based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationAutoRentalTaxDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationLodging capture payment params body travel information lodging
swagger:model CapturePaymentParamsBodyTravelInformationLodging
*/
type CapturePaymentParamsBodyTravelInformationLodging struct {

	// Amount of an additional coupon or discount.
	//
	// Max Length: 12
	AdditionalDiscountAmount string `json:"additionalDiscountAmount,omitempty"`

	// Adjusted amount charged in addition to the reservation amount after the stay is complete.
	//
	// Max Length: 12
	AdjustmentAmount string `json:"adjustmentAmount,omitempty"`

	// Cost of audio visual services.
	//
	// Max Length: 12
	AudioVisualCost string `json:"audioVisualCost,omitempty"`

	// Cost of banquet services.
	//
	// Max Length: 12
	BanquestCost string `json:"banquestCost,omitempty"`

	// Cost of business center services.
	//
	// Max Length: 12
	BusinessCenterCost string `json:"businessCenterCost,omitempty"`

	// Cost of the cash that was disbursed plus any associated service fees
	//
	// Max Length: 12
	CashDisbursementCost string `json:"cashDisbursementCost,omitempty"`

	// Date on which the guest checked in. In the case of a no-show or a reservation, the scheduled arrival date.
	// Format: `MMDDYY`. For best interchange rates, make sure it is a valid date.
	//
	// Max Length: 6
	CheckInDate string `json:"checkInDate,omitempty"`

	// The date of the check-in in GMT+8 offset.
	//
	CheckInDateTime string `json:"checkInDateTime,omitempty"`

	// Date on which the guest checked out.
	// Format: `MMDDYY`. For best interchange rates, make sure it is a valid date.
	//
	// Max Length: 6
	CheckOutDate string `json:"checkOutDate,omitempty"`

	// The date of the check-out in GMT+8 offset.
	//
	CheckOutDateTime string `json:"checkOutDateTime,omitempty"`

	// Cost of conference room services.
	//
	// Max Length: 12
	ConferenceRoomCost string `json:"conferenceRoomCost,omitempty"`

	// Code assigned to a business. You can use this code to identify corporate rates and discounts for guests.
	//
	// Max Length: 17
	CorporateClientCode string `json:"corporateClientCode,omitempty"`

	// Your toll-free customer service phone number.
	//
	// Max Length: 17
	CustomerServicePhoneNumber string `json:"customerServicePhoneNumber,omitempty"`

	// Service fee for early departure.
	//
	// Max Length: 12
	EarlyCheckOutCost string `json:"earlyCheckOutCost,omitempty"`

	// Cost for all food and beverages.
	//
	// Max Length: 12
	FoodAndBeverageCost string `json:"foodAndBeverageCost,omitempty"`

	// Cost of gift shop purchases.
	//
	// Max Length: 12
	GiftShopCost string `json:"giftShopCost,omitempty"`

	// Gratuity.
	//
	// Max Length: 12
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Name of the guest under which the room is reserved.
	//
	// Max Length: 40
	GuestName string `json:"guestName,omitempty"`

	// Cost of health club services.
	//
	// Max Length: 12
	HealthClubCost string `json:"healthClubCost,omitempty"`

	// The name of the hotel for which the reservation was made.
	//
	HotelName string `json:"hotelName,omitempty"`

	// Cost of Internet access.
	//
	// Max Length: 12
	InternetAccessCost string `json:"internetAccessCost,omitempty"`

	// Cost of laundry services.
	//
	// Max Length: 12
	LaundryCost string `json:"laundryCost,omitempty"`

	// Cost of lounge and bar purchases.
	//
	// Max Length: 12
	LoungeBarCost string `json:"loungeBarCost,omitempty"`

	// Cost of mini-bar purchases.
	//
	// Max Length: 12
	MiniBarCost string `json:"miniBarCost,omitempty"`

	// Miscellaneous costs.
	//
	// Max Length: 12
	MiscellaneousCost string `json:"miscellaneousCost,omitempty"`

	// Cost of movies.
	//
	// Max Length: 12
	MovieCost string `json:"movieCost,omitempty"`

	// Name of the hotel for which the reservation is for. Mandatory in case the
	// merchant's business type is Hotel.
	//
	// Max Length: 255
	Name string `json:"name,omitempty"`

	// Cost of non-room purchases, such as meals and gifts.
	//
	// Max Length: 12
	NonRoomCost string `json:"nonRoomCost,omitempty"`

	// Tax on non-room purchases.
	//
	// Max Length: 12
	NonRoomTaxAmount string `json:"nonRoomTaxAmount,omitempty"`

	// Number of guests staying in the room.
	//
	// Maximum: 99
	// Minimum: 1
	NumberOfGuests int64 `json:"numberOfGuests,omitempty"`

	// Number of rooms booked by the cardholder.
	//
	// Maximum: 99
	// Minimum: 1
	NumberOfRooms int64 `json:"numberOfRooms,omitempty"`

	// Cost of telephone services.
	//
	// Max Length: 12
	PhoneCost string `json:"phoneCost,omitempty"`

	// Prepaid amount, such as a deposit.
	//
	// Max Length: 12
	PrepaidCost string `json:"prepaidCost,omitempty"`

	// Cost of restaurant purchases
	//
	// Max Length: 12
	RestaurantCost string `json:"restaurantCost,omitempty"`

	// The object containing the number of nights and the daily rate that applies for that no of nights.
	//
	Room []*CapturePaymentParamsBodyTravelInformationLodgingRoomItems0 `json:"room"`

	// Type of room, such as queen, king, or two doubles.
	//
	// Max Length: 12
	RoomBedType string `json:"roomBedType,omitempty"`

	// Location of room, such as lake view or ocean view.
	//
	// Max Length: 10
	RoomLocation string `json:"roomLocation,omitempty"`

	// Type of rate, such as corporate or senior citizen.
	//
	// Max Length: 12
	RoomRateType string `json:"roomRateType,omitempty"`

	// Cost of room service.
	//
	// Max Length: 12
	RoomServiceCost string `json:"roomServiceCost,omitempty"`

	// Total tax for the room.
	//
	// Max Length: 12
	RoomTaxAmount string `json:"roomTaxAmount,omitempty"`

	// Type of tax, such as tourist or hotel.
	//
	// Max Length: 10
	RoomTaxType string `json:"roomTaxType,omitempty"`

	// Smoking preference of the guest.
	// Possible values:
	// - `Y`: smoking room
	// - `N`: non-smoking room
	//
	// Max Length: 1
	SmokingPreference string `json:"smokingPreference,omitempty"`

	// Code that identifies special circumstances.
	// Possible values:
	// - `1`: lodging (default)
	// - `2`: no show reservation
	// - `3`: advanced deposit
	//
	// Max Length: 1
	SpecialProgramCode string `json:"specialProgramCode,omitempty"`

	// Total tax amount.
	//
	// Max Length: 12
	TotalTaxAmount string `json:"totalTaxAmount,omitempty"`

	// Cost of transportation services.
	//
	// Max Length: 12
	TransportationCost string `json:"transportationCost,omitempty"`

	// Cost of valet parking services.
	//
	// Max Length: 12
	ValetParkingCost string `json:"valetParkingCost,omitempty"`
}

// Validate validates this capture payment params body travel information lodging
func (o *CapturePaymentParamsBodyTravelInformationLodging) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdjustmentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAudioVisualCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBanquestCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBusinessCenterCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCashDisbursementCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckInDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckOutDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConferenceRoomCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCorporateClientCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerServicePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEarlyCheckOutCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFoodAndBeverageCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGiftShopCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGuestName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthClubCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInternetAccessCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLaundryCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLoungeBarCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiniBarCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiscellaneousCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMovieCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNonRoomCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNonRoomTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfGuests(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfRooms(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrepaidCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRestaurantCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoom(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomBedType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomRateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomServiceCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomTaxType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSmokingPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpecialProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransportationCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValetParkingCost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateAdditionalDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalDiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"additionalDiscountAmount", "body", o.AdditionalDiscountAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateAdjustmentAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustmentAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"adjustmentAmount", "body", o.AdjustmentAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateAudioVisualCost(formats strfmt.Registry) error {
	if swag.IsZero(o.AudioVisualCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"audioVisualCost", "body", o.AudioVisualCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateBanquestCost(formats strfmt.Registry) error {
	if swag.IsZero(o.BanquestCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"banquestCost", "body", o.BanquestCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateBusinessCenterCost(formats strfmt.Registry) error {
	if swag.IsZero(o.BusinessCenterCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"businessCenterCost", "body", o.BusinessCenterCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateCashDisbursementCost(formats strfmt.Registry) error {
	if swag.IsZero(o.CashDisbursementCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"cashDisbursementCost", "body", o.CashDisbursementCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateCheckInDate(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckInDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"checkInDate", "body", o.CheckInDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateCheckOutDate(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckOutDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"checkOutDate", "body", o.CheckOutDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateConferenceRoomCost(formats strfmt.Registry) error {
	if swag.IsZero(o.ConferenceRoomCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"conferenceRoomCost", "body", o.ConferenceRoomCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateCorporateClientCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CorporateClientCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"corporateClientCode", "body", o.CorporateClientCode, 17); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateCustomerServicePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerServicePhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"customerServicePhoneNumber", "body", o.CustomerServicePhoneNumber, 17); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateEarlyCheckOutCost(formats strfmt.Registry) error {
	if swag.IsZero(o.EarlyCheckOutCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"earlyCheckOutCost", "body", o.EarlyCheckOutCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateFoodAndBeverageCost(formats strfmt.Registry) error {
	if swag.IsZero(o.FoodAndBeverageCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"foodAndBeverageCost", "body", o.FoodAndBeverageCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateGiftShopCost(formats strfmt.Registry) error {
	if swag.IsZero(o.GiftShopCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"giftShopCost", "body", o.GiftShopCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateGratuityAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"gratuityAmount", "body", o.GratuityAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateGuestName(formats strfmt.Registry) error {
	if swag.IsZero(o.GuestName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"guestName", "body", o.GuestName, 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateHealthClubCost(formats strfmt.Registry) error {
	if swag.IsZero(o.HealthClubCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"healthClubCost", "body", o.HealthClubCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateInternetAccessCost(formats strfmt.Registry) error {
	if swag.IsZero(o.InternetAccessCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"internetAccessCost", "body", o.InternetAccessCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateLaundryCost(formats strfmt.Registry) error {
	if swag.IsZero(o.LaundryCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"laundryCost", "body", o.LaundryCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateLoungeBarCost(formats strfmt.Registry) error {
	if swag.IsZero(o.LoungeBarCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"loungeBarCost", "body", o.LoungeBarCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateMiniBarCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MiniBarCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"miniBarCost", "body", o.MiniBarCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateMiscellaneousCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MiscellaneousCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"miscellaneousCost", "body", o.MiscellaneousCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateMovieCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MovieCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"movieCost", "body", o.MovieCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"name", "body", o.Name, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateNonRoomCost(formats strfmt.Registry) error {
	if swag.IsZero(o.NonRoomCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"nonRoomCost", "body", o.NonRoomCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateNonRoomTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.NonRoomTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"nonRoomTaxAmount", "body", o.NonRoomTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateNumberOfGuests(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfGuests) { // not required
		return nil
	}

	if err := validate.MinimumInt("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfGuests", "body", o.NumberOfGuests, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfGuests", "body", o.NumberOfGuests, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateNumberOfRooms(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfRooms) { // not required
		return nil
	}

	if err := validate.MinimumInt("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfRooms", "body", o.NumberOfRooms, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfRooms", "body", o.NumberOfRooms, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validatePhoneCost(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"phoneCost", "body", o.PhoneCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validatePrepaidCost(formats strfmt.Registry) error {
	if swag.IsZero(o.PrepaidCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"prepaidCost", "body", o.PrepaidCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRestaurantCost(formats strfmt.Registry) error {
	if swag.IsZero(o.RestaurantCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"restaurantCost", "body", o.RestaurantCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRoom(formats strfmt.Registry) error {
	if swag.IsZero(o.Room) { // not required
		return nil
	}

	for i := 0; i < len(o.Room); i++ {
		if swag.IsZero(o.Room[i]) { // not required
			continue
		}

		if o.Room[i] != nil {
			if err := o.Room[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRoomBedType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomBedType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomBedType", "body", o.RoomBedType, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRoomLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomLocation) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomLocation", "body", o.RoomLocation, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRoomRateType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomRateType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomRateType", "body", o.RoomRateType, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRoomServiceCost(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomServiceCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomServiceCost", "body", o.RoomServiceCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRoomTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomTaxAmount", "body", o.RoomTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateRoomTaxType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomTaxType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomTaxType", "body", o.RoomTaxType, 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateSmokingPreference(formats strfmt.Registry) error {
	if swag.IsZero(o.SmokingPreference) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"smokingPreference", "body", o.SmokingPreference, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateSpecialProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SpecialProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"specialProgramCode", "body", o.SpecialProgramCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateTotalTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"totalTaxAmount", "body", o.TotalTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateTransportationCost(formats strfmt.Registry) error {
	if swag.IsZero(o.TransportationCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"transportationCost", "body", o.TransportationCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) validateValetParkingCost(formats strfmt.Registry) error {
	if swag.IsZero(o.ValetParkingCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"valetParkingCost", "body", o.ValetParkingCost, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body travel information lodging based on the context it is used
func (o *CapturePaymentParamsBodyTravelInformationLodging) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRoom(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodging) contextValidateRoom(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Room); i++ {

		if o.Room[i] != nil {

			if swag.IsZero(o.Room[i]) { // not required
				return nil
			}

			if err := o.Room[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationLodging) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationLodging) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationLodging
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationLodgingRoomItems0 capture payment params body travel information lodging room items0
swagger:model CapturePaymentParamsBodyTravelInformationLodgingRoomItems0
*/
type CapturePaymentParamsBodyTravelInformationLodgingRoomItems0 struct {

	// Daily cost of the room.
	//
	// Max Length: 8
	DailyRate string `json:"dailyRate,omitempty"`

	// Number of nights billed at the rate specified by `travelInformation.lodging.room[].dailyRate`.
	//
	// Maximum: 9999
	// Minimum: 1
	NumberOfNights int64 `json:"numberOfNights,omitempty"`
}

// Validate validates this capture payment params body travel information lodging room items0
func (o *CapturePaymentParamsBodyTravelInformationLodgingRoomItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDailyRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfNights(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodgingRoomItems0) validateDailyRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DailyRate) { // not required
		return nil
	}

	if err := validate.MaxLength("dailyRate", "body", o.DailyRate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationLodgingRoomItems0) validateNumberOfNights(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfNights) { // not required
		return nil
	}

	if err := validate.MinimumInt("numberOfNights", "body", o.NumberOfNights, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("numberOfNights", "body", o.NumberOfNights, 9999, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information lodging room items0 based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationLodgingRoomItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationLodgingRoomItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationLodgingRoomItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationLodgingRoomItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationTransit capture payment params body travel information transit
swagger:model CapturePaymentParamsBodyTravelInformationTransit
*/
type CapturePaymentParamsBodyTravelInformationTransit struct {

	// airline
	Airline *CapturePaymentParamsBodyTravelInformationTransitAirline `json:"airline,omitempty"`
}

// Validate validates this capture payment params body travel information transit
func (o *CapturePaymentParamsBodyTravelInformationTransit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAirline(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransit) validateAirline(formats strfmt.Registry) error {
	if swag.IsZero(o.Airline) { // not required
		return nil
	}

	if o.Airline != nil {
		if err := o.Airline.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this capture payment params body travel information transit based on the context it is used
func (o *CapturePaymentParamsBodyTravelInformationTransit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAirline(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransit) contextValidateAirline(ctx context.Context, formats strfmt.Registry) error {

	if o.Airline != nil {

		if swag.IsZero(o.Airline) { // not required
			return nil
		}

		if err := o.Airline.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransit) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransit) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationTransit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationTransitAirline capture payment params body travel information transit airline
swagger:model CapturePaymentParamsBodyTravelInformationTransitAirline
*/
type CapturePaymentParamsBodyTravelInformationTransitAirline struct {

	// Description of the charge if the charge does not involve an airline ticket.
	// For example: Excess baggage.
	//
	// Max Length: 20
	AdditionalCharges string `json:"additionalCharges,omitempty"`

	// ancillary information
	AncillaryInformation *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation `json:"ancillaryInformation,omitempty"`

	// Date of arrival for the last leg of the trip.
	// Format: `MMDDYYYY`
	// English characters only.
	// Optional request field.
	//
	// Max Length: 8
	ArrivalDate string `json:"arrivalDate,omitempty"`

	// Boarding fee.
	//
	// Max Length: 12
	BoardingFeeAmount string `json:"boardingFeeAmount,omitempty"`

	// Reference number for the airline booking.
	// Required if ticket numbers are not issued.
	//
	// Max Length: 15
	BookingReferenceNumber string `json:"bookingReferenceNumber,omitempty"`

	// Airline that generated the ticket.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 15
	CarrierName string `json:"carrierName,omitempty"`

	// Check digit for the ticket number. CyberSource recommends that you validate the check digit.
	// With Discover and Diners Club, a valid ticket number has these characteristics:
	// - The value is numeric.
	// - The first three digits are a valid IATA2 license plate carrier code.
	// - The last digit is a check digit or zero (0).
	// - All remaining digits are nonzero.
	//
	// Max Length: 1
	CheckDigit string `json:"checkDigit,omitempty"`

	// Total number of clearing messages associated with the authorization request.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 2
	ClearingCount string `json:"clearingCount,omitempty"`

	// Number that identifies the clearing message when multiple clearing messages are allowed per authorized transaction.
	// Each clearing message linked to one authorization request must include a unique clearing sequence number between 1 and the total number of clearing records.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 2
	ClearingSequence string `json:"clearingSequence,omitempty"`

	// Reason for the credit.
	// Possible values:
	// - `A`: Cancellation of the ancillary passenger transport purchase.
	// - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase.
	// - `C`: Cancellation of the airline ticket.
	// - `O`: Other.
	// - `P`: Partial refund of the airline ticket.
	// Format: English characters only.
	//
	// Optional request field.
	//
	// Max Length: 1
	CreditReasonIndicator string `json:"creditReasonIndicator,omitempty"`

	// Reference number or code that identifies the cardholder.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 40
	CustomerCode string `json:"customerCode,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 14
	DocumentNumber string `json:"documentNumber,omitempty"`

	// The field is not currently supported.
	//
	DocumentNumberOfParts int64 `json:"documentNumberOfParts,omitempty"`

	// Airline document type code that specifies the purpose of the transaction.
	// Format: English characters only.
	// Optional request field.
	//
	// | Code | Description |
	// | --- | --- |
	// | 01 | Passenger ticket |
	// | 02 | Additional collection |
	// | 03 | Excess baggage |
	// | 04 | Miscellaneous charge order (MCO) or prepaid ticket authorization |
	// | 05 | Special service ticket |
	// | 06 | Supported refund |
	// | 07 | Unsupported refund |
	// | 08 | Lost ticket application |
	// | 09 | Tour order voucher |
	// | 10 | Ticket by mail |
	// | 11 | Undercharge adjustment |
	// | 12 | Group ticket |
	// | 13 | Exchange adjustment |
	// | 14 | SPD or air freight |
	// | 15 | In-flight adjustment |
	// | 16 | Agency passenger ticket |
	// | 17 | Agency tour order or voucher |
	// | 18 | Agency miscellaneous charge order (MCO) |
	// | 19 | Agency exchange order |
	// | 20 | Agency group ticket |
	// | 21 | Debit adjustment for duplicate refund or use |
	// | 22 | In-flight merchandise order |
	// | 23 | Catalogue merchandise order |
	// | 24 | In-flight phone charges |
	// | 25 | Frequent flyer fee or purchase |
	// | 26 | Kennel charge |
	// | 27 | Animal transportation charge |
	// | 28 | Firearms case |
	// | 29 | Upgrade charge |
	// | 30 | Credit for unused transportation |
	// | 31 | Credit for class of service adjustment |
	// | 32 | Credit for denied boarding |
	// | 33 | Credit for miscellaneous refund |
	// | 34 | Credit for lost ticket refund |
	// | 35 | Credit for exchange refund |
	// | 36 | Credit for overcharge adjustment |
	// | 37 | Credit for multiple Unused tickets |
	// | 38 | Exchange order |
	// | 39 | Self-service ticket |
	// | 41 | In-flight duty-free purchase |
	// | 42 | Senior citizen discount booklets |
	// | 43 | Club membership fee |
	// | 44 | Coupon book |
	// | 45 | In-flight charges |
	// | 46 | Tour deposit |
	// | 47 | Frequent flyer overnight delivery charge |
	// | 48 | Frequent flyer fulfillment |
	// | 49 | Small package delivery |
	// | 50 | Vendor sale |
	// | 51 | Miscellaneous taxes or fees |
	// | 52 | Travel agency fee |
	// | 60 | Vendor refund or credit |
	// | 64 | Duty free sale |
	// | 65 | Preferred seat upgrade |
	// | 66 | Cabin upgrade |
	// | 67 | Lounge or club access or day pass |
	// | 68 | Agent assisted reservation or ticketing fee |
	// | 69 | Ticket change or cancel fee |
	// | 70 | Trip insurance |
	// | 71 | Unaccompanied minor |
	// | 72 | Standby fee |
	// | 73 | Curbside baggage |
	// | 74 | In-flight medical equipment |
	// | 75 | Ticket or pass print fee |
	// | 76 | Checked sporting or special equipment |
	// | 77 | Dry ice fee |
	// | 78 | Mail or postage fee |
	// | 79 | Club membership fee or temporary trial |
	// | 80 | Frequent flyer activation or reinstatement |
	// | 81 | Gift certificate |
	// | 82 | Onboard or in-flight prepaid voucher |
	// | 83 | Optional services fee |
	// | 84 | Advance purchase for excess baggage |
	// | 85 | Advance purchase for preferred seat upgrade |
	// | 86 | Advance purchase for cabin upgrade |
	// | 87 | Advance purchase for optional services |
	// | 88 | WiFi |
	// | 89 | Packages |
	// | 90 | In-flight entertainment or internet access |
	// | 91 | Overweight bag fee |
	// | 92 | Sleep sets |
	// | 93 | Special purchase fee |
	//
	// Max Length: 1
	DocumentType string `json:"documentType,omitempty"`

	// Flag that indicates whether an electronic ticket was issued.
	// Possible values:
	// - `true`
	// - `false`
	// Optional request field.
	//
	ElectronicTicketIndicator bool `json:"electronicTicketIndicator,omitempty"`

	// Amount of the exchanged ticket.
	// Format: English characters only.
	//
	// Max Length: 12
	ExchangeTicketAmount string `json:"exchangeTicketAmount,omitempty"`

	// Fee for exchanging the ticket.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 12
	ExchangeTicketFeeAmount string `json:"exchangeTicketFeeAmount,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 3
	ExtendedPaymentCode string `json:"extendedPaymentCode,omitempty"`

	// Specifies the type of flight.
	// One way (0)
	// Return (1)
	// Transit (2)
	// Transit & Return (3)
	// Multi-City (4)
	//
	// Max Length: 2
	FlightType string `json:"flightType,omitempty"`

	// The consumer's frequent flyer number. Leave 0 if there is no
	// frequent flyer number
	//
	// Max Length: 255
	FrequentFlyerNumber string `json:"frequentFlyerNumber,omitempty"`

	// The total cost of the flight insurance. Example: 10000.00
	//
	// Max Length: 255
	InsuranceAmount string `json:"insuranceAmount,omitempty"`

	// Invoice date. The format is YYYYMMDD.
	// If this value is
	// included in the request, it is used in the creation of the invoice number. See "Invoice Number,"
	//
	InvoiceDate int64 `json:"invoiceDate,omitempty"`

	// Invoice number for the airline transaction.
	//
	// Max Length: 25
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Specifies if the flight is:
	// Domestic (01)
	// International (02)
	// If Y then 01 else 02
	//
	// Max Length: 255
	IsDomestic string `json:"isDomestic,omitempty"`

	// legs
	Legs []*CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0 `json:"legs"`

	// Number of passengers for whom the ticket was issued.
	// Format: English characters only.
	// Optional request field.
	//
	NumberOfPassengers int64 `json:"numberOfPassengers,omitempty"`

	// Original ticket number when the transaction is for a replacement ticket.
	//
	// Max Length: 14
	OriginalTicketNumber string `json:"originalTicketNumber,omitempty"`

	// Name of the passenger to whom the ticket was issued.  This will always be a single passenger's name.
	// If there are more than one passengers, provide only the primary passenger's name.
	// Do not include special characters such as commas, hyphens, or apostrophes.
	// Only ASCII characters are supported.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 42
	PassengerName string `json:"passengerName,omitempty"`

	// List of passenger types in a booking code:
	// A (Adult)
	// C (Child)
	// Comma separated values for total number of passenger
	//
	// Max Length: 50
	PassengerType string `json:"passengerType,omitempty"`

	// Plan number based on the fare.
	// This value is provided by the airline.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 1
	PlanNumber string `json:"planNumber,omitempty"`

	// Airline process identifier. This value is the airline's three-digit IATA1 code
	// which is used to process extended payment airline tickets.
	//
	// Max Length: 3
	ProcessIdentifier string `json:"processIdentifier,omitempty"`

	// Type of purchase. Possible values:
	// - `EXC`: Exchange ticket
	// - `MSC`: Miscellaneous (not a ticket purchase and not a transaction related to an exchange ticket)
	// - `REF`: Refund
	// - `TKT`: Ticket
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 3
	PurchaseType string `json:"purchaseType,omitempty"`

	// Code that specifies the computerized reservation system used to make the reservation and purchase the ticket.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 20
	ReservationSystemCode string `json:"reservationSystemCode,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 32
	ReservationType string `json:"reservationType,omitempty"`

	// Text that describes the ticket limitations, such as _nonrefundable_.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 20
	RestrictedTicketDesciption string `json:"restrictedTicketDesciption,omitempty"`

	// Flag that indicates whether or not the ticket is restricted (nonrefundable).
	// Possible values:
	// - 0: No restriction (refundable)
	// - 1: Restricted (nonrefundable)
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	RestrictedTicketIndicator int64 `json:"restrictedTicketIndicator,omitempty"`

	// Specifies if the travel agent joins the flight (0) or not (1)
	//
	// Max Length: 255
	ThirdPartyStatus string `json:"thirdPartyStatus,omitempty"`

	// Type of update.
	// Possible values:
	// - `C`: Change to the existing ticket.
	// - `N`: New ticket.
	// Format: English characters only
	// Optional request field.
	//
	// Max Length: 1
	TicketChangeIndicator string `json:"ticketChangeIndicator,omitempty"`

	// Date on which the transaction occurred.
	// Format: `YYYYMMDD`
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 8
	TicketIssueDate string `json:"ticketIssueDate,omitempty"`

	// ticket issuer
	TicketIssuer *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer `json:"ticketIssuer,omitempty"`

	// Ticket number.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 15
	TicketNumber string `json:"ticketNumber,omitempty"`

	// Total clearing amount for all transactions in the clearing count set.
	// This value cannot exceed `99999999999999999999` (twenty 9s).
	// Format: English characters only.
	// If this field is not set and if the total amount from the original authorization is not NULL,
	// the total clearing amount is set to the total amount from the original authorization.
	//
	// Max Length: 20
	TotalClearingAmount string `json:"totalClearingAmount,omitempty"`

	// Total fee for the ticket. This value cannot exceed `99999999999999999999` (twenty 9s).
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 12
	TotalFeeAmount string `json:"totalFeeAmount,omitempty"`

	// Total insurance amount. We have per leg and not total
	//
	// Max Length: 50
	TotalInsuranceAmount string `json:"totalInsuranceAmount,omitempty"`

	// Type of charge.
	// Possible values:
	// - 01: Charge is for an airline ticket
	// - 02: Charge is for an item that is not an airline ticket
	//
	TransactionType int64 `json:"transactionType,omitempty"`
}

// Validate validates this capture payment params body travel information transit airline
func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAncillaryInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateArrivalDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBoardingFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBookingReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCarrierName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckDigit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClearingCount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClearingSequence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreditReasonIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDocumentNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDocumentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtendedPaymentCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFlightType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFrequentFlyerNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsuranceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIsDomestic(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLegs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengerType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlanNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReservationSystemCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReservationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRestrictedTicketDesciption(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThirdPartyStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketChangeIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketIssueDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalClearingAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalInsuranceAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateAdditionalCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"additionalCharges", "body", o.AdditionalCharges, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateAncillaryInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AncillaryInformation) { // not required
		return nil
	}

	if o.AncillaryInformation != nil {
		if err := o.AncillaryInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateArrivalDate(formats strfmt.Registry) error {
	if swag.IsZero(o.ArrivalDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"arrivalDate", "body", o.ArrivalDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateBoardingFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.BoardingFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"boardingFeeAmount", "body", o.BoardingFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateBookingReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.BookingReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"bookingReferenceNumber", "body", o.BookingReferenceNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateCarrierName(formats strfmt.Registry) error {
	if swag.IsZero(o.CarrierName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"carrierName", "body", o.CarrierName, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateCheckDigit(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckDigit) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"checkDigit", "body", o.CheckDigit, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateClearingCount(formats strfmt.Registry) error {
	if swag.IsZero(o.ClearingCount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"clearingCount", "body", o.ClearingCount, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateClearingSequence(formats strfmt.Registry) error {
	if swag.IsZero(o.ClearingSequence) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"clearingSequence", "body", o.ClearingSequence, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateCreditReasonIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditReasonIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"creditReasonIndicator", "body", o.CreditReasonIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateCustomerCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"customerCode", "body", o.CustomerCode, 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateDocumentNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.DocumentNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"documentNumber", "body", o.DocumentNumber, 14); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateDocumentType(formats strfmt.Registry) error {
	if swag.IsZero(o.DocumentType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"documentType", "body", o.DocumentType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateExchangeTicketAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"exchangeTicketAmount", "body", o.ExchangeTicketAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateExchangeTicketFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"exchangeTicketFeeAmount", "body", o.ExchangeTicketFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateExtendedPaymentCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtendedPaymentCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"extendedPaymentCode", "body", o.ExtendedPaymentCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateFlightType(formats strfmt.Registry) error {
	if swag.IsZero(o.FlightType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"flightType", "body", o.FlightType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateFrequentFlyerNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.FrequentFlyerNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"frequentFlyerNumber", "body", o.FrequentFlyerNumber, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateInsuranceAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.InsuranceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"insuranceAmount", "body", o.InsuranceAmount, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateInvoiceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"invoiceNumber", "body", o.InvoiceNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateIsDomestic(formats strfmt.Registry) error {
	if swag.IsZero(o.IsDomestic) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"isDomestic", "body", o.IsDomestic, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateLegs(formats strfmt.Registry) error {
	if swag.IsZero(o.Legs) { // not required
		return nil
	}

	for i := 0; i < len(o.Legs); i++ {
		if swag.IsZero(o.Legs[i]) { // not required
			continue
		}

		if o.Legs[i] != nil {
			if err := o.Legs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateOriginalTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"originalTicketNumber", "body", o.OriginalTicketNumber, 14); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validatePassengerName(formats strfmt.Registry) error {
	if swag.IsZero(o.PassengerName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"passengerName", "body", o.PassengerName, 42); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validatePassengerType(formats strfmt.Registry) error {
	if swag.IsZero(o.PassengerType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"passengerType", "body", o.PassengerType, 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validatePlanNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PlanNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"planNumber", "body", o.PlanNumber, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateProcessIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessIdentifier) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"processIdentifier", "body", o.ProcessIdentifier, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validatePurchaseType(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"purchaseType", "body", o.PurchaseType, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateReservationSystemCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ReservationSystemCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"reservationSystemCode", "body", o.ReservationSystemCode, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateReservationType(formats strfmt.Registry) error {
	if swag.IsZero(o.ReservationType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"reservationType", "body", o.ReservationType, 32); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateRestrictedTicketDesciption(formats strfmt.Registry) error {
	if swag.IsZero(o.RestrictedTicketDesciption) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"restrictedTicketDesciption", "body", o.RestrictedTicketDesciption, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateThirdPartyStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.ThirdPartyStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"thirdPartyStatus", "body", o.ThirdPartyStatus, 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateTicketChangeIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketChangeIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketChangeIndicator", "body", o.TicketChangeIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateTicketIssueDate(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketIssueDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssueDate", "body", o.TicketIssueDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateTicketIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketIssuer) { // not required
		return nil
	}

	if o.TicketIssuer != nil {
		if err := o.TicketIssuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketNumber", "body", o.TicketNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateTotalClearingAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalClearingAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"totalClearingAmount", "body", o.TotalClearingAmount, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateTotalFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"totalFeeAmount", "body", o.TotalFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) validateTotalInsuranceAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalInsuranceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"totalInsuranceAmount", "body", o.TotalInsuranceAmount, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body travel information transit airline based on the context it is used
func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAncillaryInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLegs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTicketIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) contextValidateAncillaryInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AncillaryInformation != nil {

		if swag.IsZero(o.AncillaryInformation) { // not required
			return nil
		}

		if err := o.AncillaryInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) contextValidateLegs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Legs); i++ {

		if o.Legs[i] != nil {

			if swag.IsZero(o.Legs[i]) { // not required
				return nil
			}

			if err := o.Legs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) contextValidateTicketIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.TicketIssuer != nil {

		if swag.IsZero(o.TicketIssuer) { // not required
			return nil
		}

		if err := o.TicketIssuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirline) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationTransitAirline
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation capture payment params body travel information transit airline ancillary information
swagger:model CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation
*/
type CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation struct {

	// Number for the airline ticket to which the ancillary purchase is connected.
	//
	// If this purchase has a connection or relationship to another purchase such as a baggage fee for a passenger transport ticket, this field must contain the ticket number for the other purchase.
	//
	// For a stand-alone purchase, the value for this field must be the same as the value for the `travelInformation.transit.airline.ancillaryInformation.ticketNumber` field.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF)
	// program.
	// Format: English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 15
	ConnectedTicketNumber string `json:"connectedTicketNumber,omitempty"`

	// Reason for the credit.
	// Possible values:
	// - `A`: Cancellation of the ancillary passenger transport purchase.
	// - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase.
	// - `C`: Cancellation of the airline ticket.
	// - `O`: Other.
	// - `P`: Partial refund of the airline ticket.
	// Format: English characters only.
	// Optional field for ancillary services.
	//
	// Max Length: 15
	CreditReasonIndicator string `json:"creditReasonIndicator,omitempty"`

	// Name of the passenger. If the passenger's name is not available, this value is the cardholder's name. If neither the passenger's name nor the cardholder's name is available,
	// this value is a description of the ancillary purchase.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF)
	// program.
	// Format: English characters only.
	// Optional field for ancillary service.
	//
	// Max Length: 20
	PassengerName string `json:"passengerName,omitempty"`

	// service
	Service []*CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 `json:"service"`

	// Ticket number, which consists of the carrier code, form, and serial number, without the check digit.
	// **Important** This field is required in the U.S. in order for you to qualify for either the
	// custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF) program.
	// Format: English characters only.
	// Optional field for ancillary services.
	//
	// Max Length: 15
	TicketNumber string `json:"ticketNumber,omitempty"`
}

// Validate validates this capture payment params body travel information transit airline ancillary information
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConnectedTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreditReasonIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateService(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateConnectedTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ConnectedTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"connectedTicketNumber", "body", o.ConnectedTicketNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateCreditReasonIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditReasonIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"creditReasonIndicator", "body", o.CreditReasonIndicator, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validatePassengerName(formats strfmt.Registry) error {
	if swag.IsZero(o.PassengerName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"passengerName", "body", o.PassengerName, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateService(formats strfmt.Registry) error {
	if swag.IsZero(o.Service) { // not required
		return nil
	}

	for i := 0; i < len(o.Service); i++ {
		if swag.IsZero(o.Service[i]) { // not required
			continue
		}

		if o.Service[i] != nil {
			if err := o.Service[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"ticketNumber", "body", o.TicketNumber, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this capture payment params body travel information transit airline ancillary information based on the context it is used
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) contextValidateService(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Service); i++ {

		if o.Service[i] != nil {

			if swag.IsZero(o.Service[i]) { // not required
				return nil
			}

			if err := o.Service[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("capturePaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 capture payment params body travel information transit airline ancillary information service items0
swagger:model CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0
*/
type CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 struct {

	// Category code for the ancillary service that is provided. Obtain the codes from the International
	// Air Transport Association (IATA).
	// **Note** `#` is either 0, 1, 2, or 3.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom
	// payment service (CPS) or the electronic interchange reimbursement fee (EIRF)program.
	// Format: English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 4
	CategoryCode string `json:"categoryCode,omitempty"`

	// Subcategory code for the ancillary service category. Obtain the codes from the International
	// Air Transport Association (IATA).
	// **Note** `#` is either 0, 1, 2, or 3.
	// Format  English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 4
	SubCategoryCode string `json:"subCategoryCode,omitempty"`
}

// Validate validates this capture payment params body travel information transit airline ancillary information service items0
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) validateCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("categoryCode", "body", o.CategoryCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) validateSubCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SubCategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("subCategoryCode", "body", o.SubCategoryCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information transit airline ancillary information service items0 based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0 capture payment params body travel information transit airline legs items0
swagger:model CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0
*/
type CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0 struct {

	// Time of arrival for this leg of the trip.
	// The format is military time and HHMM:
	// If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	ArrivalTime int64 `json:"arrivalTime,omitempty"`

	// AM or PM for the arrival time for this leg of the trip.
	// Possible values:
	// - `A`: 12:00 midnight to 11:59 a.m.
	// - `P`: 12:00 noon to 11:59 p.m.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	ArrivalTimeMeridian string `json:"arrivalTimeMeridian,omitempty"`

	// IATA code for the carrier for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 4
	CarrierCode string `json:"carrierCode,omitempty"`

	// IATA code for the class of service for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 3
	Class string `json:"class,omitempty"`

	// Ticket that contains additional coupons for this leg of the trip on an itinerary that has more than four segments.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 25
	ConjunctionTicket string `json:"conjunctionTicket,omitempty"`

	// Coupon number. Each leg on the ticket requires a separate coupon, and each coupon is identified by the coupon number.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	CouponNumber string `json:"couponNumber,omitempty"`

	// Amount of departure tax for this leg of the trip.
	//
	// Max Length: 12
	DepartTaxAmount string `json:"departTaxAmount,omitempty"`

	// Departure date for the first leg of the trip.
	// Format: `YYYYMMDD`.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	DepartureDate int64 `json:"departureDate,omitempty"`

	// Time of departure for this leg of the trip. The format is military time and HHMM:
	// If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	DepartureTime int64 `json:"departureTime,omitempty"`

	// AM or PM for the departure time.
	// Possible values:
	// - A: 12:00 midnight to 11:59 a.m.
	// - P: 12:00 noon to 11:59 p.m
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	DepartureTimeMeridian string `json:"departureTimeMeridian,omitempty"`

	// IATA code for the destination airport for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 3
	DestinationAirportCode string `json:"destinationAirportCode,omitempty"`

	// Notes or notations about endorsements and restrictions for this leg of the trip.
	// Endorsements can be notations added by the travel agency, including mandatory government-required notations such as value added tax.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 20
	EndorsementsRestrictions string `json:"endorsementsRestrictions,omitempty"`

	// New ticket number that is issued when the ticket is exchanged for this leg of the trip.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 25
	ExchangeTicketNumber string `json:"exchangeTicketNumber,omitempty"`

	// Code for the fare basis for this leg of the trip.
	// The fare basis is assigned by the carriers and indicates a particular ticket type,
	// such as business class or discounted/nonrefundable.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Format: English characters only.
	// Optional request field for travel legs.auto_rental_regular_mileage_cost
	//
	// Max Length: 15
	FareBasis string `json:"fareBasis,omitempty"`

	// Fee for this leg of the trip, such as an airport fee or country fee.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 12
	FeeAmount string `json:"feeAmount,omitempty"`

	// Flight number for this leg of the trip.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 6
	FlightNumber string `json:"flightNumber,omitempty"`

	// IATA code for the originating airport for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 5
	OriginatingAirportCode string `json:"originatingAirportCode,omitempty"`

	// Code that indicates whether a stopover is allowed on this leg of the trip. Possible values:
	// - `O` (capital letter "O") (default): Stopover allowed
	// - `X` (capital letter "X"): Stopover not allowed
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	StopoverIndicator int64 `json:"stopoverIndicator,omitempty"`

	// Tax for this leg of the trip.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Total fare for this leg of the trip.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 15
	TotalFareAmount string `json:"totalFareAmount,omitempty"`
}

// Validate validates this capture payment params body travel information transit airline legs items0
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateArrivalTimeMeridian(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCarrierCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConjunctionTicket(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCouponNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDepartTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDepartureTimeMeridian(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDestinationAirportCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEndorsementsRestrictions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFareBasis(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFlightNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginatingAirportCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalFareAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateArrivalTimeMeridian(formats strfmt.Registry) error {
	if swag.IsZero(o.ArrivalTimeMeridian) { // not required
		return nil
	}

	if err := validate.MaxLength("arrivalTimeMeridian", "body", o.ArrivalTimeMeridian, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateCarrierCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CarrierCode) { // not required
		return nil
	}

	if err := validate.MaxLength("carrierCode", "body", o.CarrierCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(o.Class) { // not required
		return nil
	}

	if err := validate.MaxLength("class", "body", o.Class, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateConjunctionTicket(formats strfmt.Registry) error {
	if swag.IsZero(o.ConjunctionTicket) { // not required
		return nil
	}

	if err := validate.MaxLength("conjunctionTicket", "body", o.ConjunctionTicket, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateCouponNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CouponNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("couponNumber", "body", o.CouponNumber, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateDepartTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DepartTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("departTaxAmount", "body", o.DepartTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateDepartureTimeMeridian(formats strfmt.Registry) error {
	if swag.IsZero(o.DepartureTimeMeridian) { // not required
		return nil
	}

	if err := validate.MaxLength("departureTimeMeridian", "body", o.DepartureTimeMeridian, 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateDestinationAirportCode(formats strfmt.Registry) error {
	if swag.IsZero(o.DestinationAirportCode) { // not required
		return nil
	}

	if err := validate.MaxLength("destinationAirportCode", "body", o.DestinationAirportCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateEndorsementsRestrictions(formats strfmt.Registry) error {
	if swag.IsZero(o.EndorsementsRestrictions) { // not required
		return nil
	}

	if err := validate.MaxLength("endorsementsRestrictions", "body", o.EndorsementsRestrictions, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateExchangeTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("exchangeTicketNumber", "body", o.ExchangeTicketNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateFareBasis(formats strfmt.Registry) error {
	if swag.IsZero(o.FareBasis) { // not required
		return nil
	}

	if err := validate.MaxLength("fareBasis", "body", o.FareBasis, 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("feeAmount", "body", o.FeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateFlightNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.FlightNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("flightNumber", "body", o.FlightNumber, 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateOriginatingAirportCode(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginatingAirportCode) { // not required
		return nil
	}

	if err := validate.MaxLength("originatingAirportCode", "body", o.OriginatingAirportCode, 5); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateTotalFareAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalFareAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalFareAmount", "body", o.TotalFareAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information transit airline legs items0 based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationTransitAirlineLegsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer capture payment params body travel information transit airline ticket issuer
swagger:model CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer
*/
type CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer struct {

	// Address of the company issuing the ticket.
	//
	// Max Length: 16
	Address string `json:"address,omitempty"`

	// State in which transaction occured.
	//
	// Max Length: 18
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// IATA2 airline code.
	// Format: English characters only.
	// Required for Mastercard; optional for all other card types.
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Country in which transaction occured.
	//
	// Max Length: 18
	Country string `json:"country,omitempty"`

	// City in which the transaction occurred.
	// If the name of the city exceeds 18 characters, use meaningful abbreviations.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 18
	Locality string `json:"locality,omitempty"`

	// Name of the ticket issuer. If you do not include this field,
	// CyberSource uses the value for your merchant name that is in the CyberSource merchant configuration database.
	//
	// Max Length: 20
	Name string `json:"name,omitempty"`

	// Zip code of the city in which transaction occured.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body travel information transit airline ticket issuer
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.Address) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"address", "body", o.Address, 16); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"administrativeArea", "body", o.AdministrativeArea, 18); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"country", "body", o.Country, 18); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"locality", "body", o.Locality, 18); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"name", "body", o.Name, 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"postalCode", "body", o.PostalCode, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information transit airline ticket issuer based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CapturePaymentParamsBodyTravelInformationVehicleData capture payment params body travel information vehicle data
swagger:model CapturePaymentParamsBodyTravelInformationVehicleData
*/
type CapturePaymentParamsBodyTravelInformationVehicleData struct {

	// This field will contain charging reason code values for electric vehicle transactions.
	//
	// Possible Values:
	// 010 (Other Error)
	// 011 (Connector Lock Failure)
	// 012 (EV Communication Error)
	// 013 (Ground Failure)
	// 014 (High Temperature)
	// 015 (Internal Error)
	// 016 (Over Current Failure)
	// 017 (Over Voltage)
	// 018 (Power Meter Failure)
	// 019 (Power Switch Failure)
	// 020 (Reader Failure)
	// 021 (Reset Failure)
	// 022 (Under Voltage)
	// 023 (Weak Signal)
	// 100 (No Error)
	// 200 (Payment Related Error)
	//
	// Max Length: 3
	ChargingReasonCode string `json:"chargingReasonCode,omitempty"`

	// This field will contain connector type values for electric vehicle transactions.
	//
	// Possible Values:
	// 001 (AC - J1772 Type 1)
	// 002 (AC - Mennekes - Type 2)
	// 003 (AC - GB/T)
	// 100 (DC - CCS1)
	// 101 (DC - CHAdeMO)
	// 102 (DC - CCS2)
	// 103 (DC - GB/T)
	// 200 (NACS – Tesla)
	//
	// Max Length: 3
	ConnectorType string `json:"connectorType,omitempty"`
}

// Validate validates this capture payment params body travel information vehicle data
func (o *CapturePaymentParamsBodyTravelInformationVehicleData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateChargingReasonCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConnectorType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationVehicleData) validateChargingReasonCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ChargingReasonCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"vehicleData"+"."+"chargingReasonCode", "body", o.ChargingReasonCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyTravelInformationVehicleData) validateConnectorType(formats strfmt.Registry) error {
	if swag.IsZero(o.ConnectorType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"travelInformation"+"."+"vehicleData"+"."+"connectorType", "body", o.ConnectorType, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this capture payment params body travel information vehicle data based on context it is used
func (o *CapturePaymentParamsBodyTravelInformationVehicleData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationVehicleData) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyTravelInformationVehicleData) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyTravelInformationVehicleData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
