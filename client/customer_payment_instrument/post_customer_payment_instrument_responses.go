// Code generated by go-swagger; DO NOT EDIT.

package customer_payment_instrument

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PostCustomerPaymentInstrumentReader is a Reader for the PostCustomerPaymentInstrument structure.
type PostCustomerPaymentInstrumentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PostCustomerPaymentInstrumentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewPostCustomerPaymentInstrumentCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPostCustomerPaymentInstrumentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPostCustomerPaymentInstrumentForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 409:
		result := NewPostCustomerPaymentInstrumentConflict()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 424:
		result := NewPostCustomerPaymentInstrumentFailedDependency()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewPostCustomerPaymentInstrumentInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[POST /tms/v2/customers/{customerId}/payment-instruments] postCustomerPaymentInstrument", response, response.Code())
	}
}

// NewPostCustomerPaymentInstrumentCreated creates a PostCustomerPaymentInstrumentCreated with default headers values
func NewPostCustomerPaymentInstrumentCreated() *PostCustomerPaymentInstrumentCreated {
	return &PostCustomerPaymentInstrumentCreated{}
}

/*
PostCustomerPaymentInstrumentCreated describes a response with status code 201, with default header values.

A new Payment Instrument has been created.
*/
type PostCustomerPaymentInstrumentCreated struct {

	/* An ETag is an identifier assigned to a specific version of a resource.
	 */
	ETag string

	/* Location of the Payment Instrument.
	 */
	Location string

	/* A globally-unique Id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation Id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PostCustomerPaymentInstrumentCreatedBody
}

// IsSuccess returns true when this post customer payment instrument created response has a 2xx status code
func (o *PostCustomerPaymentInstrumentCreated) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this post customer payment instrument created response has a 3xx status code
func (o *PostCustomerPaymentInstrumentCreated) IsRedirect() bool {
	return false
}

// IsClientError returns true when this post customer payment instrument created response has a 4xx status code
func (o *PostCustomerPaymentInstrumentCreated) IsClientError() bool {
	return false
}

// IsServerError returns true when this post customer payment instrument created response has a 5xx status code
func (o *PostCustomerPaymentInstrumentCreated) IsServerError() bool {
	return false
}

// IsCode returns true when this post customer payment instrument created response a status code equal to that given
func (o *PostCustomerPaymentInstrumentCreated) IsCode(code int) bool {
	return code == 201
}

// Code gets the status code for the post customer payment instrument created response
func (o *PostCustomerPaymentInstrumentCreated) Code() int {
	return 201
}

func (o *PostCustomerPaymentInstrumentCreated) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentCreated %s", 201, payload)
}

func (o *PostCustomerPaymentInstrumentCreated) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentCreated %s", 201, payload)
}

func (o *PostCustomerPaymentInstrumentCreated) GetPayload() *PostCustomerPaymentInstrumentCreatedBody {
	return o.Payload
}

func (o *PostCustomerPaymentInstrumentCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header ETag
	hdrETag := response.GetHeader("ETag")

	if hdrETag != "" {
		o.ETag = hdrETag
	}

	// hydrates response header Location
	hdrLocation := response.GetHeader("Location")

	if hdrLocation != "" {
		o.Location = hdrLocation
	}

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PostCustomerPaymentInstrumentCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostCustomerPaymentInstrumentBadRequest creates a PostCustomerPaymentInstrumentBadRequest with default headers values
func NewPostCustomerPaymentInstrumentBadRequest() *PostCustomerPaymentInstrumentBadRequest {
	return &PostCustomerPaymentInstrumentBadRequest{}
}

/*
PostCustomerPaymentInstrumentBadRequest describes a response with status code 400, with default header values.

Bad Request: e.g. A required header value could be missing.
*/
type PostCustomerPaymentInstrumentBadRequest struct {

	/* A globally unique Id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation Id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PostCustomerPaymentInstrumentBadRequestBody
}

// IsSuccess returns true when this post customer payment instrument bad request response has a 2xx status code
func (o *PostCustomerPaymentInstrumentBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this post customer payment instrument bad request response has a 3xx status code
func (o *PostCustomerPaymentInstrumentBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this post customer payment instrument bad request response has a 4xx status code
func (o *PostCustomerPaymentInstrumentBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this post customer payment instrument bad request response has a 5xx status code
func (o *PostCustomerPaymentInstrumentBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this post customer payment instrument bad request response a status code equal to that given
func (o *PostCustomerPaymentInstrumentBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the post customer payment instrument bad request response
func (o *PostCustomerPaymentInstrumentBadRequest) Code() int {
	return 400
}

func (o *PostCustomerPaymentInstrumentBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentBadRequest %s", 400, payload)
}

func (o *PostCustomerPaymentInstrumentBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentBadRequest %s", 400, payload)
}

func (o *PostCustomerPaymentInstrumentBadRequest) GetPayload() *PostCustomerPaymentInstrumentBadRequestBody {
	return o.Payload
}

func (o *PostCustomerPaymentInstrumentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PostCustomerPaymentInstrumentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostCustomerPaymentInstrumentForbidden creates a PostCustomerPaymentInstrumentForbidden with default headers values
func NewPostCustomerPaymentInstrumentForbidden() *PostCustomerPaymentInstrumentForbidden {
	return &PostCustomerPaymentInstrumentForbidden{}
}

/*
PostCustomerPaymentInstrumentForbidden describes a response with status code 403, with default header values.

Forbidden: e.g. The profile might not have permission to perform the operation.
*/
type PostCustomerPaymentInstrumentForbidden struct {

	/* A globally unique Id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation Id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PostCustomerPaymentInstrumentForbiddenBody
}

// IsSuccess returns true when this post customer payment instrument forbidden response has a 2xx status code
func (o *PostCustomerPaymentInstrumentForbidden) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this post customer payment instrument forbidden response has a 3xx status code
func (o *PostCustomerPaymentInstrumentForbidden) IsRedirect() bool {
	return false
}

// IsClientError returns true when this post customer payment instrument forbidden response has a 4xx status code
func (o *PostCustomerPaymentInstrumentForbidden) IsClientError() bool {
	return true
}

// IsServerError returns true when this post customer payment instrument forbidden response has a 5xx status code
func (o *PostCustomerPaymentInstrumentForbidden) IsServerError() bool {
	return false
}

// IsCode returns true when this post customer payment instrument forbidden response a status code equal to that given
func (o *PostCustomerPaymentInstrumentForbidden) IsCode(code int) bool {
	return code == 403
}

// Code gets the status code for the post customer payment instrument forbidden response
func (o *PostCustomerPaymentInstrumentForbidden) Code() int {
	return 403
}

func (o *PostCustomerPaymentInstrumentForbidden) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentForbidden %s", 403, payload)
}

func (o *PostCustomerPaymentInstrumentForbidden) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentForbidden %s", 403, payload)
}

func (o *PostCustomerPaymentInstrumentForbidden) GetPayload() *PostCustomerPaymentInstrumentForbiddenBody {
	return o.Payload
}

func (o *PostCustomerPaymentInstrumentForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PostCustomerPaymentInstrumentForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostCustomerPaymentInstrumentConflict creates a PostCustomerPaymentInstrumentConflict with default headers values
func NewPostCustomerPaymentInstrumentConflict() *PostCustomerPaymentInstrumentConflict {
	return &PostCustomerPaymentInstrumentConflict{}
}

/*
PostCustomerPaymentInstrumentConflict describes a response with status code 409, with default header values.

Conflict. The token is linked to a Payment Instrument.
*/
type PostCustomerPaymentInstrumentConflict struct {

	/* A globally unique Id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation Id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PostCustomerPaymentInstrumentConflictBody
}

// IsSuccess returns true when this post customer payment instrument conflict response has a 2xx status code
func (o *PostCustomerPaymentInstrumentConflict) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this post customer payment instrument conflict response has a 3xx status code
func (o *PostCustomerPaymentInstrumentConflict) IsRedirect() bool {
	return false
}

// IsClientError returns true when this post customer payment instrument conflict response has a 4xx status code
func (o *PostCustomerPaymentInstrumentConflict) IsClientError() bool {
	return true
}

// IsServerError returns true when this post customer payment instrument conflict response has a 5xx status code
func (o *PostCustomerPaymentInstrumentConflict) IsServerError() bool {
	return false
}

// IsCode returns true when this post customer payment instrument conflict response a status code equal to that given
func (o *PostCustomerPaymentInstrumentConflict) IsCode(code int) bool {
	return code == 409
}

// Code gets the status code for the post customer payment instrument conflict response
func (o *PostCustomerPaymentInstrumentConflict) Code() int {
	return 409
}

func (o *PostCustomerPaymentInstrumentConflict) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentConflict %s", 409, payload)
}

func (o *PostCustomerPaymentInstrumentConflict) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentConflict %s", 409, payload)
}

func (o *PostCustomerPaymentInstrumentConflict) GetPayload() *PostCustomerPaymentInstrumentConflictBody {
	return o.Payload
}

func (o *PostCustomerPaymentInstrumentConflict) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PostCustomerPaymentInstrumentConflictBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostCustomerPaymentInstrumentFailedDependency creates a PostCustomerPaymentInstrumentFailedDependency with default headers values
func NewPostCustomerPaymentInstrumentFailedDependency() *PostCustomerPaymentInstrumentFailedDependency {
	return &PostCustomerPaymentInstrumentFailedDependency{}
}

/*
PostCustomerPaymentInstrumentFailedDependency describes a response with status code 424, with default header values.

Failed Dependency: e.g. The profile represented by the profile-id may not exist or the profile-id was entered incorrectly.
*/
type PostCustomerPaymentInstrumentFailedDependency struct {

	/* A globally unique Id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation Id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PostCustomerPaymentInstrumentFailedDependencyBody
}

// IsSuccess returns true when this post customer payment instrument failed dependency response has a 2xx status code
func (o *PostCustomerPaymentInstrumentFailedDependency) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this post customer payment instrument failed dependency response has a 3xx status code
func (o *PostCustomerPaymentInstrumentFailedDependency) IsRedirect() bool {
	return false
}

// IsClientError returns true when this post customer payment instrument failed dependency response has a 4xx status code
func (o *PostCustomerPaymentInstrumentFailedDependency) IsClientError() bool {
	return true
}

// IsServerError returns true when this post customer payment instrument failed dependency response has a 5xx status code
func (o *PostCustomerPaymentInstrumentFailedDependency) IsServerError() bool {
	return false
}

// IsCode returns true when this post customer payment instrument failed dependency response a status code equal to that given
func (o *PostCustomerPaymentInstrumentFailedDependency) IsCode(code int) bool {
	return code == 424
}

// Code gets the status code for the post customer payment instrument failed dependency response
func (o *PostCustomerPaymentInstrumentFailedDependency) Code() int {
	return 424
}

func (o *PostCustomerPaymentInstrumentFailedDependency) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentFailedDependency %s", 424, payload)
}

func (o *PostCustomerPaymentInstrumentFailedDependency) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentFailedDependency %s", 424, payload)
}

func (o *PostCustomerPaymentInstrumentFailedDependency) GetPayload() *PostCustomerPaymentInstrumentFailedDependencyBody {
	return o.Payload
}

func (o *PostCustomerPaymentInstrumentFailedDependency) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PostCustomerPaymentInstrumentFailedDependencyBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostCustomerPaymentInstrumentInternalServerError creates a PostCustomerPaymentInstrumentInternalServerError with default headers values
func NewPostCustomerPaymentInstrumentInternalServerError() *PostCustomerPaymentInstrumentInternalServerError {
	return &PostCustomerPaymentInstrumentInternalServerError{}
}

/*
PostCustomerPaymentInstrumentInternalServerError describes a response with status code 500, with default header values.

Unexpected error.
*/
type PostCustomerPaymentInstrumentInternalServerError struct {

	/* A globally unique Id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation Id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PostCustomerPaymentInstrumentInternalServerErrorBody
}

// IsSuccess returns true when this post customer payment instrument internal server error response has a 2xx status code
func (o *PostCustomerPaymentInstrumentInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this post customer payment instrument internal server error response has a 3xx status code
func (o *PostCustomerPaymentInstrumentInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this post customer payment instrument internal server error response has a 4xx status code
func (o *PostCustomerPaymentInstrumentInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this post customer payment instrument internal server error response has a 5xx status code
func (o *PostCustomerPaymentInstrumentInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this post customer payment instrument internal server error response a status code equal to that given
func (o *PostCustomerPaymentInstrumentInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the post customer payment instrument internal server error response
func (o *PostCustomerPaymentInstrumentInternalServerError) Code() int {
	return 500
}

func (o *PostCustomerPaymentInstrumentInternalServerError) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentInternalServerError %s", 500, payload)
}

func (o *PostCustomerPaymentInstrumentInternalServerError) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /tms/v2/customers/{customerId}/payment-instruments][%d] postCustomerPaymentInstrumentInternalServerError %s", 500, payload)
}

func (o *PostCustomerPaymentInstrumentInternalServerError) GetPayload() *PostCustomerPaymentInstrumentInternalServerErrorBody {
	return o.Payload
}

func (o *PostCustomerPaymentInstrumentInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PostCustomerPaymentInstrumentInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
PostCustomerPaymentInstrumentBadRequestBody post customer payment instrument bad request body
swagger:model PostCustomerPaymentInstrumentBadRequestBody
*/
type PostCustomerPaymentInstrumentBadRequestBody struct {

	// errors
	// Read Only: true
	Errors []*PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0 `json:"errors"`
}

// Validate validates this post customer payment instrument bad request body
func (o *PostCustomerPaymentInstrumentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument bad request body based on the context it is used
func (o *PostCustomerPaymentInstrumentBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentBadRequest"+"."+"errors", "body", []*PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {

			if swag.IsZero(o.Errors[i]) { // not required
				return nil
			}

			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0 post customer payment instrument bad request body errors items0
swagger:model PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0
*/
type PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	//
	// Possible Values:
	//   - invalidHeaders
	//   - missingHeaders
	//   - invalidFields
	//   - missingFields
	//   - unsupportedPaymentMethodModification
	//   - invalidCombination
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument bad request body errors items0
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument bad request body errors items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0 post customer payment instrument bad request body errors items0 details items0
swagger:model PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0
*/
type PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this post customer payment instrument bad request body errors items0 details items0
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument bad request body errors items0 details items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentBody post customer payment instrument body
swagger:model PostCustomerPaymentInstrumentBody
*/
type PostCustomerPaymentInstrumentBody struct {

	// embedded
	Embedded *PostCustomerPaymentInstrumentParamsBodyEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PostCustomerPaymentInstrumentParamsBodyLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PostCustomerPaymentInstrumentParamsBodyBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PostCustomerPaymentInstrumentParamsBodyBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PostCustomerPaymentInstrumentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PostCustomerPaymentInstrumentParamsBodyCard `json:"card,omitempty"`

	// Flag that indicates whether customer payment instrument is the dafault.
	// Possible Values:
	//  - `true`: Payment instrument is customer's default.
	//  - `false`: Payment instrument is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The Id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PostCustomerPaymentInstrumentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *PostCustomerPaymentInstrumentParamsBodyMetadata `json:"metadata,omitempty"`

	// The type.
	//
	// Possible Values:
	// - paymentInstrument
	//
	// Example: paymentInstrument
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PostCustomerPaymentInstrumentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Possible Values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// The type of Payment Instrument.
	// Possible Values:
	// - cardHash
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument body
func (o *PostCustomerPaymentInstrumentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentRequest"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument body based on the context it is used
func (o *PostCustomerPaymentInstrumentBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {

		if swag.IsZero(o.Embedded) { // not required
			return nil
		}

		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {

		if swag.IsZero(o.BankAccount) { // not required
			return nil
		}

		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {

		if swag.IsZero(o.BuyerInformation) { // not required
			return nil
		}

		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {

		if swag.IsZero(o.InstrumentIdentifier) { // not required
			return nil
		}

		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {

		if swag.IsZero(o.MerchantInformation) { // not required
			return nil
		}

		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {

		if swag.IsZero(o.Metadata) { // not required
			return nil
		}

		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentBody) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentBody) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentConflictBody post customer payment instrument conflict body
swagger:model PostCustomerPaymentInstrumentConflictBody
*/
type PostCustomerPaymentInstrumentConflictBody struct {

	// errors
	// Read Only: true
	Errors []*PostCustomerPaymentInstrumentConflictBodyErrorsItems0 `json:"errors"`
}

// Validate validates this post customer payment instrument conflict body
func (o *PostCustomerPaymentInstrumentConflictBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentConflictBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentConflict" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentConflict" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument conflict body based on the context it is used
func (o *PostCustomerPaymentInstrumentConflictBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentConflictBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentConflict"+"."+"errors", "body", []*PostCustomerPaymentInstrumentConflictBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {

			if swag.IsZero(o.Errors[i]) { // not required
				return nil
			}

			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentConflict" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentConflict" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentConflictBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentConflictBody) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentConflictBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentConflictBodyErrorsItems0 post customer payment instrument conflict body errors items0
swagger:model PostCustomerPaymentInstrumentConflictBodyErrorsItems0
*/
type PostCustomerPaymentInstrumentConflictBodyErrorsItems0 struct {

	// The detailed message related to the type.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	//
	// Possible Values:
	//   - instrumentIdentifierDeletionError
	//   - tokenIdConflict
	//   - conflict
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument conflict body errors items0
func (o *PostCustomerPaymentInstrumentConflictBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument conflict body errors items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentConflictBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentConflictBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentConflictBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentConflictBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentConflictBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentConflictBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBody post customer payment instrument created body
swagger:model PostCustomerPaymentInstrumentCreatedBody
*/
type PostCustomerPaymentInstrumentCreatedBody struct {

	// embedded
	Embedded *PostCustomerPaymentInstrumentCreatedBodyEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PostCustomerPaymentInstrumentCreatedBodyLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PostCustomerPaymentInstrumentCreatedBodyBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PostCustomerPaymentInstrumentCreatedBodyBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PostCustomerPaymentInstrumentCreatedBodyCard `json:"card,omitempty"`

	// Flag that indicates whether customer payment instrument is the dafault.
	// Possible Values:
	//  - `true`: Payment instrument is customer's default.
	//  - `false`: Payment instrument is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The Id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PostCustomerPaymentInstrumentCreatedBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *PostCustomerPaymentInstrumentCreatedBodyMetadata `json:"metadata,omitempty"`

	// The type.
	//
	// Possible Values:
	// - paymentInstrument
	//
	// Example: paymentInstrument
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PostCustomerPaymentInstrumentCreatedBodyProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Possible Values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// The type of Payment Instrument.
	// Possible Values:
	// - cardHash
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument created body
func (o *PostCustomerPaymentInstrumentCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentCreated"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {

		if swag.IsZero(o.Embedded) { // not required
			return nil
		}

		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {

		if swag.IsZero(o.BankAccount) { // not required
			return nil
		}

		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {

		if swag.IsZero(o.BuyerInformation) { // not required
			return nil
		}

		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {

		if swag.IsZero(o.InstrumentIdentifier) { // not required
			return nil
		}

		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {

		if swag.IsZero(o.MerchantInformation) { // not required
			return nil
		}

		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {

		if swag.IsZero(o.Metadata) { // not required
			return nil
		}

		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBody) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBody) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyBankAccount post customer payment instrument created body bank account
swagger:model PostCustomerPaymentInstrumentCreatedBodyBankAccount
*/
type PostCustomerPaymentInstrumentCreatedBodyBankAccount struct {

	// Account type.
	//
	// Possible Values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 18
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument created body bank account
func (o *PostCustomerPaymentInstrumentCreatedBodyBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"bankAccount"+"."+"type", "body", o.Type, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body bank account based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBankAccount) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyBillTo post customer payment instrument created body bill to
swagger:model PostCustomerPaymentInstrumentCreatedBodyBillTo
*/
type PostCustomerPaymentInstrumentCreatedBodyBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer's records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customer's company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customer's first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer's last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer's phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this post customer payment instrument created body bill to
func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body bill to based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBillTo) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyBuyerInformation post customer payment instrument created body buyer information
swagger:model PostCustomerPaymentInstrumentCreatedBodyBuyerInformation
*/
type PostCustomerPaymentInstrumentCreatedBodyBuyerInformation struct {

	// Company's tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Example: 1960-12-30
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this post customer payment instrument created body buyer information
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"buyerInformation"+"."+"companyTaxID", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"buyerInformation"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("postCustomerPaymentInstrumentCreated"+"."+"buyerInformation"+"."+"dateOfBirth", "body", "date", o.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body buyer information based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {

			if swag.IsZero(o.PersonalIdentification[i]) { // not required
				return nil
			}

			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0 post customer payment instrument created body buyer information personal identification items0
swagger:model PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0
*/
type PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Possible Values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument created body buyer information personal identification items0
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuedBy) { // not required
		return nil
	}

	if o.IssuedBy != nil {
		if err := o.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body buyer information personal identification items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuedBy != nil {

		if swag.IsZero(o.IssuedBy) { // not required
			return nil
		}

		if err := o.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy post customer payment instrument created body buyer information personal identification items0 issued by
swagger:model PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy
*/
type PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customer's driver's license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this post customer payment instrument created body buyer information personal identification items0 issued by
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body buyer information personal identification items0 issued by based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyCard post customer payment instrument created body card
swagger:model PostCustomerPaymentInstrumentCreatedBodyCard
*/
type PostCustomerPaymentInstrumentCreatedBodyCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Hash value representing the card.
	//
	// Read Only: true
	// Max Length: 34
	// Min Length: 32
	Hash string `json:"hash,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Possible Values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Possible Values v2 : v1:
	//   * 001 : visa
	//   * 002 : mastercard - Eurocard—European regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue — formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard — supported only by the Comercio Latino processor.
	//   * 051 : aura — supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo — supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this post customer payment instrument created body card
func (o *PostCustomerPaymentInstrumentCreatedBodyCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHash(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) validateHash(formats strfmt.Registry) error {
	if swag.IsZero(o.Hash) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"hash", "body", o.Hash, 32); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"hash", "body", o.Hash, 34); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) validateTokenizedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedInformation) { // not required
		return nil
	}

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body card based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHash(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) contextValidateHash(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"hash", "body", string(o.Hash)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCard) contextValidateTokenizedInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedInformation != nil {

		if swag.IsZero(o.TokenizedInformation) { // not required
			return nil
		}

		if err := o.TokenizedInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation post customer payment instrument created body card tokenized information
swagger:model PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation
*/
type PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholder's account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service provider's database.
	//
	// **Note** This field is supported only through **VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customer's mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this post customer payment instrument created body card tokenized information
func (o *PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"tokenizedInformation"+"."+"requestorID", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"card"+"."+"tokenizedInformation"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body card tokenized information based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyCardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbedded Additional resources for the Payment Instrument.
//
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbedded
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbedded struct {

	// instrument identifier
	InstrumentIdentifier *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbedded) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbedded) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {

		if swag.IsZero(o.InstrumentIdentifier) { // not required
			return nil
		}

		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbedded) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier tmsEmbeddedInstrumentIdentifier
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier struct {

	// links
	Links *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The Id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type.
	//
	// Possible Values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Possible Values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// token provisioning information
	TokenProvisioningInformation *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation `json:"tokenProvisioningInformation,omitempty"`

	// tokenized card
	TokenizedCard *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Possible Values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenProvisioningInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateTokenProvisioningInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenProvisioningInformation) { // not required
		return nil
	}

	if o.TokenProvisioningInformation != nil {
		if err := o.TokenProvisioningInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenProvisioningInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {

		if swag.IsZero(o.BankAccount) { // not required
			return nil
		}

		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {

		if swag.IsZero(o.Issuer) { // not required
			return nil
		}

		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {

		if swag.IsZero(o.Metadata) { // not required
			return nil
		}

		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateTokenProvisioningInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenProvisioningInformation != nil {

		if swag.IsZero(o.TokenProvisioningInformation) { // not required
			return nil
		}

		if err := o.TokenProvisioningInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {

		if swag.IsZero(o.TokenizedCard) { // not required
			return nil
		}

		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount post customer payment instrument created body embedded instrument identifier bank account
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier bank account
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body embedded instrument identifier bank account based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier.
//
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer's records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier bill to
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body embedded instrument identifier bill to based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier.
//
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer's payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Code.
	// This value is sent to the issuer to support the approval of a network token provision.
	// It is not persisted against the Instrument Identifier.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier card
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 19); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body embedded instrument identifier card based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer post customer payment instrument created body embedded instrument identifier issuer
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier issuer
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", o.PaymentAccountReference, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier issuer based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentAccountReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer) contextValidatePaymentAccountReference(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(o.PaymentAccountReference)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks post customer payment instrument created body embedded instrument identifier links
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier links
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier links based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {

		if swag.IsZero(o.PaymentInstruments) { // not required
			return nil
		}

		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments post customer payment instrument created body embedded instrument identifier links payment instruments
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Example: tms/v1/instrumentidentifiers/7010000000016241111/paymentinstruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier links payment instruments
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier links payment instruments based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf post customer payment instrument created body embedded instrument identifier links self
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Example: tms/v1/instrumentidentifiers/7010000000016241111
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier links self
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier links self based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata post customer payment instrument created body embedded instrument identifier metadata
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier metadata
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier metadata based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation post customer payment instrument created body embedded instrument identifier processing information
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier processing information
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier processing information based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {

		if swag.IsZero(o.AuthorizationOptions) { // not required
			return nil
		}

		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions tmsAuthorizationOptions
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier processing information authorization options
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier processing information authorization options based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {

		if swag.IsZero(o.Initiator) { // not required
			return nil
		}

		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator post customer payment instrument created body embedded instrument identifier processing information authorization options initiator
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier processing information authorization options initiator
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier processing information authorization options initiator based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {

		if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
			return nil
		}

		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction post customer payment instrument created body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Amount of the original authorization.
	//
	// Max Length: 15
	OriginalAuthorizedAmount string `json:"originalAuthorizedAmount,omitempty"`

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateOriginalAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validateOriginalAuthorizedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalAuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"originalAuthorizedAmount", "body", o.OriginalAuthorizedAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body embedded instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation post customer payment instrument created body embedded instrument identifier token provisioning information
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation struct {

	// Flag that indicates whether the user consented to the tokenization of their credentials. Required for card network tokenization in certain markets, such as India.
	// Possible Values:
	// - `true`: Consumer has consented to tokenization of their credentials.
	// - `false`: Consumer has not consented to tokenization of their credentials.
	//
	ConsumerConsentObtained bool `json:"consumerConsentObtained,omitempty"`

	// Flag that indicates whether AFA (Additional Factor of Authentication) for the PAN was completed. Required for card network tokenization in certain markets, such as India.
	// Possible Values:
	// - `true`: Consumer has been authenticated by the issuer.
	// - `false`: Consumer has not been authenticated by the issuer.
	//
	MultiFactorAuthenticated bool `json:"multiFactorAuthenticated,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier token provisioning information
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this post customer payment instrument created body embedded instrument identifier token provisioning information based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard post customer payment instrument created body embedded instrument identifier tokenized card
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Example: CgAFRFYFPTFOfg5rj2ais9wQAAAAAM=
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Unique Identifier for the enrolled PAN. This Id is provided by the card association when a network token is provisioned successfully.
	//
	// Read Only: true
	EnrollmentID string `json:"enrollmentId,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Possible Values:
	// - INVALID_REQUEST : The network token provision request contained invalid data.
	// - CARD_VERIFICATION_FAILED : The network token provision request contained data that could not be verified.
	// - CARD_NOT_ELIGIBLE : Card can currently not be used with issuer for tokenization.
	// - CARD_NOT_ALLOWED : Card can currently not be used with card association for tokenization.
	// - DECLINED : Card can currently not be used with issuer for tokenization.
	// - SERVICE_UNAVAILABLE : The network token service was unavailable or timed out.
	// - SYSTEM_ERROR : An unexpected error occurred with network token service, check configuration.
	//
	// Example: ACTIVE
	// Read Only: true
	Reason string `json:"reason,omitempty"`

	// State of the network token or network token provision
	// Possible Values:
	// - ACTIVE : Network token is active.
	// - SUSPENDED : Network token is suspended. This state can change back to ACTIVE.
	// - DELETED : This is a final state for a network token instance.
	// - UNPROVISIONED : A previous network token provision was unsuccessful.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// Unique Identifier for the network token. This Id is provided by the card association when a network token is provisioned successfully.
	//
	// Read Only: true
	TokenReferenceID string `json:"tokenReferenceId,omitempty"`

	// The network token card association brand
	// Possible Values:
	// - visa
	// - mastercard
	// - americanexpress
	//
	// Example: visa
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier tokenized card
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier tokenized card based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCryptogram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateEnrollmentID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenReferenceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCryptogram(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateEnrollmentID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"enrollmentId", "body", string(o.EnrollmentID)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateReason(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"reason", "body", string(o.Reason)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateTokenReferenceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"tokenReferenceId", "body", string(o.TokenReferenceID)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
swagger:model PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard
*/
type PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customer's latest payment card expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customer's latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer's latest payment card number suffix
	//
	// Example: 1111
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this post customer payment instrument created body embedded instrument identifier tokenized card card
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body embedded instrument identifier tokenized card card based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSuffix(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateSuffix(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"suffix", "body", string(o.Suffix)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyEmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier post customer payment instrument created body instrument identifier
swagger:model PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier
*/
type PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier struct {

	// The Id of the Instrument Identifier linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this post customer payment instrument created body instrument identifier
func (o *PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentCreated"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body instrument identifier based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyLinks post customer payment instrument created body links
swagger:model PostCustomerPaymentInstrumentCreatedBodyLinks
*/
type PostCustomerPaymentInstrumentCreatedBodyLinks struct {

	// customer
	Customer *PostCustomerPaymentInstrumentCreatedBodyLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PostCustomerPaymentInstrumentCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this post customer payment instrument created body links
func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body links based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {

		if swag.IsZero(o.Customer) { // not required
			return nil
		}

		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyLinksCustomer post customer payment instrument created body links customer
swagger:model PostCustomerPaymentInstrumentCreatedBodyLinksCustomer
*/
type PostCustomerPaymentInstrumentCreatedBodyLinksCustomer struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/D9F340DD3DB9C276E053A2598D0A41A3
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument created body links customer
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument created body links customer based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyLinksSelf post customer payment instrument created body links self
swagger:model PostCustomerPaymentInstrumentCreatedBodyLinksSelf
*/
type PostCustomerPaymentInstrumentCreatedBodyLinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Example: /tms/v2/customers/D9F340DD3DB9C276E053A2598D0A41A3/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument created body links self
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument created body links self based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyMerchantInformation post customer payment instrument created body merchant information
swagger:model PostCustomerPaymentInstrumentCreatedBodyMerchantInformation
*/
type PostCustomerPaymentInstrumentCreatedBodyMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this post customer payment instrument created body merchant information
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body merchant information based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {

		if swag.IsZero(o.MerchantDescriptor) { // not required
			return nil
		}

		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor post customer payment instrument created body merchant information merchant descriptor
swagger:model PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor
*/
type PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholder's statement.
	// When you do not include this value in your capture or credit request, the merchant URL from your CyberSource account is used.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this post customer payment instrument created body merchant information merchant descriptor
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body merchant information merchant descriptor based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyMetadata post customer payment instrument created body metadata
swagger:model PostCustomerPaymentInstrumentCreatedBodyMetadata
*/
type PostCustomerPaymentInstrumentCreatedBodyMetadata struct {

	// The creator of the Payment Instrument.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this post customer payment instrument created body metadata
func (o *PostCustomerPaymentInstrumentCreatedBodyMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument created body metadata based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentCreated"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyMetadata) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyProcessingInformation tmsPaymentInstrumentProcessingInfo
swagger:model PostCustomerPaymentInstrumentCreatedBodyProcessingInformation
*/
type PostCustomerPaymentInstrumentCreatedBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Possible Values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this post customer payment instrument created body processing information
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument created body processing information based on the context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {

		if swag.IsZero(o.BankTransferOptions) { // not required
			return nil
		}

		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions post customer payment instrument created body processing information bank transfer options
swagger:model PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions
*/
type PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Possible Values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this post customer payment instrument created body processing information bank transfer options
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentCreated"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", o.SECCode, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument created body processing information bank transfer options based on context it is used
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentCreatedBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentFailedDependencyBody post customer payment instrument failed dependency body
swagger:model PostCustomerPaymentInstrumentFailedDependencyBody
*/
type PostCustomerPaymentInstrumentFailedDependencyBody struct {

	// errors
	// Read Only: true
	Errors []*PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0 `json:"errors"`
}

// Validate validates this post customer payment instrument failed dependency body
func (o *PostCustomerPaymentInstrumentFailedDependencyBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentFailedDependencyBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument failed dependency body based on the context it is used
func (o *PostCustomerPaymentInstrumentFailedDependencyBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentFailedDependencyBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentFailedDependency"+"."+"errors", "body", []*PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {

			if swag.IsZero(o.Errors[i]) { // not required
				return nil
			}

			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentFailedDependencyBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentFailedDependencyBody) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentFailedDependencyBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0 post customer payment instrument failed dependency body errors items0
swagger:model PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0
*/
type PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0 struct {

	// The detailed message related to the type.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	//
	// Possible Values:
	//   - notFound
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument failed dependency body errors items0
func (o *PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument failed dependency body errors items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentFailedDependencyBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentForbiddenBody post customer payment instrument forbidden body
swagger:model PostCustomerPaymentInstrumentForbiddenBody
*/
type PostCustomerPaymentInstrumentForbiddenBody struct {

	// errors
	// Read Only: true
	Errors []*PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0 `json:"errors"`
}

// Validate validates this post customer payment instrument forbidden body
func (o *PostCustomerPaymentInstrumentForbiddenBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentForbiddenBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument forbidden body based on the context it is used
func (o *PostCustomerPaymentInstrumentForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentForbiddenBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentForbidden"+"."+"errors", "body", []*PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {

			if swag.IsZero(o.Errors[i]) { // not required
				return nil
			}

			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentForbiddenBody) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0 post customer payment instrument forbidden body errors items0
swagger:model PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0
*/
type PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0 struct {

	// The detailed message related to the type.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	//
	// Possible Values:
	//   - forbidden
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument forbidden body errors items0
func (o *PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument forbidden body errors items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentForbiddenBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentInternalServerErrorBody post customer payment instrument internal server error body
swagger:model PostCustomerPaymentInstrumentInternalServerErrorBody
*/
type PostCustomerPaymentInstrumentInternalServerErrorBody struct {

	// errors
	// Read Only: true
	Errors []*PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0 `json:"errors"`
}

// Validate validates this post customer payment instrument internal server error body
func (o *PostCustomerPaymentInstrumentInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentInternalServerErrorBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument internal server error body based on the context it is used
func (o *PostCustomerPaymentInstrumentInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentInternalServerErrorBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentInternalServerError"+"."+"errors", "body", []*PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {

			if swag.IsZero(o.Errors[i]) { // not required
				return nil
			}

			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0 post customer payment instrument internal server error body errors items0
swagger:model PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0
*/
type PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0 struct {

	// The detailed message related to the type.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	//
	// Possible Values:
	//   - internalError
	//
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument internal server error body errors items0
func (o *PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument internal server error body errors items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentInternalServerErrorBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyBankAccount post customer payment instrument params body bank account
swagger:model PostCustomerPaymentInstrumentParamsBodyBankAccount
*/
type PostCustomerPaymentInstrumentParamsBodyBankAccount struct {

	// Account type.
	//
	// Possible Values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 18
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument params body bank account
func (o *PostCustomerPaymentInstrumentParamsBodyBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"bankAccount"+"."+"type", "body", o.Type, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body bank account based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBankAccount) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyBillTo post customer payment instrument params body bill to
swagger:model PostCustomerPaymentInstrumentParamsBodyBillTo
*/
type PostCustomerPaymentInstrumentParamsBodyBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer's records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customer's company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customer's first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer's last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer's phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this post customer payment instrument params body bill to
func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body bill to based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBillTo) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyBuyerInformation post customer payment instrument params body buyer information
swagger:model PostCustomerPaymentInstrumentParamsBodyBuyerInformation
*/
type PostCustomerPaymentInstrumentParamsBodyBuyerInformation struct {

	// Company's tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Example: 1960-12-30
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this post customer payment instrument params body buyer information
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"buyerInformation"+"."+"companyTaxID", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"buyerInformation"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("postCustomerPaymentInstrumentRequest"+"."+"buyerInformation"+"."+"dateOfBirth", "body", "date", o.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body buyer information based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {

			if swag.IsZero(o.PersonalIdentification[i]) { // not required
				return nil
			}

			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0 post customer payment instrument params body buyer information personal identification items0
swagger:model PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0
*/
type PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Possible Values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument params body buyer information personal identification items0
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuedBy) { // not required
		return nil
	}

	if o.IssuedBy != nil {
		if err := o.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body buyer information personal identification items0 based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuedBy != nil {

		if swag.IsZero(o.IssuedBy) { // not required
			return nil
		}

		if err := o.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy post customer payment instrument params body buyer information personal identification items0 issued by
swagger:model PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy
*/
type PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customer's driver's license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this post customer payment instrument params body buyer information personal identification items0 issued by
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body buyer information personal identification items0 issued by based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyCard post customer payment instrument params body card
swagger:model PostCustomerPaymentInstrumentParamsBodyCard
*/
type PostCustomerPaymentInstrumentParamsBodyCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Hash value representing the card.
	//
	// Read Only: true
	// Max Length: 34
	// Min Length: 32
	Hash string `json:"hash,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Possible Values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Possible Values v2 : v1:
	//   * 001 : visa
	//   * 002 : mastercard - Eurocard—European regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue — formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard — supported only by the Comercio Latino processor.
	//   * 051 : aura — supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo — supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this post customer payment instrument params body card
func (o *PostCustomerPaymentInstrumentParamsBodyCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHash(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) validateHash(formats strfmt.Registry) error {
	if swag.IsZero(o.Hash) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"hash", "body", o.Hash, 32); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"hash", "body", o.Hash, 34); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) validateTokenizedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedInformation) { // not required
		return nil
	}

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body card based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHash(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) contextValidateHash(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"hash", "body", string(o.Hash)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCard) contextValidateTokenizedInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedInformation != nil {

		if swag.IsZero(o.TokenizedInformation) { // not required
			return nil
		}

		if err := o.TokenizedInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation post customer payment instrument params body card tokenized information
swagger:model PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation
*/
type PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholder's account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service provider's database.
	//
	// **Note** This field is supported only through **VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customer's mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this post customer payment instrument params body card tokenized information
func (o *PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"tokenizedInformation"+"."+"requestorID", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"card"+"."+"tokenizedInformation"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body card tokenized information based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyCardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbedded Additional resources for the Payment Instrument.
//
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbedded
*/
type PostCustomerPaymentInstrumentParamsBodyEmbedded struct {

	// instrument identifier
	InstrumentIdentifier *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded
func (o *PostCustomerPaymentInstrumentParamsBodyEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbedded) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbedded) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {

		if swag.IsZero(o.InstrumentIdentifier) { // not required
			return nil
		}

		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbedded) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier tmsEmbeddedInstrumentIdentifier
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier struct {

	// links
	Links *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The Id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type.
	//
	// Possible Values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Possible Values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// token provisioning information
	TokenProvisioningInformation *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation `json:"tokenProvisioningInformation,omitempty"`

	// tokenized card
	TokenizedCard *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Possible Values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenProvisioningInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateTokenProvisioningInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenProvisioningInformation) { // not required
		return nil
	}

	if o.TokenProvisioningInformation != nil {
		if err := o.TokenProvisioningInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenProvisioningInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {

		if swag.IsZero(o.BankAccount) { // not required
			return nil
		}

		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {

		if swag.IsZero(o.Issuer) { // not required
			return nil
		}

		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {

		if swag.IsZero(o.Metadata) { // not required
			return nil
		}

		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateTokenProvisioningInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenProvisioningInformation != nil {

		if swag.IsZero(o.TokenProvisioningInformation) { // not required
			return nil
		}

		if err := o.TokenProvisioningInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenProvisioningInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {

		if swag.IsZero(o.TokenizedCard) { // not required
			return nil
		}

		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount post customer payment instrument params body embedded instrument identifier bank account
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier bank account
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body embedded instrument identifier bank account based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier.
//
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer's records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier bill to
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body embedded instrument identifier bill to based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier.
//
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer's payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Code.
	// This value is sent to the issuer to support the approval of a network token provision.
	// It is not persisted against the Instrument Identifier.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier card
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 19); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body embedded instrument identifier card based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer post customer payment instrument params body embedded instrument identifier issuer
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier issuer
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", o.PaymentAccountReference, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier issuer based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentAccountReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) contextValidatePaymentAccountReference(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(o.PaymentAccountReference)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks post customer payment instrument params body embedded instrument identifier links
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier links
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier links based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {

		if swag.IsZero(o.PaymentInstruments) { // not required
			return nil
		}

		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments post customer payment instrument params body embedded instrument identifier links payment instruments
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Example: tms/v1/instrumentidentifiers/7010000000016241111/paymentinstruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier links payment instruments
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier links payment instruments based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf post customer payment instrument params body embedded instrument identifier links self
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Example: tms/v1/instrumentidentifiers/7010000000016241111
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier links self
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier links self based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata post customer payment instrument params body embedded instrument identifier metadata
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier metadata
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier metadata based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation post customer payment instrument params body embedded instrument identifier processing information
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier processing information
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier processing information based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {

		if swag.IsZero(o.AuthorizationOptions) { // not required
			return nil
		}

		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions tmsAuthorizationOptions
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier processing information authorization options
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier processing information authorization options based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {

		if swag.IsZero(o.Initiator) { // not required
			return nil
		}

		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator post customer payment instrument params body embedded instrument identifier processing information authorization options initiator
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier processing information authorization options initiator
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier processing information authorization options initiator based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {

		if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
			return nil
		}

		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction post customer payment instrument params body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Amount of the original authorization.
	//
	// Max Length: 15
	OriginalAuthorizedAmount string `json:"originalAuthorizedAmount,omitempty"`

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateOriginalAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validateOriginalAuthorizedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalAuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"originalAuthorizedAmount", "body", o.OriginalAuthorizedAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body embedded instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation post customer payment instrument params body embedded instrument identifier token provisioning information
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation struct {

	// Flag that indicates whether the user consented to the tokenization of their credentials. Required for card network tokenization in certain markets, such as India.
	// Possible Values:
	// - `true`: Consumer has consented to tokenization of their credentials.
	// - `false`: Consumer has not consented to tokenization of their credentials.
	//
	ConsumerConsentObtained bool `json:"consumerConsentObtained,omitempty"`

	// Flag that indicates whether AFA (Additional Factor of Authentication) for the PAN was completed. Required for card network tokenization in certain markets, such as India.
	// Possible Values:
	// - `true`: Consumer has been authenticated by the issuer.
	// - `false`: Consumer has not been authenticated by the issuer.
	//
	MultiFactorAuthenticated bool `json:"multiFactorAuthenticated,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier token provisioning information
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this post customer payment instrument params body embedded instrument identifier token provisioning information based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenProvisioningInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard post customer payment instrument params body embedded instrument identifier tokenized card
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Example: CgAFRFYFPTFOfg5rj2ais9wQAAAAAM=
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Unique Identifier for the enrolled PAN. This Id is provided by the card association when a network token is provisioned successfully.
	//
	// Read Only: true
	EnrollmentID string `json:"enrollmentId,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Possible Values:
	// - INVALID_REQUEST : The network token provision request contained invalid data.
	// - CARD_VERIFICATION_FAILED : The network token provision request contained data that could not be verified.
	// - CARD_NOT_ELIGIBLE : Card can currently not be used with issuer for tokenization.
	// - CARD_NOT_ALLOWED : Card can currently not be used with card association for tokenization.
	// - DECLINED : Card can currently not be used with issuer for tokenization.
	// - SERVICE_UNAVAILABLE : The network token service was unavailable or timed out.
	// - SYSTEM_ERROR : An unexpected error occurred with network token service, check configuration.
	//
	// Example: ACTIVE
	// Read Only: true
	Reason string `json:"reason,omitempty"`

	// State of the network token or network token provision
	// Possible Values:
	// - ACTIVE : Network token is active.
	// - SUSPENDED : Network token is suspended. This state can change back to ACTIVE.
	// - DELETED : This is a final state for a network token instance.
	// - UNPROVISIONED : A previous network token provision was unsuccessful.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// Unique Identifier for the network token. This Id is provided by the card association when a network token is provisioned successfully.
	//
	// Read Only: true
	TokenReferenceID string `json:"tokenReferenceId,omitempty"`

	// The network token card association brand
	// Possible Values:
	// - visa
	// - mastercard
	// - americanexpress
	//
	// Example: visa
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier tokenized card
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier tokenized card based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCryptogram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateEnrollmentID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateReason(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenReferenceID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCryptogram(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateEnrollmentID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"enrollmentId", "body", string(o.EnrollmentID)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateReason(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"reason", "body", string(o.Reason)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateTokenReferenceID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"tokenReferenceId", "body", string(o.TokenReferenceID)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
swagger:model PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard
*/
type PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customer's latest payment card expires.
	//
	// Format: `MM`.
	//
	// Possible Values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customer's latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer's latest payment card number suffix
	//
	// Example: 1111
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this post customer payment instrument params body embedded instrument identifier tokenized card card
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body embedded instrument identifier tokenized card card based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSuffix(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateSuffix(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"suffix", "body", string(o.Suffix)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier post customer payment instrument params body instrument identifier
swagger:model PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier
*/
type PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier struct {

	// The Id of the Instrument Identifier linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this post customer payment instrument params body instrument identifier
func (o *PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("postCustomerPaymentInstrumentRequest"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body instrument identifier based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyLinks post customer payment instrument params body links
swagger:model PostCustomerPaymentInstrumentParamsBodyLinks
*/
type PostCustomerPaymentInstrumentParamsBodyLinks struct {

	// customer
	Customer *PostCustomerPaymentInstrumentParamsBodyLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PostCustomerPaymentInstrumentParamsBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this post customer payment instrument params body links
func (o *PostCustomerPaymentInstrumentParamsBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body links based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {

		if swag.IsZero(o.Customer) { // not required
			return nil
		}

		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyLinks) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyLinksCustomer post customer payment instrument params body links customer
swagger:model PostCustomerPaymentInstrumentParamsBodyLinksCustomer
*/
type PostCustomerPaymentInstrumentParamsBodyLinksCustomer struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/D9F340DD3DB9C276E053A2598D0A41A3
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument params body links customer
func (o *PostCustomerPaymentInstrumentParamsBodyLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument params body links customer based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyLinksSelf post customer payment instrument params body links self
swagger:model PostCustomerPaymentInstrumentParamsBodyLinksSelf
*/
type PostCustomerPaymentInstrumentParamsBodyLinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Example: /tms/v2/customers/D9F340DD3DB9C276E053A2598D0A41A3/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this post customer payment instrument params body links self
func (o *PostCustomerPaymentInstrumentParamsBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument params body links self based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyMerchantInformation post customer payment instrument params body merchant information
swagger:model PostCustomerPaymentInstrumentParamsBodyMerchantInformation
*/
type PostCustomerPaymentInstrumentParamsBodyMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this post customer payment instrument params body merchant information
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body merchant information based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {

		if swag.IsZero(o.MerchantDescriptor) { // not required
			return nil
		}

		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor post customer payment instrument params body merchant information merchant descriptor
swagger:model PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor
*/
type PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholder's statement.
	// When you do not include this value in your capture or credit request, the merchant URL from your CyberSource account is used.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this post customer payment instrument params body merchant information merchant descriptor
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body merchant information merchant descriptor based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyMetadata post customer payment instrument params body metadata
swagger:model PostCustomerPaymentInstrumentParamsBodyMetadata
*/
type PostCustomerPaymentInstrumentParamsBodyMetadata struct {

	// The creator of the Payment Instrument.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this post customer payment instrument params body metadata
func (o *PostCustomerPaymentInstrumentParamsBodyMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this post customer payment instrument params body metadata based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "postCustomerPaymentInstrumentRequest"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyMetadata) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyProcessingInformation tmsPaymentInstrumentProcessingInfo
swagger:model PostCustomerPaymentInstrumentParamsBodyProcessingInformation
*/
type PostCustomerPaymentInstrumentParamsBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Possible Values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this post customer payment instrument params body processing information
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this post customer payment instrument params body processing information based on the context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {

		if swag.IsZero(o.BankTransferOptions) { // not required
			return nil
		}

		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("postCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions post customer payment instrument params body processing information bank transfer options
swagger:model PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions
*/
type PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Possible Values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this post customer payment instrument params body processing information bank transfer options
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("postCustomerPaymentInstrumentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", o.SECCode, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this post customer payment instrument params body processing information bank transfer options based on context it is used
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PostCustomerPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
