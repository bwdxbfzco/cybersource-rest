// Code generated by go-swagger; DO NOT EDIT.

package payments

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IncrementAuthReader is a Reader for the IncrementAuth structure.
type IncrementAuthReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *IncrementAuthReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewIncrementAuthCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewIncrementAuthBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewIncrementAuthBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[PATCH /pts/v2/payments/{id}] incrementAuth", response, response.Code())
	}
}

// NewIncrementAuthCreated creates a IncrementAuthCreated with default headers values
func NewIncrementAuthCreated() *IncrementAuthCreated {
	return &IncrementAuthCreated{}
}

/*
IncrementAuthCreated describes a response with status code 201, with default header values.

Successful response.
*/
type IncrementAuthCreated struct {
	Payload *IncrementAuthCreatedBody
}

// IsSuccess returns true when this increment auth created response has a 2xx status code
func (o *IncrementAuthCreated) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this increment auth created response has a 3xx status code
func (o *IncrementAuthCreated) IsRedirect() bool {
	return false
}

// IsClientError returns true when this increment auth created response has a 4xx status code
func (o *IncrementAuthCreated) IsClientError() bool {
	return false
}

// IsServerError returns true when this increment auth created response has a 5xx status code
func (o *IncrementAuthCreated) IsServerError() bool {
	return false
}

// IsCode returns true when this increment auth created response a status code equal to that given
func (o *IncrementAuthCreated) IsCode(code int) bool {
	return code == 201
}

// Code gets the status code for the increment auth created response
func (o *IncrementAuthCreated) Code() int {
	return 201
}

func (o *IncrementAuthCreated) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthCreated %s", 201, payload)
}

func (o *IncrementAuthCreated) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthCreated %s", 201, payload)
}

func (o *IncrementAuthCreated) GetPayload() *IncrementAuthCreatedBody {
	return o.Payload
}

func (o *IncrementAuthCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(IncrementAuthCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewIncrementAuthBadRequest creates a IncrementAuthBadRequest with default headers values
func NewIncrementAuthBadRequest() *IncrementAuthBadRequest {
	return &IncrementAuthBadRequest{}
}

/*
IncrementAuthBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type IncrementAuthBadRequest struct {
	Payload *IncrementAuthBadRequestBody
}

// IsSuccess returns true when this increment auth bad request response has a 2xx status code
func (o *IncrementAuthBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this increment auth bad request response has a 3xx status code
func (o *IncrementAuthBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this increment auth bad request response has a 4xx status code
func (o *IncrementAuthBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this increment auth bad request response has a 5xx status code
func (o *IncrementAuthBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this increment auth bad request response a status code equal to that given
func (o *IncrementAuthBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the increment auth bad request response
func (o *IncrementAuthBadRequest) Code() int {
	return 400
}

func (o *IncrementAuthBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthBadRequest %s", 400, payload)
}

func (o *IncrementAuthBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthBadRequest %s", 400, payload)
}

func (o *IncrementAuthBadRequest) GetPayload() *IncrementAuthBadRequestBody {
	return o.Payload
}

func (o *IncrementAuthBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(IncrementAuthBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewIncrementAuthBadGateway creates a IncrementAuthBadGateway with default headers values
func NewIncrementAuthBadGateway() *IncrementAuthBadGateway {
	return &IncrementAuthBadGateway{}
}

/*
IncrementAuthBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type IncrementAuthBadGateway struct {
	Payload *IncrementAuthBadGatewayBody
}

// IsSuccess returns true when this increment auth bad gateway response has a 2xx status code
func (o *IncrementAuthBadGateway) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this increment auth bad gateway response has a 3xx status code
func (o *IncrementAuthBadGateway) IsRedirect() bool {
	return false
}

// IsClientError returns true when this increment auth bad gateway response has a 4xx status code
func (o *IncrementAuthBadGateway) IsClientError() bool {
	return false
}

// IsServerError returns true when this increment auth bad gateway response has a 5xx status code
func (o *IncrementAuthBadGateway) IsServerError() bool {
	return true
}

// IsCode returns true when this increment auth bad gateway response a status code equal to that given
func (o *IncrementAuthBadGateway) IsCode(code int) bool {
	return code == 502
}

// Code gets the status code for the increment auth bad gateway response
func (o *IncrementAuthBadGateway) Code() int {
	return 502
}

func (o *IncrementAuthBadGateway) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthBadGateway %s", 502, payload)
}

func (o *IncrementAuthBadGateway) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthBadGateway %s", 502, payload)
}

func (o *IncrementAuthBadGateway) GetPayload() *IncrementAuthBadGatewayBody {
	return o.Payload
}

func (o *IncrementAuthBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(IncrementAuthBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
IncrementAuthBadGatewayBody ptsV2IncrementalAuthorizationPatch502Response
swagger:model IncrementAuthBadGatewayBody
*/
type IncrementAuthBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this increment auth bad gateway body
func (o *IncrementAuthBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth bad gateway body based on context it is used
func (o *IncrementAuthBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthBadRequestBody ptsV2IncrementalAuthorizationPatch400Response
swagger:model IncrementAuthBadRequestBody
*/
type IncrementAuthBadRequestBody struct {

	// details
	Details []*IncrementAuthBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_CARD
	//  - CARD_TYPE_NOT_ACCEPTED
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - PROCESSOR_UNAVAILABLE
	//  - INVALID_PAYMENT_ID
	//  - NOT_SUPPORTED
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this increment auth bad request body
func (o *IncrementAuthBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this increment auth bad request body based on the context it is used
func (o *IncrementAuthBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBadRequestBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthBadRequestBodyDetailsItems0 increment auth bad request body details items0
swagger:model IncrementAuthBadRequestBodyDetailsItems0
*/
type IncrementAuthBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this increment auth bad request body details items0
func (o *IncrementAuthBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth bad request body details items0 based on context it is used
func (o *IncrementAuthBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthBody increment auth body
// Example: {"clientReferenceInformation":{"code":"TC50171_3"},"merchantInformation":{"transactionLocalDateTime":20191002080000},"orderInformation":{"amountDetails":{"additionalAmount":"22.49","currency":"USD"}},"processingInformation":{"authorizationOptions":{"initiator":{"storedCredentialUsed":true}}},"travelInformation":{"duration":"4"}}
swagger:model IncrementAuthBody
*/
type IncrementAuthBody struct {

	// client reference information
	ClientReferenceInformation *IncrementAuthParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// merchant information
	MerchantInformation *IncrementAuthParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *IncrementAuthParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// processing information
	ProcessingInformation *IncrementAuthParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// travel information
	TravelInformation *IncrementAuthParamsBodyTravelInformation `json:"travelInformation,omitempty"`
}

// Validate validates this increment auth body
func (o *IncrementAuthBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTravelInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateTravelInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TravelInformation) { // not required
		return nil
	}

	if o.TravelInformation != nil {
		if err := o.TravelInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth body based on the context it is used
func (o *IncrementAuthBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTravelInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {

		if swag.IsZero(o.MerchantInformation) { // not required
			return nil
		}

		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateTravelInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TravelInformation != nil {

		if swag.IsZero(o.TravelInformation) { // not required
			return nil
		}

		if err := o.TravelInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBody ptsV2IncrementalAuthorizationPatch201Response
// Example: {"_links":{"self":{"href":"/pts/v2/payments/4963015972176007901546","method":"GET"}},"clientReferenceInformation":{"code":"TC50171_3"},"id":"4963015972176007901546","orderInformation":{"amountDetails":{"authorizedAmount":"22.49","currency":"USD"}},"processorInformation":{"approvalCode":"888888","responseCode":"100"},"reconciliationId":"39570726X3E1LBQR","status":"200","submitTimeUtc":"2017-06-01T071957Z"}
swagger:model IncrementAuthCreatedBody
*/
type IncrementAuthCreatedBody struct {

	// links
	Links *IncrementAuthCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *IncrementAuthCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// error information
	ErrorInformation *IncrementAuthCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// order information
	OrderInformation *IncrementAuthCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *IncrementAuthCreatedBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// processor information
	ProcessorInformation *IncrementAuthCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// Reference number for the transaction.
	// Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource.
	// The actual value used in the request to the processor is provided back to you by Cybersource in the response.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - AUTHORIZED
	//  - AUTHORIZED_PENDING_REVIEW
	//  - DECLINED
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this increment auth created body
func (o *IncrementAuthCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this increment auth created body based on the context it is used
func (o *IncrementAuthCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {

		if swag.IsZero(o.ErrorInformation) { // not required
			return nil
		}

		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {

		if swag.IsZero(o.PaymentInformation) { // not required
			return nil
		}

		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateProcessorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessorInformation != nil {

		if swag.IsZero(o.ProcessorInformation) { // not required
			return nil
		}

		if err := o.ProcessorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyClientReferenceInformation increment auth created body client reference information
swagger:model IncrementAuthCreatedBodyClientReferenceInformation
*/
type IncrementAuthCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`
}

// Validate validates this increment auth created body client reference information
func (o *IncrementAuthCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body client reference information based on context it is used
func (o *IncrementAuthCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyErrorInformation increment auth created body error information
swagger:model IncrementAuthCreatedBodyErrorInformation
*/
type IncrementAuthCreatedBodyErrorInformation struct {

	// details
	Details []*IncrementAuthCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//   - AVS_FAILED
	//   - CONTACT_PROCESSOR
	//   - EXPIRED_CARD
	//   - PROCESSOR_DECLINED
	//   - INSUFFICIENT_FUND
	//   - STOLEN_LOST_CARD
	//   - ISSUER_UNAVAILABLE
	//   - UNAUTHORIZED_CARD
	//   - CVN_NOT_MATCH
	//   - EXCEEDS_CREDIT_LIMIT
	//   - INVALID_CVN
	//   - BLACKLISTED_CUSTOMER
	//   - SUSPENDED_ACCOUNT
	//   - PAYMENT_REFUSED
	//   - CV_FAILED
	//   - INVALID_ACCOUNT
	//   - GENERAL_DECLINE
	//   - INVALID_MERCHANT_CONFIGURATION
	//   - DECISION_PROFILE_REJECT
	//   - SCORE_EXCEEDS_THRESHOLD
	//   - CONSUMER_AUTHENTICATION_REQUIRED
	//   - ALLOWABLE_PIN_RETRIES_EXCEEDED
	//   - PROCESSOR_ERROR
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this increment auth created body error information
func (o *IncrementAuthCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this increment auth created body error information based on the context it is used
func (o *IncrementAuthCreatedBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyErrorInformationDetailsItems0 increment auth created body error information details items0
swagger:model IncrementAuthCreatedBodyErrorInformationDetailsItems0
*/
type IncrementAuthCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this increment auth created body error information details items0
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth created body error information details items0 based on context it is used
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyLinks increment auth created body links
swagger:model IncrementAuthCreatedBodyLinks
*/
type IncrementAuthCreatedBodyLinks struct {

	// self
	Self *IncrementAuthCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this increment auth created body links
func (o *IncrementAuthCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth created body links based on the context it is used
func (o *IncrementAuthCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyLinksSelf increment auth created body links self
swagger:model IncrementAuthCreatedBodyLinksSelf
*/
type IncrementAuthCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this increment auth created body links self
func (o *IncrementAuthCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth created body links self based on context it is used
func (o *IncrementAuthCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyOrderInformation increment auth created body order information
swagger:model IncrementAuthCreatedBodyOrderInformation
*/
type IncrementAuthCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *IncrementAuthCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// invoice details
	InvoiceDetails *IncrementAuthCreatedBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`
}

// Validate validates this increment auth created body order information
func (o *IncrementAuthCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth created body order information based on the context it is used
func (o *IncrementAuthCreatedBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {

		if swag.IsZero(o.InvoiceDetails) { // not required
			return nil
		}

		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyOrderInformationAmountDetails increment auth created body order information amount details
swagger:model IncrementAuthCreatedBodyOrderInformationAmountDetails
*/
type IncrementAuthCreatedBodyOrderInformationAmountDetails struct {

	// Amount that was authorized.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Amount of the purchase.
	//
	// Returned by PIN debit purchase.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in Merchant Descriptors Using the SCMP API.
	//
	// Max Length: 15
	AuthorizedAmount string `json:"authorizedAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// If coupons/vouchers are used in the transaction, the discount amount redeemed in the settlement currency will be returned. Otherwise, no return.
	//
	// Max Length: 11
	DiscountAmount string `json:"discountAmount,omitempty"`

	// The rate of conversion of the currency given in the request to CNY. The conversion happens at the time when Alipay's trade order is created
	//
	// Max Length: 17
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// The transaction amount in CNY.
	//
	// Max Length: 11
	ForeignAmount string `json:"foreignAmount,omitempty"`

	// Currency code for the transaction performed in cross border currency.
	//
	// Max Length: 3
	ForeignCurrency string `json:"foreignCurrency,omitempty"`

	// Amount in your original local pricing currency.
	//
	// This value cannot be negative. You can include a decimal point (.) in this field to denote the currency
	// exponent, but you cannot include any other special characters.
	//
	// If needed, CyberSource truncates the amount to the correct number of decimal places.
	//
	// Max Length: 15
	OriginalAmount string `json:"originalAmount,omitempty"`

	// Your local pricing currency code.
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// Max Length: 15
	OriginalCurrency string `json:"originalCurrency,omitempty"`

	// Amount up to N digit after the decimals separator as defined in ISO 4217 for the appropriate currency code.
	//
	// Max Length: 15
	ProcessorTransactionFee string `json:"processorTransactionFee,omitempty"`

	// This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholder's account.
	// This field is returned for OCT transactions.
	//
	// Max Length: 12
	SettlementAmount string `json:"settlementAmount,omitempty"`

	// This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account.
	// This field is returned for OCT transactions.
	//
	// Max Length: 3
	SettlementCurrency string `json:"settlementCurrency,omitempty"`

	// Amount you requested for the payment or capture.
	//
	// This value is returned for partial authorizations.
	// This field is also returned on incremental authorizations will contain the aggregated amount from the original authorizations and all the incremental authorizations.
	//
	// Max Length: 15
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this increment auth created body order information amount details
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorTransactionFee(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateAuthorizedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"authorizedAmount", "body", o.AuthorizedAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", o.DiscountAmount, 11); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateExchangeRate(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeRate) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRate", "body", o.ExchangeRate, 17); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateForeignAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignAmount", "body", o.ForeignAmount, 11); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateForeignCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignCurrency", "body", o.ForeignCurrency, 3); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateOriginalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalAmount", "body", o.OriginalAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateOriginalCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalCurrency", "body", o.OriginalCurrency, 15); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateProcessorTransactionFee(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorTransactionFee) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"processorTransactionFee", "body", o.ProcessorTransactionFee, 15); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateSettlementAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"settlementAmount", "body", o.SettlementAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateSettlementCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"settlementCurrency", "body", o.SettlementCurrency, 3); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body order information amount details based on context it is used
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyOrderInformationInvoiceDetails increment auth created body order information invoice details
swagger:model IncrementAuthCreatedBodyOrderInformationInvoiceDetails
*/
type IncrementAuthCreatedBodyOrderInformationInvoiceDetails struct {

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// Max Length: 35
	ProductID string `json:"productId,omitempty"`
}

// Validate validates this increment auth created body order information invoice details
func (o *IncrementAuthCreatedBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateProductID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationInvoiceDetails) validateProductID(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"productId", "body", o.ProductID, 35); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body order information invoice details based on context it is used
func (o *IncrementAuthCreatedBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyPaymentInformation increment auth created body payment information
swagger:model IncrementAuthCreatedBodyPaymentInformation
*/
type IncrementAuthCreatedBodyPaymentInformation struct {

	// account features
	AccountFeatures *IncrementAuthCreatedBodyPaymentInformationAccountFeatures `json:"accountFeatures,omitempty"`
}

// Validate validates this increment auth created body payment information
func (o *IncrementAuthCreatedBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyPaymentInformation) validateAccountFeatures(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountFeatures) { // not required
		return nil
	}

	if o.AccountFeatures != nil {
		if err := o.AccountFeatures.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth created body payment information based on the context it is used
func (o *IncrementAuthCreatedBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccountFeatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyPaymentInformation) contextValidateAccountFeatures(ctx context.Context, formats strfmt.Registry) error {

	if o.AccountFeatures != nil {

		if swag.IsZero(o.AccountFeatures) { // not required
			return nil
		}

		if err := o.AccountFeatures.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyPaymentInformationAccountFeatures increment auth created body payment information account features
swagger:model IncrementAuthCreatedBodyPaymentInformationAccountFeatures
*/
type IncrementAuthCreatedBodyPaymentInformationAccountFeatures struct {

	// #### GPX
	// Mastercard product ID associated with the primary account number (PAN).
	// Returned by authorization service.
	//
	// #### CyberSource through VisaNet
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, see the Product ID table on the [Visa
	// Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)
	//
	// Data Length: String (3)
	//
	// #### GPN
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, see the Product ID table on the
	// [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)
	//
	// Data Length: String (3)
	//
	// #### Worldpay VAP
	// **Important** Before using this field on Worldpay VAP,
	// you must contact CyberSource Customer Support to have
	// your account configured for this feature.
	//
	// Type of card used in the transaction. The only possible value is:
	// - `PREPAID`: Prepaid Card
	//
	// Data Length: String (7)
	//
	// #### RBS WorldPay Atlanta
	// Type of card used in the transaction. Possible values:
	// - `B`: Business Card
	// - `O`: Noncommercial Card
	// - `R`: Corporate Card
	// - `S`: Purchase Card
	// - `Blank`: Purchase card not supported
	//
	// Data Length: String (1)
	//
	// Max Length: 7
	Category string `json:"category,omitempty"`
}

// Validate validates this increment auth created body payment information account features
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(o.Category) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"category", "body", o.Category, 7); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body payment information account features based on context it is used
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyPaymentInformationAccountFeatures
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyProcessorInformation increment auth created body processor information
swagger:model IncrementAuthCreatedBodyProcessorInformation
*/
type IncrementAuthCreatedBodyProcessorInformation struct {

	// Authorization code. Returned only when the processor returns this value.
	//
	// The length of this value depends on your processor.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Authorization code that is returned by the processor.
	//
	// Returned by PIN debit credit.
	//
	// #### Elavon Encrypted Account Number Program
	// The returned value is OFFLINE.
	//
	// #### TSYS Acquiring Solutions
	// The returned value for a successful zero amount authorization is 000000.
	//
	// Max Length: 6
	ApprovalCode string `json:"approvalCode,omitempty"`

	// merchant advice
	MerchantAdvice *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice `json:"merchantAdvice,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	//
	// #### PIN debit
	// Response value that is returned by the processor or bank.
	// **Important** Do not use this field to evaluate the results of the transaction request.
	//
	// Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or response code received from the processor separated by a colon.
	// Format: [status code]:E[error code] or [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field.
	// String (3)
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// This field might contain information about a decline. This field is supported only for **CyberSource through
	// VisaNet**.
	//
	// Max Length: 255
	ResponseDetails string `json:"responseDetails,omitempty"`

	// seller protection
	SellerProtection *IncrementAuthCreatedBodyProcessorInformationSellerProtection `json:"sellerProtection,omitempty"`

	// This field is returned only for **American Express Direct** and **CyberSource through VisaNet**.
	// Returned by authorization and incremental authorization services.
	//
	// #### American Express Direct
	//
	// System trace audit number (STAN). This value identifies the transaction and is useful when investigating a
	// chargeback dispute.
	//
	// #### CyberSource through VisaNet
	//
	// System trace number that must be printed on the customer's receipt.
	//
	// Max Length: 6
	SystemTraceAuditNumber string `json:"systemTraceAuditNumber,omitempty"`

	// Network transaction identifier (TID). You can use this value to identify a specific transaction when you are
	// discussing the transaction with your processor. Not all processors provide this value.
	//
	// Returned by the authorization service.
	//
	// #### PIN debit
	// Transaction identifier generated by the processor.
	//
	// Returned by PIN debit credit.
	//
	// #### GPX
	// Processor transaction ID.
	//
	// #### Cielo
	// For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.
	//
	// #### Comercio Latino
	// For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.
	//
	// #### CyberSource through VisaNet and GPN
	// For details about this value for CyberSource through VisaNet and GPN, see "Network Transaction Identifiers" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Moneris
	// This value identifies the transaction on a host system. It contains the following information:
	// - Terminal used to process the transaction
	// - Shift during which the transaction took place
	// - Batch number
	// - Transaction number within the batch
	// You must store this value. If you give the customer a receipt, display this value on the receipt.
	//
	// **Example** For the value
	// 66012345001069003:
	// - Terminal ID = 66012345
	// - Shift number = 001
	// - Batch number = 069
	// - Transaction number = 003
	//
	// Max Length: 50
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this increment auth created body processor information
func (o *IncrementAuthCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateApprovalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantAdvice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSellerProtection(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSystemTraceAuditNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateApprovalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ApprovalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"approvalCode", "body", o.ApprovalCode, 6); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateMerchantAdvice(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantAdvice) { // not required
		return nil
	}

	if o.MerchantAdvice != nil {
		if err := o.MerchantAdvice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"responseCode", "body", o.ResponseCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateResponseDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"responseDetails", "body", o.ResponseDetails, 255); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateSellerProtection(formats strfmt.Registry) error {
	if swag.IsZero(o.SellerProtection) { // not required
		return nil
	}

	if o.SellerProtection != nil {
		if err := o.SellerProtection.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "sellerProtection")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "sellerProtection")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateSystemTraceAuditNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.SystemTraceAuditNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"systemTraceAuditNumber", "body", o.SystemTraceAuditNumber, 6); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"transactionId", "body", o.TransactionID, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this increment auth created body processor information based on the context it is used
func (o *IncrementAuthCreatedBodyProcessorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantAdvice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSellerProtection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) contextValidateMerchantAdvice(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantAdvice != nil {

		if swag.IsZero(o.MerchantAdvice) { // not required
			return nil
		}

		if err := o.MerchantAdvice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) contextValidateSellerProtection(ctx context.Context, formats strfmt.Registry) error {

	if o.SellerProtection != nil {

		if swag.IsZero(o.SellerProtection) { // not required
			return nil
		}

		if err := o.SellerProtection.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "sellerProtection")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "sellerProtection")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyProcessorInformationMerchantAdvice increment auth created body processor information merchant advice
swagger:model IncrementAuthCreatedBodyProcessorInformationMerchantAdvice
*/
type IncrementAuthCreatedBodyProcessorInformationMerchantAdvice struct {

	// - Merchant should update their retry logic to ensure retry is not attempted for the cards for which Issuer won't approve the transactions and where the retry is allowed.
	// - Card Processing Associations provides this data which is being passed through in the following data element irrespective of the Card Associations.   Usage of this data must be always associated with the Card Associations card types for merchant processing retry logic.
	// - In additions to the Merchant Advice code, Associations also provides the decline response codes which provides the reason for decline.  Association response code will be a pass-through value.
	//
	// #### Processors supported:
	//   - HSBC
	//   - Barclays
	//   - FDC Nash
	//   - FDI Global
	//   - Elavon America
	//   - VPC
	//   - Rede
	//   - Payment tech Salem
	//
	//
	// #### Possible values:
	// | Card Type   | Advice Code   |  Description                                |
	// | ----------- | ------------- | ------------------------------------------- |
	// | VISA        | 1             | Issuer never approves                       |
	// | VISA        | 2             | Issuer cannot approve at this time          |
	// | VISA        | 3             | Data quality/revalidate payment information |
	// | MasterCard  | 01            | New account information available           |
	// | MasterCard  | 02            | Try Again Later                             |
	// | MasterCard  | 03            | Do Not Try Again                            |
	// | MasterCard  | 04            | Token not supported                         |
	// | MasterCard  | 21            | Do not honor                                |
	// | MasterCard  | 22            | Merchant does not qualify for product code  |
	// | MasterCard  | 24            | Retry after 1 hour                          |
	// | MasterCard  | 25            | Retry after 24 hours                        |
	// | MasterCard  | 26            | Retry after 2 days                          |
	// | MasterCard  | 27            | Retry after 4 days                          |
	// | MasterCard  | 28            | Retry after 6 days                          |
	// | MasterCard  | 29            | Retry after 8 days                          |
	// | MasterCard  | 30            | Retry after 10 days                         |
	// | MasterCard  | 40            | Consumer non-reloadable prepaid card        |
	// | MasterCard  | 41            | Consumer single-use virtual card number     |
	// | MasterCard  | 42            | Sanctions score exceeds threshold value     |
	// | MasterCard  | 99            | Do Not Try Again                            |
	//
	// For processor-specific information, see the `auth_merchant_advice_code` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Code string `json:"code,omitempty"`

	// Raw merchant advice code sent directly from the processor. This field is used only for Mastercard.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR7
	// - Position: 96-99
	// - Field: Response Data-Merchant Advice Code
	//
	//
	// For processor-specific information, see the `auth_merchant_advice_code_raw` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	CodeRaw string `json:"codeRaw,omitempty"`

	// #### Visa Platform Connect
	// The field contains will contain the Account Name Request Result for zero amount Authorization request. Valid values are:
	//
	// 00 = Name Match Performed
	// 01 = Name Match not Performed
	// 02 = Name Match not supported
	//
	// Max Length: 2
	NameMatch string `json:"nameMatch,omitempty"`
}

// Validate validates this increment auth created body processor information merchant advice
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNameMatch(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"code", "body", o.Code, 2); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) validateCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"codeRaw", "body", o.CodeRaw, 4); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) validateNameMatch(formats strfmt.Registry) error {
	if swag.IsZero(o.NameMatch) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"nameMatch", "body", o.NameMatch, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body processor information merchant advice based on context it is used
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyProcessorInformationMerchantAdvice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthCreatedBodyProcessorInformationSellerProtection increment auth created body processor information seller protection
swagger:model IncrementAuthCreatedBodyProcessorInformationSellerProtection
*/
type IncrementAuthCreatedBodyProcessorInformationSellerProtection struct {

	// The level of seller protection in force for the transaction.
	// Possible values:
	// - `ELIGIBLE`
	// - `PARTIALLY_ELIGIBLE`
	// - `INELIGIBLE`
	//
	Eligibility string `json:"eligibility,omitempty"`

	// The kind of seller protection in force for the transaction. This field is returned only when the protection_eligibility property is set to ELIGIBLE or PARTIALLY_ELIGIBLE.
	// Possible values:
	// - `ITEM_NOT_RECEIVED_ELIGIBLE: Sellers are protected against claims for items not received.`
	// - `UNAUTHORIZED_PAYMENT_ELIGIBLE: Sellers are protected against claims for unauthorized payments.`
	// One or both values can be returned.
	//
	// Max Length: 60
	EligibilityType string `json:"eligibilityType,omitempty"`

	// The kind of seller protection in force for the transaction. This field is
	// returned only when the protection eligibility value is set to
	// ELIGIBLE or PARTIALLY_ELIGIBLE.
	// Possible values
	// - ITEM_NOT_RECEIVED_ELIGIBLE: Sellers are protected
	// against claims for items not received.
	// - UNAUTHORIZED_PAYMENT_ELIGIBLE: Sellers are
	// protected against claims for unauthorized payments.
	// One or both values can be returned.
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this increment auth created body processor information seller protection
func (o *IncrementAuthCreatedBodyProcessorInformationSellerProtection) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEligibilityType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformationSellerProtection) validateEligibilityType(formats strfmt.Registry) error {
	if swag.IsZero(o.EligibilityType) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"sellerProtection"+"."+"eligibilityType", "body", o.EligibilityType, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body processor information seller protection based on context it is used
func (o *IncrementAuthCreatedBodyProcessorInformationSellerProtection) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformationSellerProtection) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformationSellerProtection) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyProcessorInformationSellerProtection
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyClientReferenceInformation increment auth params body client reference information
swagger:model IncrementAuthParamsBodyClientReferenceInformation
*/
type IncrementAuthParamsBodyClientReferenceInformation struct {

	// The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource.
	//
	ApplicationName string `json:"applicationName,omitempty"`

	// The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method.
	//
	ApplicationUser string `json:"applicationUser,omitempty"`

	// Version of the CyberSource application or integration used for a transaction.
	//
	ApplicationVersion string `json:"applicationVersion,omitempty"`

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// partner
	Partner *IncrementAuthParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this increment auth params body client reference information
func (o *IncrementAuthParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body client reference information based on the context it is used
func (o *IncrementAuthParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {

		if swag.IsZero(o.Partner) { // not required
			return nil
		}

		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyClientReferenceInformationPartner increment auth params body client reference information partner
swagger:model IncrementAuthParamsBodyClientReferenceInformationPartner
*/
type IncrementAuthParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminal's software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal's
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this increment auth params body client reference information partner
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", o.OriginalTransactionID, 32); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body client reference information partner based on context it is used
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyMerchantInformation increment auth params body merchant information
swagger:model IncrementAuthParamsBodyMerchantInformation
*/
type IncrementAuthParamsBodyMerchantInformation struct {

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where:
	//  - `YYYY` = year
	//  - `MM` = month
	//  - `DD` = day
	//  - `hh` = hour
	//  - `mm` = minutes
	//  - `ss` = seconds
	//
	// #### Used by
	// **Authorization**
	// Required for these processors:
	// - American Express Direct                                                                                                                                                                                                                                                                                                                         - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - SIX
	//
	// Optional for all other processors.
	//
	// Max Length: 14
	TransactionLocalDateTime string `json:"transactionLocalDateTime,omitempty"`
}

// Validate validates this increment auth params body merchant information
func (o *IncrementAuthParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTransactionLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyMerchantInformation) validateTransactionLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"merchantInformation"+"."+"transactionLocalDateTime", "body", o.TransactionLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body merchant information based on context it is used
func (o *IncrementAuthParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyOrderInformation increment auth params body order information
swagger:model IncrementAuthParamsBodyOrderInformation
*/
type IncrementAuthParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *IncrementAuthParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`
}

// Validate validates this increment auth params body order information
func (o *IncrementAuthParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body order information based on the context it is used
func (o *IncrementAuthParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyOrderInformationAmountDetails increment auth params body order information amount details
swagger:model IncrementAuthParamsBodyOrderInformationAmountDetails
*/
type IncrementAuthParamsBodyOrderInformationAmountDetails struct {

	// Additional charges that have to be authorized against a lodging or auto-rental order.
	// This value cannot be negative. You can include a decimal point (.), but no other special characters.
	//
	// Max Length: 19
	AdditionalAmount string `json:"additionalAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`
}

// Validate validates this increment auth params body order information amount details
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) validateAdditionalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"additionalAmount", "body", o.AdditionalAmount, 19); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body order information amount details based on context it is used
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyProcessingInformation increment auth params body processing information
swagger:model IncrementAuthParamsBodyProcessingInformation
*/
type IncrementAuthParamsBodyProcessingInformation struct {

	// authorization options
	AuthorizationOptions *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this increment auth params body processing information
func (o *IncrementAuthParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body processing information based on the context it is used
func (o *IncrementAuthParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {

		if swag.IsZero(o.AuthorizationOptions) { // not required
			return nil
		}

		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyProcessingInformationAuthorizationOptions increment auth params body processing information authorization options
swagger:model IncrementAuthParamsBodyProcessingInformationAuthorizationOptions
*/
type IncrementAuthParamsBodyProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this increment auth params body processing information authorization options
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body processing information authorization options based on the context it is used
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {

		if swag.IsZero(o.Initiator) { // not required
			return nil
		}

		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator increment auth params body processing information authorization options initiator
swagger:model IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator
*/
type IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator struct {

	// Indicates to an issuing bank whether a merchant-initiated transaction came from a card that was already stored on file.
	//
	// Possible values:
	// - **true** means the merchant-initiated transaction came from a card that was already stored on file.
	// - **false**  means the merchant-initiated transaction came from a card that was not stored on file.
	//
	StoredCredentialUsed bool `json:"storedCredentialUsed,omitempty"`
}

// Validate validates this increment auth params body processing information authorization options initiator
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth params body processing information authorization options initiator based on context it is used
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
IncrementAuthParamsBodyTravelInformation increment auth params body travel information
swagger:model IncrementAuthParamsBodyTravelInformation
*/
type IncrementAuthParamsBodyTravelInformation struct {

	// Duration for which the vehicle was rented or lodge/hotel was booked.
	//
	// Max Length: 2
	Duration string `json:"duration,omitempty"`
}

// Validate validates this increment auth params body travel information
func (o *IncrementAuthParamsBodyTravelInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyTravelInformation) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(o.Duration) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"travelInformation"+"."+"duration", "body", o.Duration, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body travel information based on context it is used
func (o *IncrementAuthParamsBodyTravelInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyTravelInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyTravelInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyTravelInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
