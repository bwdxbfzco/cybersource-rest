// Code generated by go-swagger; DO NOT EDIT.

package taxes

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CalculateTaxReader is a Reader for the CalculateTax structure.
type CalculateTaxReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CalculateTaxReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCalculateTaxCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCalculateTaxBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewCalculateTaxBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[POST /vas/v2/tax] calculateTax", response, response.Code())
	}
}

// NewCalculateTaxCreated creates a CalculateTaxCreated with default headers values
func NewCalculateTaxCreated() *CalculateTaxCreated {
	return &CalculateTaxCreated{}
}

/*
CalculateTaxCreated describes a response with status code 201, with default header values.

Successful response.
*/
type CalculateTaxCreated struct {
	Payload *CalculateTaxCreatedBody
}

// IsSuccess returns true when this calculate tax created response has a 2xx status code
func (o *CalculateTaxCreated) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this calculate tax created response has a 3xx status code
func (o *CalculateTaxCreated) IsRedirect() bool {
	return false
}

// IsClientError returns true when this calculate tax created response has a 4xx status code
func (o *CalculateTaxCreated) IsClientError() bool {
	return false
}

// IsServerError returns true when this calculate tax created response has a 5xx status code
func (o *CalculateTaxCreated) IsServerError() bool {
	return false
}

// IsCode returns true when this calculate tax created response a status code equal to that given
func (o *CalculateTaxCreated) IsCode(code int) bool {
	return code == 201
}

// Code gets the status code for the calculate tax created response
func (o *CalculateTaxCreated) Code() int {
	return 201
}

func (o *CalculateTaxCreated) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /vas/v2/tax][%d] calculateTaxCreated %s", 201, payload)
}

func (o *CalculateTaxCreated) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /vas/v2/tax][%d] calculateTaxCreated %s", 201, payload)
}

func (o *CalculateTaxCreated) GetPayload() *CalculateTaxCreatedBody {
	return o.Payload
}

func (o *CalculateTaxCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CalculateTaxCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCalculateTaxBadRequest creates a CalculateTaxBadRequest with default headers values
func NewCalculateTaxBadRequest() *CalculateTaxBadRequest {
	return &CalculateTaxBadRequest{}
}

/*
CalculateTaxBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type CalculateTaxBadRequest struct {
	Payload *CalculateTaxBadRequestBody
}

// IsSuccess returns true when this calculate tax bad request response has a 2xx status code
func (o *CalculateTaxBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this calculate tax bad request response has a 3xx status code
func (o *CalculateTaxBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this calculate tax bad request response has a 4xx status code
func (o *CalculateTaxBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this calculate tax bad request response has a 5xx status code
func (o *CalculateTaxBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this calculate tax bad request response a status code equal to that given
func (o *CalculateTaxBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the calculate tax bad request response
func (o *CalculateTaxBadRequest) Code() int {
	return 400
}

func (o *CalculateTaxBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /vas/v2/tax][%d] calculateTaxBadRequest %s", 400, payload)
}

func (o *CalculateTaxBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /vas/v2/tax][%d] calculateTaxBadRequest %s", 400, payload)
}

func (o *CalculateTaxBadRequest) GetPayload() *CalculateTaxBadRequestBody {
	return o.Payload
}

func (o *CalculateTaxBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CalculateTaxBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCalculateTaxBadGateway creates a CalculateTaxBadGateway with default headers values
func NewCalculateTaxBadGateway() *CalculateTaxBadGateway {
	return &CalculateTaxBadGateway{}
}

/*
CalculateTaxBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type CalculateTaxBadGateway struct {
	Payload *CalculateTaxBadGatewayBody
}

// IsSuccess returns true when this calculate tax bad gateway response has a 2xx status code
func (o *CalculateTaxBadGateway) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this calculate tax bad gateway response has a 3xx status code
func (o *CalculateTaxBadGateway) IsRedirect() bool {
	return false
}

// IsClientError returns true when this calculate tax bad gateway response has a 4xx status code
func (o *CalculateTaxBadGateway) IsClientError() bool {
	return false
}

// IsServerError returns true when this calculate tax bad gateway response has a 5xx status code
func (o *CalculateTaxBadGateway) IsServerError() bool {
	return true
}

// IsCode returns true when this calculate tax bad gateway response a status code equal to that given
func (o *CalculateTaxBadGateway) IsCode(code int) bool {
	return code == 502
}

// Code gets the status code for the calculate tax bad gateway response
func (o *CalculateTaxBadGateway) Code() int {
	return 502
}

func (o *CalculateTaxBadGateway) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /vas/v2/tax][%d] calculateTaxBadGateway %s", 502, payload)
}

func (o *CalculateTaxBadGateway) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /vas/v2/tax][%d] calculateTaxBadGateway %s", 502, payload)
}

func (o *CalculateTaxBadGateway) GetPayload() *CalculateTaxBadGatewayBody {
	return o.Payload
}

func (o *CalculateTaxBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CalculateTaxBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
CalculateTaxBadGatewayBody vasV2PaymentsPost502Response
swagger:model CalculateTaxBadGatewayBody
*/
type CalculateTaxBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this calculate tax bad gateway body
func (o *CalculateTaxBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this calculate tax bad gateway body based on context it is used
func (o *CalculateTaxBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res CalculateTaxBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxBadRequestBody vasV2PaymentsPost400Response
swagger:model CalculateTaxBadRequestBody
*/
type CalculateTaxBadRequestBody struct {

	// details
	Details []*CalculateTaxBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - INVALID_ADDRESS
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this calculate tax bad request body
func (o *CalculateTaxBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("calculateTaxBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("calculateTaxBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this calculate tax bad request body based on the context it is used
func (o *CalculateTaxBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("calculateTaxBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("calculateTaxBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CalculateTaxBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxBadRequestBodyDetailsItems0 calculate tax bad request body details items0
swagger:model CalculateTaxBadRequestBodyDetailsItems0
*/
type CalculateTaxBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this calculate tax bad request body details items0
func (o *CalculateTaxBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this calculate tax bad request body details items0 based on context it is used
func (o *CalculateTaxBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CalculateTaxBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxBody calculate tax body
swagger:model CalculateTaxBody
*/
type CalculateTaxBody struct {

	// buyer information
	BuyerInformation *CalculateTaxParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CalculateTaxParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// merchant information
	MerchantInformation *CalculateTaxParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *CalculateTaxParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// tax information
	TaxInformation *CalculateTaxParamsBodyTaxInformation `json:"taxInformation,omitempty"`
}

// Validate validates this calculate tax body
func (o *CalculateTaxBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) validateTaxInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxInformation) { // not required
		return nil
	}

	if o.TaxInformation != nil {
		if err := o.TaxInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "taxInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "taxInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this calculate tax body based on the context it is used
func (o *CalculateTaxBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {

		if swag.IsZero(o.BuyerInformation) { // not required
			return nil
		}

		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {

		if swag.IsZero(o.MerchantInformation) { // not required
			return nil
		}

		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxBody) contextValidateTaxInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TaxInformation != nil {

		if swag.IsZero(o.TaxInformation) { // not required
			return nil
		}

		if err := o.TaxInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "taxInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "taxInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxBody) UnmarshalBinary(b []byte) error {
	var res CalculateTaxBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBody vasV2PaymentsPost201Response
swagger:model CalculateTaxCreatedBody
*/
type CalculateTaxCreatedBody struct {

	// links
	Links *CalculateTaxCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *CalculateTaxCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// order information
	OrderInformation *CalculateTaxCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - COMPLETED
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`

	// tax information
	TaxInformation *CalculateTaxCreatedBodyTaxInformation `json:"taxInformation,omitempty"`
}

// Validate validates this calculate tax created body
func (o *CalculateTaxCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBody) validateTaxInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxInformation) { // not required
		return nil
	}

	if o.TaxInformation != nil {
		if err := o.TaxInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "taxInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "taxInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this calculate tax created body based on the context it is used
func (o *CalculateTaxCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBody) contextValidateTaxInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TaxInformation != nil {

		if swag.IsZero(o.TaxInformation) { // not required
			return nil
		}

		if err := o.TaxInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "taxInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "taxInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBody) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyClientReferenceInformation calculate tax created body client reference information
swagger:model CalculateTaxCreatedBodyClientReferenceInformation
*/
type CalculateTaxCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Merchant ID that was used to create the subscription or customer profile for which the service was requested.
	//
	// If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using
	// subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using
	// profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	OwnerMerchantID string `json:"ownerMerchantId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds
	//
	// #### PIN Debit
	// Optional field for PIN Debit purchase and credit requests.
	//
	// Max Length: 14
	SubmitLocalDateTime string `json:"submitLocalDateTime,omitempty"`
}

// Validate validates this calculate tax created body client reference information
func (o *CalculateTaxCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyClientReferenceInformation) validateSubmitLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.SubmitLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"clientReferenceInformation"+"."+"submitLocalDateTime", "body", o.SubmitLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax created body client reference information based on context it is used
func (o *CalculateTaxCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyLinks calculate tax created body links
swagger:model CalculateTaxCreatedBodyLinks
*/
type CalculateTaxCreatedBodyLinks struct {

	// void
	Void *CalculateTaxCreatedBodyLinksVoid `json:"void,omitempty"`
}

// Validate validates this calculate tax created body links
func (o *CalculateTaxCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateVoid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyLinks) validateVoid(formats strfmt.Registry) error {
	if swag.IsZero(o.Void) { // not required
		return nil
	}

	if o.Void != nil {
		if err := o.Void.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "_links" + "." + "void")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this calculate tax created body links based on the context it is used
func (o *CalculateTaxCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateVoid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyLinks) contextValidateVoid(ctx context.Context, formats strfmt.Registry) error {

	if o.Void != nil {

		if swag.IsZero(o.Void) { // not required
			return nil
		}

		if err := o.Void.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "_links" + "." + "void")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyLinksVoid calculate tax created body links void
swagger:model CalculateTaxCreatedBodyLinksVoid
*/
type CalculateTaxCreatedBodyLinksVoid struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this calculate tax created body links void
func (o *CalculateTaxCreatedBodyLinksVoid) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this calculate tax created body links void based on context it is used
func (o *CalculateTaxCreatedBodyLinksVoid) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyLinksVoid) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyLinksVoid) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyLinksVoid
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyOrderInformation calculate tax created body order information
swagger:model CalculateTaxCreatedBodyOrderInformation
*/
type CalculateTaxCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *CalculateTaxCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// Total amount of tax exempt amounts. This value is the sum of the values for all the `orderInformation.lineItems[].exemptAmount` fields in the tax calculation request.
	//
	// Max Length: 15
	ExemptAmount string `json:"exemptAmount,omitempty"`

	// line items
	LineItems []*CalculateTaxCreatedBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// Total amount of tax for all lineItems in the tax calculation request.
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// tax details
	TaxDetails []*CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0 `json:"taxDetails"`

	// Total amount of all taxable amounts. This value is the sum of the values for all the `orderInformation.lineItems[].taxAmount` fields in the tax calculation request.
	//
	// Max Length: 15
	TaxableAmount string `json:"taxableAmount,omitempty"`
}

// Validate validates this calculate tax created body order information
func (o *CalculateTaxCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxableAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) validateExemptAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"orderInformation"+"."+"exemptAmount", "body", o.ExemptAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"orderInformation"+"."+"taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) validateTaxableAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxableAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"orderInformation"+"."+"taxableAmount", "body", o.TaxableAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this calculate tax created body order information based on the context it is used
func (o *CalculateTaxCreatedBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {

			if swag.IsZero(o.LineItems[i]) { // not required
				return nil
			}

			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformation) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {

			if swag.IsZero(o.TaxDetails[i]) { // not required
				return nil
			}

			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("calculateTaxCreated" + "." + "orderInformation" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyOrderInformationAmountDetails calculate tax created body order information amount details
swagger:model CalculateTaxCreatedBodyOrderInformationAmountDetails
*/
type CalculateTaxCreatedBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this calculate tax created body order information amount details
func (o *CalculateTaxCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("calculateTaxCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax created body order information amount details based on context it is used
func (o *CalculateTaxCreatedBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyOrderInformationLineItemsItems0 calculate tax created body order information line items items0
swagger:model CalculateTaxCreatedBodyOrderInformationLineItemsItems0
*/
type CalculateTaxCreatedBodyOrderInformationLineItemsItems0 struct {

	// Exempt amount for the lineItem. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	ExemptAmount string `json:"exemptAmount,omitempty"`

	// jurisdiction
	Jurisdiction []*CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0 `json:"jurisdiction"`

	// Total tax for the item. This value is the sum of all taxes applied to the item.
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// tax details
	TaxDetails []*CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0 `json:"taxDetails"`

	// Portion of the item amount that is taxable.
	//
	// Max Length: 15
	TaxableAmount string `json:"taxableAmount,omitempty"`
}

// Validate validates this calculate tax created body order information line items items0
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExemptAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateJurisdiction(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxableAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) validateExemptAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptAmount", "body", o.ExemptAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) validateJurisdiction(formats strfmt.Registry) error {
	if swag.IsZero(o.Jurisdiction) { // not required
		return nil
	}

	for i := 0; i < len(o.Jurisdiction); i++ {
		if swag.IsZero(o.Jurisdiction[i]) { // not required
			continue
		}

		if o.Jurisdiction[i] != nil {
			if err := o.Jurisdiction[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("jurisdiction" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("jurisdiction" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) validateTaxableAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxableAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxableAmount", "body", o.TaxableAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this calculate tax created body order information line items items0 based on the context it is used
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateJurisdiction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) contextValidateJurisdiction(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Jurisdiction); i++ {

		if o.Jurisdiction[i] != nil {

			if swag.IsZero(o.Jurisdiction[i]) { // not required
				return nil
			}

			if err := o.Jurisdiction[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("jurisdiction" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("jurisdiction" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {

			if swag.IsZero(o.TaxDetails[i]) { // not required
				return nil
			}

			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0 calculate tax created body order information line items items0 jurisdiction items0
swagger:model CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0
*/
type CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0 struct {

	// Jurisdiction code assigned by the tax provider. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	Code string `json:"code,omitempty"`

	// Tax jurisdiction country for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	Country string `json:"country,omitempty"`

	// Free-text description of the jurisdiction for the item. For example, San Mateo County. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	Name string `json:"name,omitempty"`

	// Jurisdiction tax rate for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	Rate string `json:"rate,omitempty"`

	// Free-text description of the jurisdiction region for the item. For example, CA (California State) or GB (Great Britain). Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	Region string `json:"region,omitempty"`

	// Jurisdiction tax amount for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Name of the jurisdiction tax for the item. For example, CA State Tax. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	TaxName string `json:"taxName,omitempty"`

	// Jurisdiction taxable amount for the item, not including product level exemptions. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Max Length: 15
	Taxable string `json:"taxable,omitempty"`

	// Type of tax jurisdiction for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.
	//
	// Possible values:
	// - `city`
	// - `county`
	// - `state`
	// - `country`
	// - `special`
	//
	// Max Length: 15
	Type string `json:"type,omitempty"`
}

// Validate validates this calculate tax created body order information line items items0 jurisdiction items0
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxable(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("country", "body", o.Country, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("name", "body", o.Name, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", o.Rate, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateRegion(formats strfmt.Registry) error {
	if swag.IsZero(o.Region) { // not required
		return nil
	}

	if err := validate.MaxLength("region", "body", o.Region, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateTaxName(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxName) { // not required
		return nil
	}

	if err := validate.MaxLength("taxName", "body", o.TaxName, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateTaxable(formats strfmt.Registry) error {
	if swag.IsZero(o.Taxable) { // not required
		return nil
	}

	if err := validate.MaxLength("taxable", "body", o.Taxable, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("type", "body", o.Type, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax created body order information line items items0 jurisdiction items0 based on context it is used
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyOrderInformationLineItemsItems0JurisdictionItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0 calculate tax created body order information line items items0 tax details items0
swagger:model CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0
*/
type CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0 struct {

	// Amount corresponding to different types of taxes applied.
	//
	// Max Length: 15
	Amount string `json:"amount,omitempty"`

	// Allowed tax types:
	// - city
	// - county
	// - state
	// - national
	// - special
	//
	// Max Length: 15
	Type string `json:"type,omitempty"`
}

// Validate validates this calculate tax created body order information line items items0 tax details items0
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("type", "body", o.Type, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax created body order information line items items0 tax details items0 based on context it is used
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyOrderInformationLineItemsItems0TaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0 calculate tax created body order information tax details items0
swagger:model CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0
*/
type CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0 struct {

	// Amount corresponding to different types of taxes applied.
	//
	// Max Length: 15
	Amount string `json:"amount,omitempty"`

	// Allowed tax types:
	// - city
	// - county
	// - state
	// - national
	// - special
	//
	// Max Length: 15
	Type string `json:"type,omitempty"`
}

// Validate validates this calculate tax created body order information tax details items0
func (o *CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("type", "body", o.Type, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax created body order information tax details items0 based on context it is used
func (o *CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyOrderInformationTaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxCreatedBodyTaxInformation calculate tax created body tax information
swagger:model CalculateTaxCreatedBodyTaxInformation
*/
type CalculateTaxCreatedBodyTaxInformation struct {

	// Indicates whether this is a committed tax transaction. For a committed tax transaction, the status in the Tax Detail Report is "Committed." For an uncommitted tax transaction, the status in the Tax Detail Report is "Uncommitted." Possible values:
	// - `true`: This is a committed tax transaction.
	// - `false` (default): This is not a committed tax transaction.
	//
	// A committed tax request is a tax service request that sets the status field in the Tax Detail Report to committed.
	// The committed status indicates that the amount calculated by the tax service is included in the amount of a capture or credit.
	//
	// Use a void service request to cancel a committed tax request or a committed refund tax request. The void transaction is included as a separate entry in the Tax Detail Report. The value of the status field is cancelled. The value of the link ID is the request ID of the committed tax request or refund tax request that was voided. You can use the value of the link ID to reconcile your orders.
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	// For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html).
	//
	CommitIndicator bool `json:"commitIndicator,omitempty"`

	// Indicates whether this is a refund tax transaction. For a refund tax transaction, amounts in the Tax Detail Report will be negative.
	// Possible values:
	// - `true`: This is a refund tax transaction.
	// - `false` (default): This is not a refund tax transaction.
	//
	// A refund tax request is a tax service request that sets the transaction type field in the Tax Detail Report to refunded and makes the reported amount negative.
	// Tax amounts are returned as positive amounts in reply messages, but they are saved in reports as negative amounts which enables the reporting software to accurately calculate the aggregate amounts.
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	// For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html).
	//
	RefundIndicator bool `json:"refundIndicator,omitempty"`
}

// Validate validates this calculate tax created body tax information
func (o *CalculateTaxCreatedBodyTaxInformation) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this calculate tax created body tax information based on context it is used
func (o *CalculateTaxCreatedBodyTaxInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyTaxInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxCreatedBodyTaxInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxCreatedBodyTaxInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyBuyerInformation calculate tax params body buyer information
swagger:model CalculateTaxParamsBodyBuyerInformation
*/
type CalculateTaxParamsBodyBuyerInformation struct {

	// Customer's government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this calculate tax params body buyer information
func (o *CalculateTaxParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body buyer information based on context it is used
func (o *CalculateTaxParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyClientReferenceInformation calculate tax params body client reference information
swagger:model CalculateTaxParamsBodyClientReferenceInformation
*/
type CalculateTaxParamsBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *CalculateTaxParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this calculate tax params body client reference information
func (o *CalculateTaxParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this calculate tax params body client reference information based on the context it is used
func (o *CalculateTaxParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {

		if swag.IsZero(o.Partner) { // not required
			return nil
		}

		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyClientReferenceInformationPartner calculate tax params body client reference information partner
swagger:model CalculateTaxParamsBodyClientReferenceInformationPartner
*/
type CalculateTaxParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this calculate tax params body client reference information partner
func (o *CalculateTaxParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body client reference information partner based on context it is used
func (o *CalculateTaxParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyMerchantInformation calculate tax params body merchant information
swagger:model CalculateTaxParamsBodyMerchantInformation
*/
type CalculateTaxParamsBodyMerchantInformation struct {

	// Your government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Required field for value added tax only. Not applicable to U.S. and Canadian taxes.
	//
	// #### CyberSource through VisaNet
	// For CtV processors, the maximum length is 20.
	//
	// For other processor-specific information, see the `merchant_vat_registration_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 21
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this calculate tax params body merchant information
func (o *CalculateTaxParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyMerchantInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"merchantInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 21); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body merchant information based on context it is used
func (o *CalculateTaxParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformation calculate tax params body order information
swagger:model CalculateTaxParamsBodyOrderInformation
*/
type CalculateTaxParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *CalculateTaxParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *CalculateTaxParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// invoice details
	InvoiceDetails *CalculateTaxParamsBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// line items
	LineItems []*CalculateTaxParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// order acceptance
	OrderAcceptance *CalculateTaxParamsBodyOrderInformationOrderAcceptance `json:"orderAcceptance,omitempty"`

	// order origin
	OrderOrigin *CalculateTaxParamsBodyOrderInformationOrderOrigin `json:"orderOrigin,omitempty"`

	// ship to
	ShipTo *CalculateTaxParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// shipping details
	ShippingDetails *CalculateTaxParamsBodyOrderInformationShippingDetails `json:"shippingDetails,omitempty"`
}

// Validate validates this calculate tax params body order information
func (o *CalculateTaxParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderAcceptance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateOrderAcceptance(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderAcceptance) { // not required
		return nil
	}

	if o.OrderAcceptance != nil {
		if err := o.OrderAcceptance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderAcceptance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderAcceptance")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateOrderOrigin(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderOrigin) { // not required
		return nil
	}

	if o.OrderOrigin != nil {
		if err := o.OrderOrigin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderOrigin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderOrigin")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) validateShippingDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingDetails) { // not required
		return nil
	}

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this calculate tax params body order information based on the context it is used
func (o *CalculateTaxParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderAcceptance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderOrigin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {

		if swag.IsZero(o.BillTo) { // not required
			return nil
		}

		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {

		if swag.IsZero(o.InvoiceDetails) { // not required
			return nil
		}

		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {

			if swag.IsZero(o.LineItems[i]) { // not required
				return nil
			}

			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateOrderAcceptance(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderAcceptance != nil {

		if swag.IsZero(o.OrderAcceptance) { // not required
			return nil
		}

		if err := o.OrderAcceptance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderAcceptance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderAcceptance")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateOrderOrigin(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderOrigin != nil {

		if swag.IsZero(o.OrderOrigin) { // not required
			return nil
		}

		if err := o.OrderOrigin.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderOrigin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "orderOrigin")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {

		if swag.IsZero(o.ShipTo) { // not required
			return nil
		}

		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformation) contextValidateShippingDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingDetails != nil {

		if swag.IsZero(o.ShippingDetails) { // not required
			return nil
		}

		if err := o.ShippingDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("taxRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationAmountDetails calculate tax params body order information amount details
swagger:model CalculateTaxParamsBodyOrderInformationAmountDetails
*/
type CalculateTaxParamsBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`
}

// Validate validates this calculate tax params body order information amount details
func (o *CalculateTaxParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information amount details based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationBillTo calculate tax params body order information bill to
swagger:model CalculateTaxParamsBodyOrderInformationBillTo
*/
type CalculateTaxParamsBodyOrderInformationBillTo struct {

	// First line of the billing street address.
	//
	// #### Tax Calculation
	// Required for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the billing street address.
	//
	// #### Tax Calculation
	// Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// Credit card billing state or province.
	//
	// #### Tax Calculation
	// Required for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Credit card billing country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// If `orderInformation.shipTo.country` is not provided, `orderInformation.billTo.country` is used in its place. If  `orderInformation.billTo.country` is set to `US` or `CA`, then `orderInformation.billTo.postalCode` and `orderInformation.billTo.administrativeArea` are also required.
	//
	// #### Tax Calculation
	// Required for U.S., Canadian, international and value added taxes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Credit card billing city.
	//
	// #### Tax Calculation
	// Required for U.S. and Canadian taxes only. Not applicable to international and value added taxes.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	// If the billing country is the U.S., the 9-digit postal code must follow this format:
	//
	// [5 digits][dash][4 digits]
	//
	// **Example**: 12345-6789
	//
	// If the billing country is Canada, the 6-digit postal code must follow this format:
	//
	// [alpha][numeric][alpha] [numeric][alpha][numeric]
	//
	// **Example**: A1B 2C3
	//
	// #### Tax Calculation
	// Required for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this calculate tax params body order information bill to
func (o *CalculateTaxParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information bill to based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationInvoiceDetails calculate tax params body order information invoice details
swagger:model CalculateTaxParamsBodyOrderInformationInvoiceDetails
*/
type CalculateTaxParamsBodyOrderInformationInvoiceDetails struct {

	// Date of the tax calculation. Use format YYYYMMDD. You can provide a date in the past if you are calculating tax for a refund and want to know what the tax was on the date the order was placed.
	// You can provide a date in the future if you are calculating the tax for a future date, such as an upcoming tax holiday.
	//
	// The default is the date, in Pacific time, that the bank receives the request.
	// Keep this in mind if you are in a different time zone and want the tax calculated with the rates that are applicable on a specific date.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 8
	InvoiceDate string `json:"invoiceDate,omitempty"`
}

// Validate validates this calculate tax params body order information invoice details
func (o *CalculateTaxParamsBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInvoiceDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationInvoiceDetails) validateInvoiceDate(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"invoiceDate", "body", o.InvoiceDate, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information invoice details based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationLineItemsItems0 calculate tax params body order information line items items0
swagger:model CalculateTaxParamsBodyOrderInformationLineItemsItems0
*/
type CalculateTaxParamsBodyOrderInformationLineItemsItems0 struct {

	// Buyer's VAT registration number.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for international and value added taxes only. Not applicable to U.S. and Canadian taxes.
	//
	// Max Length: 25
	BuyerVatRegistrationNumber string `json:"buyerVatRegistrationNumber,omitempty"`

	// order acceptance
	OrderAcceptance *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance `json:"orderAcceptance,omitempty"`

	// order origin
	OrderOrigin *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin `json:"orderOrigin,omitempty"`

	// Type of product. The value for this field is used to identify the product category (electronic, handling, physical,
	// service, or shipping). The default value is `default`.
	//
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set
	// this field to a value other than `default` or one of the values related to shipping and/or handling, then
	// `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and
	// `orderInformation.lineItems[].productSku` fields are required.
	//
	// Optional field.
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don't send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you've indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields].
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is
	// required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSKU string `json:"productSKU,omitempty"`

	// Number of units for this order. Must be a non-negative integer.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values
	// related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Maximum: 9.99999999e+08
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// VAT seller registration number.
	//
	// For details, see "International Taxes and Value-Added Tax (VAT)" in [Tax Calculation Service Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/Tax_SCMP_API/html/).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for international and value added taxes only. Not applicable to U.S. and Canadian taxes.
	//
	// Max Length: 25
	SellerVatRegistrationNumber string `json:"sellerVatRegistrationNumber,omitempty"`

	// State from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromCountry` are present. Use the [State, Province, and Territory Codes for the United States and Canada](http://apps.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	ShipFromAdministrativeArea string `json:"shipFromAdministrativeArea,omitempty"`

	// Country from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromAdministrativeArea` are present. Use the [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/ or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 2
	ShipFromCountry string `json:"shipFromCountry,omitempty"`

	// City where the product is shipped from.
	// This field is used only when the `orderInformation.shipTo.administrativeArea` and `orderInformation.shipTo.country` fields are present.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 50
	ShipFromLocality string `json:"shipFromLocality,omitempty"`

	// Postal code where the product is shipped from.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// Optional field.
	//
	// #### Airlines processing
	// Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s).
	// Format: English characters only.
	// Optional request field for a line item.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Note if you send this field in your tax request, the value in the field will override the tax engine
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Tax Calculation
	// Required field for U.S., Canadian, international and value added taxes.
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`
}

// Validate validates this calculate tax params body order information line items items0
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBuyerVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderAcceptance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSKU(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSellerVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipFromAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipFromCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipFromLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateBuyerVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerVatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("buyerVatRegistrationNumber", "body", o.BuyerVatRegistrationNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateOrderAcceptance(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderAcceptance) { // not required
		return nil
	}

	if o.OrderAcceptance != nil {
		if err := o.OrderAcceptance.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("orderAcceptance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("orderAcceptance")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateOrderOrigin(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderOrigin) { // not required
		return nil
	}

	if o.OrderOrigin != nil {
		if err := o.OrderOrigin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("orderOrigin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("orderOrigin")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", o.ProductCode, 255); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", o.ProductName, 255); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateProductSKU(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductSKU) { // not required
		return nil
	}

	if err := validate.MaxLength("productSKU", "body", o.ProductSKU, 255); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {
	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", o.Quantity, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", o.Quantity, 9.99999999e+08, false); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateSellerVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.SellerVatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("sellerVatRegistrationNumber", "body", o.SellerVatRegistrationNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateShipFromAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromAdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("shipFromAdministrativeArea", "body", o.ShipFromAdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateShipFromCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromCountry) { // not required
		return nil
	}

	if err := validate.MaxLength("shipFromCountry", "body", o.ShipFromCountry, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateShipFromLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromLocality) { // not required
		return nil
	}

	if err := validate.MaxLength("shipFromLocality", "body", o.ShipFromLocality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateShipFromPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("shipFromPostalCode", "body", o.ShipFromPostalCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", o.UnitPrice, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this calculate tax params body order information line items items0 based on the context it is used
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateOrderAcceptance(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderOrigin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) contextValidateOrderAcceptance(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderAcceptance != nil {

		if swag.IsZero(o.OrderAcceptance) { // not required
			return nil
		}

		if err := o.OrderAcceptance.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("orderAcceptance")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("orderAcceptance")
			}
			return err
		}
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) contextValidateOrderOrigin(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderOrigin != nil {

		if swag.IsZero(o.OrderOrigin) { // not required
			return nil
		}

		if err := o.OrderOrigin.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("orderOrigin")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("orderOrigin")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance The Order Acceptance address fields may be used by the tax service to determine the taxability of the order or applicable taxing jurisdictions. You should consult your tax, legal and/or accounting advisors to determine if you should include an Order Acceptance address in your tax service request for some or all of your transactions based on your business.
swagger:model CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance
*/
type CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance struct {

	// Order acceptance state. This field is not used unless the `orderInformation.orderAcceptance.locality` and `orderInformation.orderAcceptance.country` fields are present. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Order acceptance country. This field is not used unless the `orderInformation.orderAcceptance.administrativeArea` and `orderInformation.orderAcceptance.locality` fields are present. Use the [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Order acceptance city. This field is not used unless the `orderInformation.orderAcceptance.administrativeArea` and `orderInformation.orderAcceptance.country` fields are present.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Order acceptance postal code. This field is not used unless the `orderInformation.orderAcceptance.locality`, `orderInformation.orderAcceptance.administrativeArea`, and `orderInformation.orderAcceptance.country` fields are present.
	// Must be sent at the line or offer level to be surfaced in the Tax Detail Report.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this calculate tax params body order information line items items0 order acceptance
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("orderAcceptance"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("orderAcceptance"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("orderAcceptance"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("orderAcceptance"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information line items items0 order acceptance based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderAcceptance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin The Order Origin address fields may be used by the tax service to determine the taxability of the order or applicable taxing jurisdictions. You should consult your tax, legal and/or accounting advisors to determine if you should include an Order Origin address in your tax service request for some or all of your transactions based on your business.
swagger:model CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin
*/
type CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin struct {

	// Order origin state. This field is not used unless the `orderInformation.orderOrigin.locality` and `orderInformation.orderOrigin.country` fields are present. Use the [State, Province, and Territory Codes for the United States and Canada](http://apps.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Order origin country. This field is not used unless the `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.locality` fields are present. Use the [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Order origin city. This field is not used unless the `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.country` fields are present.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Order origin postal code. This field is not used unless the `orderInformation.orderOrigin.locality`, `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.country` fields are present.
	// Must be sent at the lineItem level to appear in the Tax Detail Report.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this calculate tax params body order information line items items0 order origin
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("orderOrigin"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("orderOrigin"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("orderOrigin"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("orderOrigin"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information line items items0 order origin based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationLineItemsItems0OrderOrigin
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationOrderAcceptance The Order Acceptance address fields may be used by the tax service to determine the taxability of the order or applicable taxing jurisdictions. You should consult your tax, legal and/or accounting advisors to determine if you should include an Order Acceptance address in your tax service request for some or all of your transactions based on your business.
swagger:model CalculateTaxParamsBodyOrderInformationOrderAcceptance
*/
type CalculateTaxParamsBodyOrderInformationOrderAcceptance struct {

	// Order acceptance state. This field is not used unless the `orderInformation.orderAcceptance.locality` and `orderInformation.orderAcceptance.country` fields are present. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Order acceptance country. This field is not used unless the `orderInformation.orderAcceptance.administrativeArea` and `orderInformation.orderAcceptance.locality` fields are present. Use the [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Order acceptance city. This field is not used unless the `orderInformation.orderAcceptance.administrativeArea` and `orderInformation.orderAcceptance.country` fields are present.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Order acceptance postal code. This field is not used unless the `orderInformation.orderAcceptance.locality`, `orderInformation.orderAcceptance.administrativeArea`, and `orderInformation.orderAcceptance.country` fields are present.
	// Must be sent at the line or offer level to be surfaced in the Tax Detail Report.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this calculate tax params body order information order acceptance
func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderAcceptance"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderAcceptance"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderAcceptance"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderAcceptance"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information order acceptance based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationOrderAcceptance) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationOrderAcceptance
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationOrderOrigin The Order Origin address fields may be used by the tax service to determine the taxability of the order or applicable taxing jurisdictions. You should consult your tax, legal and/or accounting advisors to determine if you should include an Order Origin address in your tax service request for some or all of your transactions based on your business.
swagger:model CalculateTaxParamsBodyOrderInformationOrderOrigin
*/
type CalculateTaxParamsBodyOrderInformationOrderOrigin struct {

	// Order origin state. This field is not used unless the `orderInformation.orderOrigin.locality` and `orderInformation.orderOrigin.country` fields are present. Use the [State, Province, and Territory Codes for the United States and Canada](http://apps.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Order origin country. This field is not used unless the `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.locality` fields are present. Use the [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Order origin city. This field is not used unless the `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.country` fields are present.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Order origin postal code. This field is not used unless the `orderInformation.orderOrigin.locality`, `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.country` fields are present.
	// Must be sent at the lineItem level to appear in the Tax Detail Report.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this calculate tax params body order information order origin
func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderOrigin"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderOrigin"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderOrigin"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"orderOrigin"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information order origin based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationOrderOrigin) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationOrderOrigin
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationShipTo calculate tax params body order information ship to
swagger:model CalculateTaxParamsBodyOrderInformationShipTo
*/
type CalculateTaxParamsBodyOrderInformationShipTo struct {

	// First line of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	//
	// Optional field.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// Third line of the shipping address.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 60
	Address3 string `json:"address3,omitempty"`

	// State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S.
	// or Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// City of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or
	// Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// Required field for authorization if any shipping address information is included in the request and
	// shipping to the U.S. or Canada; otherwise, optional.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the
	// remaining value is longer than nine characters, the value is truncated starting from the right side.
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder's location when shipTo objects are not present.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this calculate tax params body order information ship to
func (o *CalculateTaxParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress3(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShipTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShipTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShipTo) validateAddress3(formats strfmt.Registry) error {
	if swag.IsZero(o.Address3) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address3", "body", o.Address3, 60); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShipTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information ship to based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyOrderInformationShippingDetails calculate tax params body order information shipping details
swagger:model CalculateTaxParamsBodyOrderInformationShippingDetails
*/
type CalculateTaxParamsBodyOrderInformationShippingDetails struct {

	// State from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromCountry` are present. Use the [State, Province, and Territory Codes for the United States and Canada](http://apps.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 2
	ShipFromAdministrativeArea string `json:"shipFromAdministrativeArea,omitempty"`

	// Country from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromAdministrativeArea` are present. Use the [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/ or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 2
	ShipFromCountry string `json:"shipFromCountry,omitempty"`

	// City where the product is shipped from.
	// This field is used only when the `orderInformation.shipTo.administrativeArea` and `orderInformation.shipTo.country` fields are present.
	//
	// **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 50
	ShipFromLocality string `json:"shipFromLocality,omitempty"`

	// Postal code where the product is shipped from.
	//
	// #### Tax Calculation
	// This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.
	//
	// Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`
}

// Validate validates this calculate tax params body order information shipping details
func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShipFromAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipFromCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipFromLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) validateShipFromAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromAdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromAdministrativeArea", "body", o.ShipFromAdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) validateShipFromCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromCountry) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromCountry", "body", o.ShipFromCountry, 2); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) validateShipFromLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromLocality) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromLocality", "body", o.ShipFromLocality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) validateShipFromPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromPostalCode", "body", o.ShipFromPostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body order information shipping details based on context it is used
func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyOrderInformationShippingDetails) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyOrderInformationShippingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CalculateTaxParamsBodyTaxInformation calculate tax params body tax information
swagger:model CalculateTaxParamsBodyTaxInformation
*/
type CalculateTaxParamsBodyTaxInformation struct {

	// Indicates whether this is a committed tax transaction. For a committed tax transaction, the status in the Tax Detail Report is "Committed." For an uncommitted tax transaction, the status in the Tax Detail Report is "Uncommitted." Possible values:
	// - `true`: This is a committed tax transaction.
	// - `false` (default): This is not a committed tax transaction.
	//
	// A committed tax request is a tax service request that sets the status field in the Tax Detail Report to committed.
	// The committed status indicates that the amount calculated by the tax service is included in the amount of a capture or credit.
	//
	// Use a void service request to cancel a committed tax request or a committed refund tax request. The void transaction is included as a separate entry in the Tax Detail Report. The value of the status field is cancelled. The value of the link ID is the request ID of the committed tax request or refund tax request that was voided. You can use the value of the link ID to reconcile your orders.
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	// For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html).
	//
	CommitIndicator bool `json:"commitIndicator,omitempty"`

	// If a past or future date is specified in `orderInformation.invoiceDetails.invoiceDate`, then provide the reason for that for audit purposes.
	// Typical reasons include: 'Return', 'Layaway', 'Imported'.
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 50
	DateOverrideReason string `json:"dateOverrideReason,omitempty"`

	// Comma-separated list of states or provinces in which merchandise is taxable. Note merchandise may be still be non-taxable or tax exempt depending on the product taxability. Indicate the type of product you are selling in the product code field for product-level taxability rules to be applied. Do not use both the `taxInformation.nexus` and `taxInformation.noNexus` fields in your request. If you do not include this field in a tax calculation service request, the tax system makes its calculations as if you have nexus in every US state or Canadian province. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// If you indicate you do not have nexus in the destination state, jurisdiction level fields are left blank in the Tax Detail Report.
	//
	// Optional field for U.S. and Canadian taxes only. Either this field or `taxInformation.noNexus` is required if you do not have nexus in every state or province.
	//
	// Not applicable for international and value added taxes.
	//
	Nexus []string `json:"nexus"`

	// Comma-separated list of states or provinces where you do not have nexus. Check with a tax advisor to determine where your business has nexus. Do not use both the `taxInformation.nexus` and `taxInformation.noNexus` fields in your request. If you do not include this field in a tax calculation service request, the tax system makes its calculations as if you have nexus in every US state or Canadian province.
	// Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// If you indicate you do not have nexus in the destination state, jurisdiction level fields are left blank in the Tax Detail Report.
	//
	// Optional field for U.S. and Canadian taxes only. Either this field or `taxInformation.nexus` is required if you do not have nexus in every state or province.
	//
	// Not applicable for international and value added taxes.
	//
	NoNexus []string `json:"noNexus"`

	// Indicates whether this is a refund tax transaction. For a refund tax transaction, amounts in the Tax Detail Report will be negative.
	// Possible values:
	// - `true`: This is a refund tax transaction.
	// - `false` (default): This is not a refund tax transaction.
	//
	// A refund tax request is a tax service request that sets the transaction type field in the Tax Detail Report to refunded and makes the reported amount negative.
	// Tax amounts are returned as positive amounts in reply messages, but they are saved in reports as negative amounts which enables the reporting software to accurately calculate the aggregate amounts.
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	// For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html).
	//
	RefundIndicator bool `json:"refundIndicator,omitempty"`

	// Reporting date of transaction. Format: YYYYMMDD. Defaults to current date if not specified.
	// Optional for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 8
	ReportingDate string `json:"reportingDate,omitempty"`

	// Whether or not to display tax amounts for each line item. This field can contain one of the following values:
	// - `Yes` - Display tax amounts for each line item
	// - `No` (default) - Do not display tax amounts for each line item
	//
	// Optional for U.S., Canadian, international tax, and value added taxes.
	//
	ShowTaxPerLineItem string `json:"showTaxPerLineItem,omitempty"`
}

// Validate validates this calculate tax params body tax information
func (o *CalculateTaxParamsBodyTaxInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDateOverrideReason(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNexus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNoNexus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReportingDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CalculateTaxParamsBodyTaxInformation) validateDateOverrideReason(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOverrideReason) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"taxInformation"+"."+"dateOverrideReason", "body", o.DateOverrideReason, 50); err != nil {
		return err
	}

	return nil
}

func (o *CalculateTaxParamsBodyTaxInformation) validateNexus(formats strfmt.Registry) error {
	if swag.IsZero(o.Nexus) { // not required
		return nil
	}

	for i := 0; i < len(o.Nexus); i++ {

		if err := validate.MaxLength("taxRequest"+"."+"taxInformation"+"."+"nexus"+"."+strconv.Itoa(i), "body", o.Nexus[i], 2); err != nil {
			return err
		}

	}

	return nil
}

func (o *CalculateTaxParamsBodyTaxInformation) validateNoNexus(formats strfmt.Registry) error {
	if swag.IsZero(o.NoNexus) { // not required
		return nil
	}

	for i := 0; i < len(o.NoNexus); i++ {

		if err := validate.MaxLength("taxRequest"+"."+"taxInformation"+"."+"noNexus"+"."+strconv.Itoa(i), "body", o.NoNexus[i], 2); err != nil {
			return err
		}

	}

	return nil
}

func (o *CalculateTaxParamsBodyTaxInformation) validateReportingDate(formats strfmt.Registry) error {
	if swag.IsZero(o.ReportingDate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRequest"+"."+"taxInformation"+"."+"reportingDate", "body", o.ReportingDate, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this calculate tax params body tax information based on context it is used
func (o *CalculateTaxParamsBodyTaxInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CalculateTaxParamsBodyTaxInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CalculateTaxParamsBodyTaxInformation) UnmarshalBinary(b []byte) error {
	var res CalculateTaxParamsBodyTaxInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
