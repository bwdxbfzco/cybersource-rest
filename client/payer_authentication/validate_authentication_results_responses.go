// Code generated by go-swagger; DO NOT EDIT.

package payer_authentication

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ValidateAuthenticationResultsReader is a Reader for the ValidateAuthenticationResults structure.
type ValidateAuthenticationResultsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *ValidateAuthenticationResultsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewValidateAuthenticationResultsCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewValidateAuthenticationResultsBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewValidateAuthenticationResultsBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[POST /risk/v1/authentication-results] validateAuthenticationResults", response, response.Code())
	}
}

// NewValidateAuthenticationResultsCreated creates a ValidateAuthenticationResultsCreated with default headers values
func NewValidateAuthenticationResultsCreated() *ValidateAuthenticationResultsCreated {
	return &ValidateAuthenticationResultsCreated{}
}

/*
ValidateAuthenticationResultsCreated describes a response with status code 201, with default header values.

Successful response
*/
type ValidateAuthenticationResultsCreated struct {
	Payload *ValidateAuthenticationResultsCreatedBody
}

// IsSuccess returns true when this validate authentication results created response has a 2xx status code
func (o *ValidateAuthenticationResultsCreated) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this validate authentication results created response has a 3xx status code
func (o *ValidateAuthenticationResultsCreated) IsRedirect() bool {
	return false
}

// IsClientError returns true when this validate authentication results created response has a 4xx status code
func (o *ValidateAuthenticationResultsCreated) IsClientError() bool {
	return false
}

// IsServerError returns true when this validate authentication results created response has a 5xx status code
func (o *ValidateAuthenticationResultsCreated) IsServerError() bool {
	return false
}

// IsCode returns true when this validate authentication results created response a status code equal to that given
func (o *ValidateAuthenticationResultsCreated) IsCode(code int) bool {
	return code == 201
}

// Code gets the status code for the validate authentication results created response
func (o *ValidateAuthenticationResultsCreated) Code() int {
	return 201
}

func (o *ValidateAuthenticationResultsCreated) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /risk/v1/authentication-results][%d] validateAuthenticationResultsCreated %s", 201, payload)
}

func (o *ValidateAuthenticationResultsCreated) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /risk/v1/authentication-results][%d] validateAuthenticationResultsCreated %s", 201, payload)
}

func (o *ValidateAuthenticationResultsCreated) GetPayload() *ValidateAuthenticationResultsCreatedBody {
	return o.Payload
}

func (o *ValidateAuthenticationResultsCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ValidateAuthenticationResultsCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewValidateAuthenticationResultsBadRequest creates a ValidateAuthenticationResultsBadRequest with default headers values
func NewValidateAuthenticationResultsBadRequest() *ValidateAuthenticationResultsBadRequest {
	return &ValidateAuthenticationResultsBadRequest{}
}

/*
ValidateAuthenticationResultsBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type ValidateAuthenticationResultsBadRequest struct {
	Payload *ValidateAuthenticationResultsBadRequestBody
}

// IsSuccess returns true when this validate authentication results bad request response has a 2xx status code
func (o *ValidateAuthenticationResultsBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this validate authentication results bad request response has a 3xx status code
func (o *ValidateAuthenticationResultsBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this validate authentication results bad request response has a 4xx status code
func (o *ValidateAuthenticationResultsBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this validate authentication results bad request response has a 5xx status code
func (o *ValidateAuthenticationResultsBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this validate authentication results bad request response a status code equal to that given
func (o *ValidateAuthenticationResultsBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the validate authentication results bad request response
func (o *ValidateAuthenticationResultsBadRequest) Code() int {
	return 400
}

func (o *ValidateAuthenticationResultsBadRequest) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /risk/v1/authentication-results][%d] validateAuthenticationResultsBadRequest %s", 400, payload)
}

func (o *ValidateAuthenticationResultsBadRequest) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /risk/v1/authentication-results][%d] validateAuthenticationResultsBadRequest %s", 400, payload)
}

func (o *ValidateAuthenticationResultsBadRequest) GetPayload() *ValidateAuthenticationResultsBadRequestBody {
	return o.Payload
}

func (o *ValidateAuthenticationResultsBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ValidateAuthenticationResultsBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewValidateAuthenticationResultsBadGateway creates a ValidateAuthenticationResultsBadGateway with default headers values
func NewValidateAuthenticationResultsBadGateway() *ValidateAuthenticationResultsBadGateway {
	return &ValidateAuthenticationResultsBadGateway{}
}

/*
ValidateAuthenticationResultsBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type ValidateAuthenticationResultsBadGateway struct {
	Payload *ValidateAuthenticationResultsBadGatewayBody
}

// IsSuccess returns true when this validate authentication results bad gateway response has a 2xx status code
func (o *ValidateAuthenticationResultsBadGateway) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this validate authentication results bad gateway response has a 3xx status code
func (o *ValidateAuthenticationResultsBadGateway) IsRedirect() bool {
	return false
}

// IsClientError returns true when this validate authentication results bad gateway response has a 4xx status code
func (o *ValidateAuthenticationResultsBadGateway) IsClientError() bool {
	return false
}

// IsServerError returns true when this validate authentication results bad gateway response has a 5xx status code
func (o *ValidateAuthenticationResultsBadGateway) IsServerError() bool {
	return true
}

// IsCode returns true when this validate authentication results bad gateway response a status code equal to that given
func (o *ValidateAuthenticationResultsBadGateway) IsCode(code int) bool {
	return code == 502
}

// Code gets the status code for the validate authentication results bad gateway response
func (o *ValidateAuthenticationResultsBadGateway) Code() int {
	return 502
}

func (o *ValidateAuthenticationResultsBadGateway) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /risk/v1/authentication-results][%d] validateAuthenticationResultsBadGateway %s", 502, payload)
}

func (o *ValidateAuthenticationResultsBadGateway) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /risk/v1/authentication-results][%d] validateAuthenticationResultsBadGateway %s", 502, payload)
}

func (o *ValidateAuthenticationResultsBadGateway) GetPayload() *ValidateAuthenticationResultsBadGatewayBody {
	return o.Payload
}

func (o *ValidateAuthenticationResultsBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ValidateAuthenticationResultsBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*
ValidateAuthenticationResultsBadGatewayBody riskV1AuthenticationResultsPost502Response
swagger:model ValidateAuthenticationResultsBadGatewayBody
*/
type ValidateAuthenticationResultsBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this validate authentication results bad gateway body
func (o *ValidateAuthenticationResultsBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate authentication results bad gateway body based on context it is used
func (o *ValidateAuthenticationResultsBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsBadRequestBody riskV1AuthenticationResultsPost400Response
swagger:model ValidateAuthenticationResultsBadRequestBody
*/
type ValidateAuthenticationResultsBadRequestBody struct {

	// details
	Details []*ValidateAuthenticationResultsBadRequestBodyDetailsItems0 `json:"details"`

	// The message describing the reason of the status. Value is:
	// - Encountered a Payer Authentication problem. Payer could not be authenticated.
	//
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible Values:
	// - `MISSING_FIELD`
	// - `INVALID_DATA`
	//
	Reason string `json:"reason,omitempty"`

	// The status for payerAuthentication 201 enroll and validate calls. Value is:
	// - `INVALID_REQUEST`
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this validate authentication results bad request body
func (o *ValidateAuthenticationResultsBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateAuthenticationResultsBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateAuthenticationResultsBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this validate authentication results bad request body based on the context it is used
func (o *ValidateAuthenticationResultsBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateAuthenticationResultsBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateAuthenticationResultsBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBadRequestBody) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsBadRequestBodyDetailsItems0 validate authentication results bad request body details items0
swagger:model ValidateAuthenticationResultsBadRequestBodyDetailsItems0
*/
type ValidateAuthenticationResultsBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this validate authentication results bad request body details items0
func (o *ValidateAuthenticationResultsBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate authentication results bad request body details items0 based on context it is used
func (o *ValidateAuthenticationResultsBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsBody validate authentication results body
swagger:model ValidateAuthenticationResultsBody
*/
type ValidateAuthenticationResultsBody struct {

	// client reference information
	ClientReferenceInformation *ValidateAuthenticationResultsParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// device information
	DeviceInformation *ValidateAuthenticationResultsParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// order information
	OrderInformation *ValidateAuthenticationResultsParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *ValidateAuthenticationResultsParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// processing information
	ProcessingInformation *ValidateAuthenticationResultsParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// token information
	TokenInformation *ValidateAuthenticationResultsParamsBodyTokenInformation `json:"tokenInformation,omitempty"`
}

// Validate validates this validate authentication results body
func (o *ValidateAuthenticationResultsBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) validateDeviceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) validateTokenInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenInformation) { // not required
		return nil
	}

	if o.TokenInformation != nil {
		if err := o.TokenInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate authentication results body based on the context it is used
func (o *ValidateAuthenticationResultsBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConsumerAuthenticationInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeviceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) contextValidateConsumerAuthenticationInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ConsumerAuthenticationInformation != nil {

		if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
			return nil
		}

		if err := o.ConsumerAuthenticationInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) contextValidateDeviceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.DeviceInformation != nil {

		if swag.IsZero(o.DeviceInformation) { // not required
			return nil
		}

		if err := o.DeviceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {

		if swag.IsZero(o.OrderInformation) { // not required
			return nil
		}

		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {

		if swag.IsZero(o.PaymentInformation) { // not required
			return nil
		}

		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {

		if swag.IsZero(o.ProcessingInformation) { // not required
			return nil
		}

		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsBody) contextValidateTokenInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenInformation != nil {

		if swag.IsZero(o.TokenInformation) { // not required
			return nil
		}

		if err := o.TokenInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsBody) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBody riskV1AuthenticationResultsPost201Response
swagger:model ValidateAuthenticationResultsCreatedBody
*/
type ValidateAuthenticationResultsCreatedBody struct {

	// links
	Links *ValidateAuthenticationResultsCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// error information
	ErrorInformation *ValidateAuthenticationResultsCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The message describing the reason of the status. Value is:
	// - The cardholder is enrolled in Payer Authentication. Please authenticate
	// the cardholder before continuing with the transaction.
	//
	Message string `json:"message,omitempty"`

	// The status for payerAuthentication 201 enroll and validate calls. Possible values are:
	// - `AUTHENTICATION_SUCCESSFUL`
	// - `PENDING_AUTHENTICATION`
	// - `INVALID_REQUEST`
	// - `AUTHENTICATION_FAILED`
	//
	Status string `json:"status,omitempty"`

	// Time that the transaction was submitted in local time. Generated by Cybersource.
	SubmitTimeLocal string `json:"submitTimeLocal,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this validate authentication results created body
func (o *ValidateAuthenticationResultsCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this validate authentication results created body based on the context it is used
func (o *ValidateAuthenticationResultsCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConsumerAuthenticationInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {

		if swag.IsZero(o.Links) { // not required
			return nil
		}

		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {

		if swag.IsZero(o.ClientReferenceInformation) { // not required
			return nil
		}

		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) contextValidateConsumerAuthenticationInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ConsumerAuthenticationInformation != nil {

		if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
			return nil
		}

		if err := o.ConsumerAuthenticationInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {

		if swag.IsZero(o.ErrorInformation) { // not required
			return nil
		}

		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBody) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBodyClientReferenceInformation validate authentication results created body client reference information
swagger:model ValidateAuthenticationResultsCreatedBodyClientReferenceInformation
*/
type ValidateAuthenticationResultsCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this validate authentication results created body client reference information
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"clientReferenceInformation"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate authentication results created body client reference information based on the context it is used
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {

		if swag.IsZero(o.Partner) { // not required
			return nil
		}

		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner validate authentication results created body client reference information partner
swagger:model ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner
*/
type ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this validate authentication results created body client reference information partner
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results created body client reference information partner based on context it is used
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation validate authentication results created body consumer authentication information
swagger:model ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation
*/
type ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation struct {

	// Identifies the UI Type the ACS will use to complete the challenge. **NOTE**: Only available for App transactions using the Cardinal Mobile SDK.
	//
	AcsRenderingType string `json:"acsRenderingType,omitempty"`

	// Unique transaction identifier assigned by the ACS to identify a single transaction.
	//
	// Max Length: 36
	AcsTransactionID string `json:"acsTransactionId,omitempty"`

	// Raw authentication data that comes from the cardissuing bank. Primary authentication field that
	// indicates if authentication was successful and if liability shift occurred. You should examine first the
	// result of this field. This field contains one of these values:
	// - `-1`: Invalid PARes.
	// - `0`: Successful validation.
	// - `1`: Cardholder is not participating, but the attempt to authenticate was recorded.
	// - `6`: Issuer unable to perform authentication.
	// - `9`: Cardholder did not complete authentication.
	//
	AuthenticationResult string `json:"authenticationResult,omitempty"`

	// Message that explains the authenticationResult reply field.
	//
	AuthenticationStatusMsg string `json:"authenticationStatusMsg,omitempty"`

	// Payer authentication transaction identifier passed to link the validation and authorization calls.
	//
	// Max Length: 30
	AuthenticationTransactionContextID string `json:"authenticationTransactionContextId,omitempty"`

	// Payer authentication transaction identifier is used to link the check
	// enrollment and validate authentication messages. For Rupay, this field should be passed as request only for Resend OTP use case.
	//
	// Max Length: 26
	AuthenticationTransactionID string `json:"authenticationTransactionId,omitempty"`

	// The Base64 encoded JSON Payload of CB specific Authorization Values returned in the challenge Flow
	//
	AuthorizationPayload string `json:"authorizationPayload,omitempty"`

	// Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and
	// Discover transactions after the customer is authenticated. The value is in base64. When you
	// request the card authorization service, CyberSource automatically converts the value, not the field name,
	// to the format required by your payment processor.
	//
	// Max Length: 255
	Cavv string `json:"cavv,omitempty"`

	// Field that is returned only when the CAVV is generated, which occurs when paresStatus
	// contains the values Y (successful authentication) or A (attempted authentication). If
	// you use the ATOS processor, send the value of this field in the `cavv_algorithm` request field of the
	// authorization service. This field contains one of these values:
	// - `2`: Visa, American Express, JCB, Diners Club, and Discover
	// - `3`: Mastercard
	//
	// Max Length: 1
	CavvAlgorithm string `json:"cavvAlgorithm,omitempty"`

	// The directory server error code indicating a problem with this transaction. Note - Max Length of this field is typically 3 characters.
	//
	DirectoryServerErrorCode string `json:"directoryServerErrorCode,omitempty"`

	// Directory server text and additional detail about the error for this transaction.
	//
	// Max Length: 4096
	DirectoryServerErrorDescription string `json:"directoryServerErrorDescription,omitempty"`

	// The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results.
	// For Cybersource Through Visanet Gateway:
	// The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV Verification—Directory Server Transaction ID
	//
	// Max Length: 36
	DirectoryServerTransactionID string `json:"directoryServerTransactionId,omitempty"`

	// Note This field applies only to non-U.S-issued cards.
	//
	// For enroll, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB,
	// Diners Club, and Discover transactions when the card is not enrolled. For more information, see
	// "Interpreting the Reply," page 22.
	//
	// If you are not using the CyberSource payment services, you must send this value to your payment
	// processor in the subsequent request for card authorization. This field contains one of these values:
	// - `06`: The card can be enrolled. Liability shift.
	// - `07`: The card cannot be enrolled. No liability shift.
	//
	// For validate, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB,
	// Diners Club, and Discover transactions. The field is absent when authentication fails.
	// You must send this value to your payment processor in the subsequent request for card authorization.
	// This field contains one of these values:
	// - `05`: Successful authentication
	// - `06`: Authentication attempted
	// - `07`: Failed authentication (No response from the merchant because of a problem.)
	//
	Eci string `json:"eci,omitempty"`

	// ECI value that can be returned for Visa, Mastercard, American Express, JCB, Diners Club, and Discover.
	// The field is absent when authentication fails. If your payment processor is Streamline, you must pass the
	// value of this field instead of the value of `eci` or `ucafCollectionIndicator`.
	//
	// This field can contain one of these values:
	// - `01`: Authentication attempted (Mastercard)
	// - `02`: Successful authentication (Mastercard)
	// - `05`: Successful authentication (Visa, American Express, JCB, Diners Club, and Discover)
	// - `06`: Authentication attempted (Visa, American Express, JCB, Diners Club, and Discover)
	//
	EciRaw string `json:"eciRaw,omitempty"`

	// Indicator used to differentiate Internet transactions from other types. The authentication failed if this field
	// is not returned. For Visa, if your payment processor is Streamline, Barclays, AIBMS, or FDC Germany,
	// you receive the value vbv_failure instead of internet when eci is 07.
	// The value of this field is passed automatically to the authorization service if you request the services
	// together. This field contains one of these values:
	// - `aesk`: American Express SafeKey authentication verified successfully.
	// - `aesk_attempted`: Card not enrolled in American Express SafeKey, but the attempt to authenticate was recorded.
	// - `dipb`: Discover ProtectBuy authentication verified successfully.
	// - `dipb_attempted`: Card not enrolled in Discover ProtectBuy, but the attempt to authenticate was recorded.
	// - `internet`: Authentication was not verified successfully.
	// - `js`: J/Secure authentication verified successfully.
	// - `js_attempted`: Card not enrolled in J/Secure, but the attempt to authenticate was recorded.
	// - `moto`: Mail or telephone order.
	// - `pb_attempted`: Card not enrolled in Diners Club ProtectBuy, but the attempt to authenticate was recorded.
	// - `recurring`: Recurring transaction.
	// - `spa`: Mastercard Identity Check authentication verified successfully.
	// - `spa_failure`: Mastercard Identity Check failed authentication.
	// - `vbv`: Visa Secure authentication verified successfully.
	// - `vbv_attempted`: Card not enrolled in Visa Secure, but the attempt to authenticate was recorded.
	// - `vbv_failure`: Visa Secure authentication unavailable.
	//
	Indicator string `json:"indicator,omitempty"`

	// Indicates the number of authentication cycles attempted by the cardholder and is tracked by the Issuing Banks ACS.Example: if customer gets the challenge window and enter in their one time password and hit submit then that interaction counter should just be 1.
	// When customer gets the challenge window and the bank asks if they want to have the one time password  sent to their phone or their email and they have to choose before going to the next screen to enter in their one time password then this interaction count would be 2.
	// One for the selection of how they want the one time password delivered and another with them actually entering in the one time password and hitting the submit button.
	//
	// Max Length: 2
	InteractionCounter string `json:"interactionCounter,omitempty"`

	// Raw result of the authentication check. If you are configured for Asia, Middle East, and Africa Gateway
	// Processing, you need to send the value of this field in your authorization request. This field can contain
	// one of these values:
	// - `A`: Proof of authentication attempt was generated.
	// - `N`: Customer failed or canceled authentication. Transaction denied.
	// - `U`: Authentication not completed regardless of the reason.
	// - `Y`: Customer was successfully authenticated.
	//
	ParesStatus string `json:"paresStatus,omitempty"`

	// SDK unique transaction identifier that is generated on each new transaction.
	//
	// Max Length: 36
	SdkTransactionID string `json:"sdkTransactionId,omitempty"`

	// This field contains the 3D Secure version that was used to process the transaction. For example, 1.0.2 or 2.0.0.
	//
	SpecificationVersion string `json:"specificationVersion,omitempty"`

	// Unique transaction identifier assigned by the 3DS Server to identify a single transaction.
	//
	// Max Length: 36
	ThreeDSServerTransactionID string `json:"threeDSServerTransactionId,omitempty"`

	// Web based token used to authenticate consumer with Rupay authentication provider.
	//
	// Max Length: 256
	TransactionToken string `json:"transactionToken,omitempty"`

	// AAV is a unique identifier generated by the card-issuing bank for Mastercard Identity Check
	// transactions after the customer is authenticated. The value is in base64.
	// Include the data in the card authorization request.
	//
	UcafAuthenticationData string `json:"ucafAuthenticationData,omitempty"`

	// For enroll, Returned only for Mastercard transactions. Indicates that authentication is not required because the
	// customer is not enrolled. Add the value of this field to the authorization field ucaf_collection_indicator.
	// This field can contain these values: 0, 1.
	//
	// For validate, Numeric electronic commerce indicator (ECI) returned only for Mastercard Identity Check
	// transactions. The field is absent when authentication fails. You must send this value to your payment
	// processor in the request for card authorization. This field contain one of these values:
	// - `0`: Authentication data not collected, and customer authentication was not completed.
	// - `1`: Authentication data not collected because customer authentication was not completed.
	// - `2`: Authentication data collected because customer completed authentication.
	//
	UcafCollectionIndicator string `json:"ucafCollectionIndicator,omitempty"`

	// Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.
	//
	// Possible Values:
	//
	// Y - 3DS Requestor is whitelisted by cardholder
	//
	// N - 3DS Requestor is not whitelisted by cardholder
	//
	// Max Length: 1
	WhiteListStatus string `json:"whiteListStatus,omitempty"`

	// This data element will be populated by the system setting Whitelist Status. Possible Values: 01 - 3DS/ Server/ 02 – DS/03 - ACS
	//
	// Max Length: 2
	WhiteListStatusSource string `json:"whiteListStatusSource,omitempty"`

	// Transaction identifier generated by CyberSource for successful enrollment or validation checks.
	// Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes.
	// CyberSource forwards the XID with the card authorization service to these payment processors in these cases:
	// - Barclays
	// - Streamline (when the **ecommerceIndicator**`=spa`)
	//
	Xid string `json:"xid,omitempty"`
}

// Validate validates this validate authentication results created body consumer authentication information
func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcsTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationTransactionContextID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavvAlgorithm(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerErrorDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInteractionCounter(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSdkTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThreeDSServerTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionToken(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatusSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateAcsTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.AcsTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"acsTransactionId", "body", o.AcsTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateAuthenticationTransactionContextID(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationTransactionContextID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionContextId", "body", o.AuthenticationTransactionContextID, 30); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateAuthenticationTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionId", "body", o.AuthenticationTransactionID, 26); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateCavv(formats strfmt.Registry) error {
	if swag.IsZero(o.Cavv) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"cavv", "body", o.Cavv, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateCavvAlgorithm(formats strfmt.Registry) error {
	if swag.IsZero(o.CavvAlgorithm) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"cavvAlgorithm", "body", o.CavvAlgorithm, 1); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateDirectoryServerErrorDescription(formats strfmt.Registry) error {
	if swag.IsZero(o.DirectoryServerErrorDescription) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"directoryServerErrorDescription", "body", o.DirectoryServerErrorDescription, 4096); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateDirectoryServerTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.DirectoryServerTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"directoryServerTransactionId", "body", o.DirectoryServerTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateInteractionCounter(formats strfmt.Registry) error {
	if swag.IsZero(o.InteractionCounter) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"interactionCounter", "body", o.InteractionCounter, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateSdkTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SdkTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"sdkTransactionId", "body", o.SdkTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateThreeDSServerTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.ThreeDSServerTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"threeDSServerTransactionId", "body", o.ThreeDSServerTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateTransactionToken(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionToken) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"transactionToken", "body", o.TransactionToken, 256); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateWhiteListStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.WhiteListStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatus", "body", o.WhiteListStatus, 1); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) validateWhiteListStatusSource(formats strfmt.Registry) error {
	if swag.IsZero(o.WhiteListStatusSource) { // not required
		return nil
	}

	if err := validate.MaxLength("validateAuthenticationResultsCreated"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatusSource", "body", o.WhiteListStatusSource, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results created body consumer authentication information based on context it is used
func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBodyErrorInformation validate authentication results created body error information
swagger:model ValidateAuthenticationResultsCreatedBodyErrorInformation
*/
type ValidateAuthenticationResultsCreatedBodyErrorInformation struct {

	// details
	Details []*ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status. Possible values are:
	// - `INVALID_MERCHANT_CONFIGURATION`
	// - `CONSUMER_AUTHENTICATION_REQUIRED`
	// - `CONSUMER_AUTHENTICATION_FAILED`
	// - `AUTHENTICATION_FAILED`
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this validate authentication results created body error information
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this validate authentication results created body error information based on the context it is used
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {

			if swag.IsZero(o.Details[i]) { // not required
				return nil
			}

			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0 validate authentication results created body error information details items0
swagger:model ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0
*/
type ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this validate authentication results created body error information details items0
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate authentication results created body error information details items0 based on context it is used
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBodyLinks validate authentication results created body links
swagger:model ValidateAuthenticationResultsCreatedBodyLinks
*/
type ValidateAuthenticationResultsCreatedBodyLinks struct {

	// self
	Self *ValidateAuthenticationResultsCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this validate authentication results created body links
func (o *ValidateAuthenticationResultsCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate authentication results created body links based on the context it is used
func (o *ValidateAuthenticationResultsCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {

		if swag.IsZero(o.Self) { // not required
			return nil
		}

		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateAuthenticationResultsCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateAuthenticationResultsCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsCreatedBodyLinksSelf validate authentication results created body links self
swagger:model ValidateAuthenticationResultsCreatedBodyLinksSelf
*/
type ValidateAuthenticationResultsCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this validate authentication results created body links self
func (o *ValidateAuthenticationResultsCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate authentication results created body links self based on context it is used
func (o *ValidateAuthenticationResultsCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyClientReferenceInformation validate authentication results params body client reference information
swagger:model ValidateAuthenticationResultsParamsBodyClientReferenceInformation
*/
type ValidateAuthenticationResultsParamsBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Required: true
	// Max Length: 50
	Code *string `json:"code"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call.
	//
	// Max Length: 26
	PausedRequestID string `json:"pausedRequestId,omitempty"`
}

// Validate validates this validate authentication results params body client reference information
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePausedRequestID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("validateRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code); err != nil {
		return err
	}

	if err := validate.MaxLength("validateRequest"+"."+"clientReferenceInformation"+"."+"code", "body", *o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"clientReferenceInformation"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) validatePausedRequestID(formats strfmt.Registry) error {
	if swag.IsZero(o.PausedRequestID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"clientReferenceInformation"+"."+"pausedRequestId", "body", o.PausedRequestID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this validate authentication results params body client reference information based on the context it is used
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {

		if swag.IsZero(o.Partner) { // not required
			return nil
		}

		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner validate authentication results params body client reference information partner
swagger:model ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner
*/
type ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this validate authentication results params body client reference information partner
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body client reference information partner based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation validate authentication results params body consumer authentication information
swagger:model ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation
*/
type ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation struct {

	// Authentication transaction context is used as a unique identifier to link enroll and validate call.
	//
	// Max Length: 256
	AuthenticationTransactionContext string `json:"authenticationTransactionContext,omitempty"`

	// Payer authentication transaction identifier passed to link the check enrollment
	// and validate authentication messages.For Rupay,this is passed only in Re-Send OTP usecase.
	// **Note**: Required for Standard integration, Rupay Seamless server to server integration for enroll service.
	// Required for Hybrid integration for validate service.
	//
	// Max Length: 26
	AuthenticationTransactionID string `json:"authenticationTransactionId,omitempty"`

	// Indicates the type of authentication that will be used to challenge the card holder.
	//
	// Possible Values:
	//
	// 01 - Static
	//
	// 02 - Dynamic
	//
	// 03 - OOB (Out of Band)
	//
	// 04 - Decoupled
	//
	// 20 - OTP hosted at merchant end. (Rupay S2S flow)
	// **NOTE**:  EMV 3-D Secure version 2.1.0 supports values 01-03.  Version 2.2.0 supports values 01-04.  Decoupled authentication is not supported at this time.
	//
	// Max Length: 2
	AuthenticationType string `json:"authenticationType,omitempty"`

	// A flag to indicate if the passed credential has been encrypted by the Merchant.
	// Max Length: 10
	CredentialEncrypted string `json:"credentialEncrypted,omitempty"`

	// This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows;
	// CH - Challenge
	// FR - Frictionless
	// FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer).
	//
	// Max Length: 2
	EffectiveAuthenticationType string `json:"effectiveAuthenticationType,omitempty"`

	// OTP entered by the card holder.
	//
	// Max Length: 255
	OtpToken string `json:"otpToken,omitempty"`

	// JWT returned by the 3D Secure provider when the authentication is complete. Required for Hybrid integration if you use the Cybersource-generated access token. Note: Max. length of this field is 2048 characters.
	//
	ResponseAccessToken string `json:"responseAccessToken,omitempty"`

	// Payer authentication result (PARes) message returned by the card-issuing bank.
	// If you need to show proof of enrollment checking, you may need to
	// decrypt and parse the string for the information required by the payment card company.
	// For more information, see "Storing Payer Authentication Data," page 160.
	// Important The value is in base64. You must remove all carriage returns and line feeds before
	// adding the PARes to the request.
	//
	SignedPares string `json:"signedPares,omitempty"`

	// Provides additional information as to why the PAResStatus has a specific value.
	//
	// Max Length: 2
	SignedParesStatusReason string `json:"signedParesStatusReason,omitempty"`

	// Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.
	//
	// Possible Values:
	//
	// Y - 3DS Requestor is whitelisted by cardholder
	//
	// N - 3DS Requestor is not whitelisted by cardholder
	//
	// Max Length: 1
	WhiteListStatus string `json:"whiteListStatus,omitempty"`
}

// Validate validates this validate authentication results params body consumer authentication information
func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthenticationTransactionContext(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCredentialEncrypted(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEffectiveAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOtpToken(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSignedParesStatusReason(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateAuthenticationTransactionContext(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationTransactionContext) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionContext", "body", o.AuthenticationTransactionContext, 256); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateAuthenticationTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionId", "body", o.AuthenticationTransactionID, 26); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationType", "body", o.AuthenticationType, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateCredentialEncrypted(formats strfmt.Registry) error {
	if swag.IsZero(o.CredentialEncrypted) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"credentialEncrypted", "body", o.CredentialEncrypted, 10); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateEffectiveAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(o.EffectiveAuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"effectiveAuthenticationType", "body", o.EffectiveAuthenticationType, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateOtpToken(formats strfmt.Registry) error {
	if swag.IsZero(o.OtpToken) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"otpToken", "body", o.OtpToken, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateSignedParesStatusReason(formats strfmt.Registry) error {
	if swag.IsZero(o.SignedParesStatusReason) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"signedParesStatusReason", "body", o.SignedParesStatusReason, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) validateWhiteListStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.WhiteListStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatus", "body", o.WhiteListStatus, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body consumer authentication information based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyDeviceInformation validate authentication results params body device information
swagger:model ValidateAuthenticationResultsParamsBodyDeviceInformation
*/
type ValidateAuthenticationResultsParamsBodyDeviceInformation struct {

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 45
	IPAddress string `json:"ipAddress,omitempty"`
}

// Validate validates this validate authentication results params body device information
func (o *ValidateAuthenticationResultsParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", o.IPAddress, 45); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body device information based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyDeviceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyOrderInformation validate authentication results params body order information
swagger:model ValidateAuthenticationResultsParamsBodyOrderInformation
*/
type ValidateAuthenticationResultsParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`
}

// Validate validates this validate authentication results params body order information
func (o *ValidateAuthenticationResultsParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate authentication results params body order information based on the context it is used
func (o *ValidateAuthenticationResultsParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {

		if swag.IsZero(o.AmountDetails) { // not required
			return nil
		}

		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails Contains `currency` and `totalAmount` for this order.
swagger:model ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails
*/
type ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this validate authentication results params body order information amount details
func (o *ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body order information amount details based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyPaymentInformation validate authentication results params body payment information
swagger:model ValidateAuthenticationResultsParamsBodyPaymentInformation
*/
type ValidateAuthenticationResultsParamsBodyPaymentInformation struct {

	// card
	Card *ValidateAuthenticationResultsParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// fluid data
	FluidData *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData `json:"fluidData,omitempty"`

	// tokenized card
	TokenizedCard *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this validate authentication results params body payment information
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFluidData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) validateFluidData(formats strfmt.Registry) error {
	if swag.IsZero(o.FluidData) { // not required
		return nil
	}

	if o.FluidData != nil {
		if err := o.FluidData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate authentication results params body payment information based on the context it is used
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFluidData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {

		if swag.IsZero(o.Card) { // not required
			return nil
		}

		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {

		if swag.IsZero(o.Customer) { // not required
			return nil
		}

		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) contextValidateFluidData(ctx context.Context, formats strfmt.Registry) error {

	if o.FluidData != nil {

		if swag.IsZero(o.FluidData) { // not required
			return nil
		}

		if err := o.FluidData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {

		if swag.IsZero(o.TokenizedCard) { // not required
			return nil
		}

		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyPaymentInformationCard validate authentication results params body payment information card
swagger:model ValidateAuthenticationResultsParamsBodyPaymentInformationCard
*/
type ValidateAuthenticationResultsParamsBodyPaymentInformationCard struct {

	// description: The BIN is the first six digits of the card's Primary Account Number (PAN).
	//
	// Max Length: 6
	Bin string `json:"bin,omitempty"`

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customer's payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// #### FDMS Nashville
	// Required. String (19)
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	// - '070': EFTPOS
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this validate authentication results params body payment information card
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) validateBin(formats strfmt.Registry) error {
	if swag.IsZero(o.Bin) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"card"+"."+"bin", "body", o.Bin, 6); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body payment information card based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer validate authentication results params body payment information customer
swagger:model ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer
*/
type ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumer's card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	CustomerID string `json:"customerId,omitempty"`

	// Unique identifier for the Customer token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this validate authentication results params body payment information customer
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("validateRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body payment information customer based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData validate authentication results params body payment information fluid data
swagger:model ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData
*/
type ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData struct {

	// The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values:
	// Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ=
	// Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.
	//
	// Card Present processing:
	// Format of the encrypted payment data.
	// The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`.
	// The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field.
	// If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==`
	// If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504`
	//
	// Max Length: 128
	Descriptor string `json:"descriptor,omitempty"`

	// Encoding method used to encrypt the payment data.
	// Valid values: `Base64`, `HEX`
	// If no value is provided, `Base64` is taken as the default value. And the `Base64` descriptor is used for paymentInformation.fluidData.encoding
	//
	// Max Length: 6
	Encoding string `json:"encoding,omitempty"`

	// The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html)
	//
	KeySerialNumber string `json:"keySerialNumber,omitempty"`

	// Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method.
	// Card Present processing
	// This field represents the encrypted payment data generated by the payment terminal/device.
	//
	// Max Length: 4000
	Value string `json:"value,omitempty"`
}

// Validate validates this validate authentication results params body payment information fluid data
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoding(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData) validateDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.Descriptor) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"descriptor", "body", o.Descriptor, 128); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData) validateEncoding(formats strfmt.Registry) error {
	if swag.IsZero(o.Encoding) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"encoding", "body", o.Encoding, 6); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", o.Value, 4000); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body payment information fluid data based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyPaymentInformationFluidData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard validate authentication results params body payment information tokenized card
swagger:model ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard
*/
type ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard struct {

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Customer's payment network token value.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that
	// provided you with information about the token.
	//
	// Possible value:
	// - `2`: Near-field communication (NFC) transaction. The customer's mobile device provided the token data for a contactless EMV transaction. For recurring
	// transactions, use this value if the original transaction was a contactless EMV transaction.
	//
	// #### Visa Platform Connect
	// - `1`: For Rupay and In App tokenization. Example: InApp apple pay.
	// - `3`: Card/Credential On File Tokenization.
	//
	// **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// #### Rupay
	// - `3`: Card/Credential On File Tokenization.
	// - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	// - '070': EFTPOS
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this validate authentication results params body payment information tokenized card
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body payment information tokenized card based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyProcessingInformation validate authentication results params body processing information
swagger:model ValidateAuthenticationResultsParamsBodyProcessingInformation
*/
type ValidateAuthenticationResultsParamsBodyProcessingInformation struct {

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//  - `013`: Cybersource P2PE Decryption
	//  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `027`: Click to Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`
}

// Validate validates this validate authentication results params body processing information
func (o *ValidateAuthenticationResultsParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", o.PaymentSolution, 12); err != nil {
		return err
	}

	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {
	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", o.VisaCheckoutID, 48); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body processing information based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
ValidateAuthenticationResultsParamsBodyTokenInformation validate authentication results params body token information
swagger:model ValidateAuthenticationResultsParamsBodyTokenInformation
*/
type ValidateAuthenticationResultsParamsBodyTokenInformation struct {

	// TMS Transient Token, 64 hexadecimal id value representing captured payment credentials (including Sensitive Authentication Data, e.g. CVV).
	//
	// Max Length: 64
	Jti string `json:"jti,omitempty"`
}

// Validate validates this validate authentication results params body token information
func (o *ValidateAuthenticationResultsParamsBodyTokenInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateJti(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateAuthenticationResultsParamsBodyTokenInformation) validateJti(formats strfmt.Registry) error {
	if swag.IsZero(o.Jti) { // not required
		return nil
	}

	if err := validate.MaxLength("validateRequest"+"."+"tokenInformation"+"."+"jti", "body", o.Jti, 64); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate authentication results params body token information based on context it is used
func (o *ValidateAuthenticationResultsParamsBodyTokenInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyTokenInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateAuthenticationResultsParamsBodyTokenInformation) UnmarshalBinary(b []byte) error {
	var res ValidateAuthenticationResultsParamsBodyTokenInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
