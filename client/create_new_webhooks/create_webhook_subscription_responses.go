// Code generated by go-swagger; DO NOT EDIT.

package create_new_webhooks

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"fmt"
	"io"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CreateWebhookSubscriptionReader is a Reader for the CreateWebhookSubscription structure.
type CreateWebhookSubscriptionReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreateWebhookSubscriptionReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCreateWebhookSubscriptionCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreateWebhookSubscriptionBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewCreateWebhookSubscriptionUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewCreateWebhookSubscriptionInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("[POST /notification-subscriptions/v1/webhooks] createWebhookSubscription", response, response.Code())
	}
}

// NewCreateWebhookSubscriptionCreated creates a CreateWebhookSubscriptionCreated with default headers values
func NewCreateWebhookSubscriptionCreated() *CreateWebhookSubscriptionCreated {
	return &CreateWebhookSubscriptionCreated{}
}

/*
CreateWebhookSubscriptionCreated describes a response with status code 201, with default header values.

Created
*/
type CreateWebhookSubscriptionCreated struct {
	Payload *CreateWebhookSubscriptionCreatedBody
}

// IsSuccess returns true when this create webhook subscription created response has a 2xx status code
func (o *CreateWebhookSubscriptionCreated) IsSuccess() bool {
	return true
}

// IsRedirect returns true when this create webhook subscription created response has a 3xx status code
func (o *CreateWebhookSubscriptionCreated) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create webhook subscription created response has a 4xx status code
func (o *CreateWebhookSubscriptionCreated) IsClientError() bool {
	return false
}

// IsServerError returns true when this create webhook subscription created response has a 5xx status code
func (o *CreateWebhookSubscriptionCreated) IsServerError() bool {
	return false
}

// IsCode returns true when this create webhook subscription created response a status code equal to that given
func (o *CreateWebhookSubscriptionCreated) IsCode(code int) bool {
	return code == 201
}

// Code gets the status code for the create webhook subscription created response
func (o *CreateWebhookSubscriptionCreated) Code() int {
	return 201
}

func (o *CreateWebhookSubscriptionCreated) Error() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionCreated %s", 201, payload)
}

func (o *CreateWebhookSubscriptionCreated) String() string {
	payload, _ := json.Marshal(o.Payload)
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionCreated %s", 201, payload)
}

func (o *CreateWebhookSubscriptionCreated) GetPayload() *CreateWebhookSubscriptionCreatedBody {
	return o.Payload
}

func (o *CreateWebhookSubscriptionCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateWebhookSubscriptionCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateWebhookSubscriptionBadRequest creates a CreateWebhookSubscriptionBadRequest with default headers values
func NewCreateWebhookSubscriptionBadRequest() *CreateWebhookSubscriptionBadRequest {
	return &CreateWebhookSubscriptionBadRequest{}
}

/*
CreateWebhookSubscriptionBadRequest describes a response with status code 400, with default header values.

Bad Request
*/
type CreateWebhookSubscriptionBadRequest struct {
}

// IsSuccess returns true when this create webhook subscription bad request response has a 2xx status code
func (o *CreateWebhookSubscriptionBadRequest) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create webhook subscription bad request response has a 3xx status code
func (o *CreateWebhookSubscriptionBadRequest) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create webhook subscription bad request response has a 4xx status code
func (o *CreateWebhookSubscriptionBadRequest) IsClientError() bool {
	return true
}

// IsServerError returns true when this create webhook subscription bad request response has a 5xx status code
func (o *CreateWebhookSubscriptionBadRequest) IsServerError() bool {
	return false
}

// IsCode returns true when this create webhook subscription bad request response a status code equal to that given
func (o *CreateWebhookSubscriptionBadRequest) IsCode(code int) bool {
	return code == 400
}

// Code gets the status code for the create webhook subscription bad request response
func (o *CreateWebhookSubscriptionBadRequest) Code() int {
	return 400
}

func (o *CreateWebhookSubscriptionBadRequest) Error() string {
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionBadRequest", 400)
}

func (o *CreateWebhookSubscriptionBadRequest) String() string {
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionBadRequest", 400)
}

func (o *CreateWebhookSubscriptionBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewCreateWebhookSubscriptionUnauthorized creates a CreateWebhookSubscriptionUnauthorized with default headers values
func NewCreateWebhookSubscriptionUnauthorized() *CreateWebhookSubscriptionUnauthorized {
	return &CreateWebhookSubscriptionUnauthorized{}
}

/*
CreateWebhookSubscriptionUnauthorized describes a response with status code 401, with default header values.

Unauthorized
*/
type CreateWebhookSubscriptionUnauthorized struct {
}

// IsSuccess returns true when this create webhook subscription unauthorized response has a 2xx status code
func (o *CreateWebhookSubscriptionUnauthorized) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create webhook subscription unauthorized response has a 3xx status code
func (o *CreateWebhookSubscriptionUnauthorized) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create webhook subscription unauthorized response has a 4xx status code
func (o *CreateWebhookSubscriptionUnauthorized) IsClientError() bool {
	return true
}

// IsServerError returns true when this create webhook subscription unauthorized response has a 5xx status code
func (o *CreateWebhookSubscriptionUnauthorized) IsServerError() bool {
	return false
}

// IsCode returns true when this create webhook subscription unauthorized response a status code equal to that given
func (o *CreateWebhookSubscriptionUnauthorized) IsCode(code int) bool {
	return code == 401
}

// Code gets the status code for the create webhook subscription unauthorized response
func (o *CreateWebhookSubscriptionUnauthorized) Code() int {
	return 401
}

func (o *CreateWebhookSubscriptionUnauthorized) Error() string {
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionUnauthorized", 401)
}

func (o *CreateWebhookSubscriptionUnauthorized) String() string {
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionUnauthorized", 401)
}

func (o *CreateWebhookSubscriptionUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewCreateWebhookSubscriptionInternalServerError creates a CreateWebhookSubscriptionInternalServerError with default headers values
func NewCreateWebhookSubscriptionInternalServerError() *CreateWebhookSubscriptionInternalServerError {
	return &CreateWebhookSubscriptionInternalServerError{}
}

/*
CreateWebhookSubscriptionInternalServerError describes a response with status code 500, with default header values.

Server error
*/
type CreateWebhookSubscriptionInternalServerError struct {
}

// IsSuccess returns true when this create webhook subscription internal server error response has a 2xx status code
func (o *CreateWebhookSubscriptionInternalServerError) IsSuccess() bool {
	return false
}

// IsRedirect returns true when this create webhook subscription internal server error response has a 3xx status code
func (o *CreateWebhookSubscriptionInternalServerError) IsRedirect() bool {
	return false
}

// IsClientError returns true when this create webhook subscription internal server error response has a 4xx status code
func (o *CreateWebhookSubscriptionInternalServerError) IsClientError() bool {
	return false
}

// IsServerError returns true when this create webhook subscription internal server error response has a 5xx status code
func (o *CreateWebhookSubscriptionInternalServerError) IsServerError() bool {
	return true
}

// IsCode returns true when this create webhook subscription internal server error response a status code equal to that given
func (o *CreateWebhookSubscriptionInternalServerError) IsCode(code int) bool {
	return code == 500
}

// Code gets the status code for the create webhook subscription internal server error response
func (o *CreateWebhookSubscriptionInternalServerError) Code() int {
	return 500
}

func (o *CreateWebhookSubscriptionInternalServerError) Error() string {
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionInternalServerError", 500)
}

func (o *CreateWebhookSubscriptionInternalServerError) String() string {
	return fmt.Sprintf("[POST /notification-subscriptions/v1/webhooks][%d] createWebhookSubscriptionInternalServerError", 500)
}

func (o *CreateWebhookSubscriptionInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	return nil
}

/*
CreateWebhookSubscriptionBody create webhook subscription body
swagger:model CreateWebhookSubscriptionBody
*/
type CreateWebhookSubscriptionBody struct {

	// Client friendly webhook description.
	Description string `json:"description,omitempty"`

	// Array of the different events for a given product id.
	EventTypes []string `json:"eventTypes"`

	// The client's health check endpoint (URL). This should be as close as possible to the actual webhookUrl. If the user does not provide the health check URL, it is the user's responsibility to re-activate the webhook if it is deactivated by calling the test endpoint.
	//
	HealthCheckURL string `json:"healthCheckUrl,omitempty"`

	// Client friendly webhook name.
	Name string `json:"name,omitempty"`

	// The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. 3. CUSTOM The Webhook is used to deliver webhooks for the OrgIds (or MiDs) explicitly listed in scopeData field.
	//
	NotificationScope string `json:"notificationScope,omitempty"`

	// Organization Identifier (OrgId) or Merchant Identifier (MID).
	OrganizationID string `json:"organizationId,omitempty"`

	// To see the valid productId and eventTypes, call the "Create and Manage Webhooks - Retrieve a list of event types" endpoint.
	ProductID string `json:"productId,omitempty"`

	// retry policy
	RetryPolicy *CreateWebhookSubscriptionParamsBodyRetryPolicy `json:"retryPolicy,omitempty"`

	// security policy
	SecurityPolicy *CreateWebhookSubscriptionParamsBodySecurityPolicy `json:"securityPolicy,omitempty"`

	// The client's endpoint (URL) to receive webhooks.
	WebhookURL string `json:"webhookUrl,omitempty"`
}

// Validate validates this create webhook subscription body
func (o *CreateWebhookSubscriptionBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRetryPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionBody) validateRetryPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.RetryPolicy) { // not required
		return nil
	}

	if o.RetryPolicy != nil {
		if err := o.RetryPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *CreateWebhookSubscriptionBody) validateSecurityPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityPolicy) { // not required
		return nil
	}

	if o.SecurityPolicy != nil {
		if err := o.SecurityPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create webhook subscription body based on the context it is used
func (o *CreateWebhookSubscriptionBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRetryPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSecurityPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionBody) contextValidateRetryPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.RetryPolicy != nil {

		if swag.IsZero(o.RetryPolicy) { // not required
			return nil
		}

		if err := o.RetryPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *CreateWebhookSubscriptionBody) contextValidateSecurityPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.SecurityPolicy != nil {

		if swag.IsZero(o.SecurityPolicy) { // not required
			return nil
		}

		if err := o.SecurityPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionBody) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionCreatedBody create webhook subscription created body
// Example: {"additionalAttributes":[],"createdOn":"2021-02-25T23:25:11.000Z","description":null,"eventTypes":["payments.payments.accept","payments.payments.reject","payments.refunds.accept"],"healthCheckUrl":"https://example.com:443/cybs/healthcheck","name":"Billing Update Webhook","notificationScope":"SELF","organizationId":"\u003cINSERT ORGANIZATION ID HERE\u003e","productId":"payments","retryPolicy":null,"securityPolicy":{"config":{"keyId":"IdFromSecureUSAPI2LookupClientIdAndClientSecret","oAuthTokenExpiry":300,"oAuthTokenType":"Bearer","oAuthUrl":"https://acquirers.authorization-server.com/token"},"securityType":"oAuth"},"status":"INACTIVE","updatedOn":null,"webhookId":"b555a545-58a9-47c7-aef9-10a8e17f201a","webhookUrl":"https://example.com:443/cybs"}
swagger:model CreateWebhookSubscriptionCreatedBody
*/
type CreateWebhookSubscriptionCreatedBody struct {

	// Additional, free form configuration data.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// Date on which webhook was created/registered.
	CreatedOn string `json:"createdOn,omitempty"`

	// Client friendly webhook description.
	Description string `json:"description,omitempty"`

	// Array of the different events for a given product id.
	EventTypes []string `json:"eventTypes"`

	// The client's health check endpoint (URL). This should be as close as possible to the actual webhookUrl.
	HealthCheckURL string `json:"healthCheckUrl,omitempty"`

	// Client friendly webhook name.
	Name string `json:"name,omitempty"`

	// notification scope
	NotificationScope *CreateWebhookSubscriptionCreatedBodyNotificationScope `json:"notificationScope,omitempty"`

	// Organization ID
	OrganizationID string `json:"organizationId,omitempty"`

	// The product you are receiving a webhook for.
	ProductID string `json:"productId,omitempty"`

	// retry policy
	RetryPolicy *CreateWebhookSubscriptionCreatedBodyRetryPolicy `json:"retryPolicy,omitempty"`

	// security policy
	SecurityPolicy *CreateWebhookSubscriptionCreatedBodySecurityPolicy `json:"securityPolicy,omitempty"`

	// Webhook status.
	Status *string `json:"status,omitempty"`

	// Date on which webhook was most recently updated.
	UpdatedOn string `json:"updatedOn,omitempty"`

	// Webhook Id. This is generated by the server.
	WebhookID string `json:"webhookId,omitempty"`

	// The client's endpoint (URL) to receive webhooks.
	WebhookURL string `json:"webhookUrl,omitempty"`
}

// Validate validates this create webhook subscription created body
func (o *CreateWebhookSubscriptionCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNotificationScope(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRetryPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityPolicy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionCreatedBody) validateNotificationScope(formats strfmt.Registry) error {
	if swag.IsZero(o.NotificationScope) { // not required
		return nil
	}

	if o.NotificationScope != nil {
		if err := o.NotificationScope.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *CreateWebhookSubscriptionCreatedBody) validateRetryPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.RetryPolicy) { // not required
		return nil
	}

	if o.RetryPolicy != nil {
		if err := o.RetryPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *CreateWebhookSubscriptionCreatedBody) validateSecurityPolicy(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityPolicy) { // not required
		return nil
	}

	if o.SecurityPolicy != nil {
		if err := o.SecurityPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create webhook subscription created body based on the context it is used
func (o *CreateWebhookSubscriptionCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateNotificationScope(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRetryPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSecurityPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionCreatedBody) contextValidateNotificationScope(ctx context.Context, formats strfmt.Registry) error {

	if o.NotificationScope != nil {

		if swag.IsZero(o.NotificationScope) { // not required
			return nil
		}

		if err := o.NotificationScope.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "notificationScope")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "notificationScope")
			}
			return err
		}
	}

	return nil
}

func (o *CreateWebhookSubscriptionCreatedBody) contextValidateRetryPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.RetryPolicy != nil {

		if swag.IsZero(o.RetryPolicy) { // not required
			return nil
		}

		if err := o.RetryPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "retryPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "retryPolicy")
			}
			return err
		}
	}

	return nil
}

func (o *CreateWebhookSubscriptionCreatedBody) contextValidateSecurityPolicy(ctx context.Context, formats strfmt.Registry) error {

	if o.SecurityPolicy != nil {

		if swag.IsZero(o.SecurityPolicy) { // not required
			return nil
		}

		if err := o.SecurityPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBody) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionCreatedBodyNotificationScope create webhook subscription created body notification scope
swagger:model CreateWebhookSubscriptionCreatedBodyNotificationScope
*/
type CreateWebhookSubscriptionCreatedBodyNotificationScope struct {

	// The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. 3. CUSTOM The Webhook is used to deliver webhooks for the OrgIds (or MiDs) explicitly listed in scopeData field
	Scope *string `json:"scope,omitempty"`

	// Applicable only if scope=CUSTOM. This should contains a Set of MIDs or OrgIDs for which this subscription is applicable.
	ScopeData []string `json:"scopeData"`
}

// Validate validates this create webhook subscription created body notification scope
func (o *CreateWebhookSubscriptionCreatedBodyNotificationScope) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create webhook subscription created body notification scope based on context it is used
func (o *CreateWebhookSubscriptionCreatedBodyNotificationScope) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodyNotificationScope) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodyNotificationScope) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionCreatedBodyNotificationScope
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionCreatedBodyRetryPolicy Retry policy for the individual webhooks that are a part of your subscription. If a message fails to deliver, it will execute through this retry policy.
//
// Automatic suspend and resume:
//
// If you experience downtime and have `deactivateFlag = true` any new messages will be held in a "SUSPENDED" status.
// When your healthCheckUrl returns healthy again, the subscription will automatically be re-enabled and your messages will be sent.
// We will ping your healthCheckUrl routinely using a POST call with an empty payload to check availability.
// If your endpoint returns an unhealthy status of != 200, we will check the healthCheckUrl at a more frequent rate until it is healthy again.
//
// If you experience downtime and have `deactivateFlag = false` and your message exhausts all retry attempts the message will go to a "FAILED" status.
// Support will be notified and will reach out to suggest you execute the "REPLAY" endpoint at a later date when your server is healthy.
//
//
// Reference the below values for formulas and calculations related to the frequency of retries depending on algorithm and configuration.
//
swagger:model CreateWebhookSubscriptionCreatedBodyRetryPolicy
*/
type CreateWebhookSubscriptionCreatedBodyRetryPolicy struct {

	// Additional data, if any.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// This is used to calculate the Retry Sequence.
	//
	// Sample calculations using firstRetry=10, interval=30, maxNumberOfRetries=3
	// Arithmetic = a+r(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10+30x1 = 40 minutes
	// Retry 3 - 10+30x2 = 70 minutes
	//
	// Geometric = ar^(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10x30^1 = 300 minutes
	// Retry 3 - 10x30^2 = 9,000 minutes
	//
	Algorithm string `json:"algorithm,omitempty"`

	// Deactivate the subscription if your retries fail to deliver.
	//
	// If this is set to `true`, the automatic suspend and resume feature will occur.
	// This would prevent new webhooks from attempting to deliver and to queue up until your healthCheckUrl returns 200 again, then all messages will be sent.
	//
	// If this is set to `false`, new individual messages will continue to retry and exhaust all failures, but the subscription will stay active.
	//
	DeactivateFlag string `json:"deactivateFlag,omitempty"`

	// When to initiate first retry, after the initial call failed. (in mins).
	FirstRetry int64 `json:"firstRetry,omitempty"`

	// The interval between retries (in mins).
	Interval int64 `json:"interval,omitempty"`

	// The number of retries per sequence.
	NumberOfRetries int64 `json:"numberOfRetries,omitempty"`

	// The number of times to repeat the complete retry sequence.
	// 0 => don't repeat the retry sequence
	// 1 => repeat the retry sequence once (R1, R2, R3)+ (R1, R2, R3)
	// 2 => repeat the retry sequence twice (R1, R2, R3) + (R1, R2, R3) + (R1, R2, R3)
	//
	RepeatSequenceCount int64 `json:"repeatSequenceCount,omitempty"`

	// The time to wait to before repeating the complete retry sequence.
	// Amount of time to wait between each sequence.
	// Sample calculation using repeatSequenceWaitTime=10
	// (R1, R2, R3) + (10) + (R1, R2, R3) + (10) + (R1, R2, R3)
	//
	RepeatSequenceWaitTime int64 `json:"repeatSequenceWaitTime,omitempty"`
}

// Validate validates this create webhook subscription created body retry policy
func (o *CreateWebhookSubscriptionCreatedBodyRetryPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create webhook subscription created body retry policy based on context it is used
func (o *CreateWebhookSubscriptionCreatedBodyRetryPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodyRetryPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodyRetryPolicy) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionCreatedBodyRetryPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionCreatedBodySecurityPolicy The security option to authenticate with your API or client server.
swagger:model CreateWebhookSubscriptionCreatedBodySecurityPolicy
*/
type CreateWebhookSubscriptionCreatedBodySecurityPolicy struct {

	// config
	Config *CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig `json:"config,omitempty"`

	// Security Policy of the client server.
	SecurityType string `json:"securityType,omitempty"`
}

// Validate validates this create webhook subscription created body security policy
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicy) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.Config) { // not required
		return nil
	}

	if o.Config != nil {
		if err := o.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create webhook subscription created body security policy based on the context it is used
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicy) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.Config != nil {

		if swag.IsZero(o.Config) { // not required
			return nil
		}

		if err := o.Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookSubscriptionCreated" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicy) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionCreatedBodySecurityPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig Optional configuration object for if your API or server requires oAuth for an incoming webhook.
swagger:model CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig
*/
type CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig struct {

	// Token expiration for the oAuth server.
	OAuthTokenExpiry string `json:"oAuthTokenExpiry,omitempty"`

	// Token type for the oAuth config.
	OAuthTokenType string `json:"oAuthTokenType,omitempty"`

	// Client direct endpoint to the oAuth server.
	OAuthURL string `json:"oAuthURL,omitempty"`
}

// Validate validates this create webhook subscription created body security policy config
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create webhook subscription created body security policy config based on context it is used
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionCreatedBodySecurityPolicyConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionParamsBodyRetryPolicy Retry policy for the individual webhooks that are a part of your subscription. If a message fails to deliver, it will execute through this retry policy.
//
// Automatic suspend and resume:
//
// If you experience downtime and have `deactivateFlag = true` any new messages will be held in a "SUSPENDED" status.
// When your healthCheckUrl returns healthy again, the subscription will automatically be re-enabled and your messages will be sent.
// We will ping your healthCheckUrl routinely using a POST call with an empty payload to check availability.
// If your endpoint returns an unhealthy status of != 200, we will check the healthCheckUrl at a more frequent rate until it is healthy again.
//
// If you experience downtime and have `deactivateFlag = false` and your message exhausts all retry attempts the message will go to a "FAILED" status.
// Support will be notified and will reach out to suggest you execute the "REPLAY" endpoint at a later date when your server is healthy.
//
//
// Reference the below values for formulas and calculations related to the frequency of retries depending on algorithm and configuration.
//
swagger:model CreateWebhookSubscriptionParamsBodyRetryPolicy
*/
type CreateWebhookSubscriptionParamsBodyRetryPolicy struct {

	// Additional data, if any.
	AdditionalAttributes []map[string]string `json:"additionalAttributes"`

	// This is used to calculate the Retry Sequence.
	//
	// Sample calculations using firstRetry=10, interval=30, maxNumberOfRetries=3
	// Arithmetic = a+r(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10+30x1 = 40 minutes
	// Retry 3 - 10+30x2 = 70 minutes
	//
	// Geometric = ar^(n-1)
	// Retry 1 - 10 minutes
	// Retry 2 - 10x30^1 = 300 minutes
	// Retry 3 - 10x30^2 = 9,000 minutes
	//
	Algorithm string `json:"algorithm,omitempty"`

	// Deactivate the subscription if your retries fail to deliver.
	//
	// If this is set to `true`, the automatic suspend and resume feature will occur.
	// This would prevent new webhooks from attempting to deliver and to queue up until your healthCheckUrl returns 200 again, then all messages will be sent.
	//
	// If this is set to `false`, new individual messages will continue to retry and exhaust all failures, but the subscription will stay active.
	//
	DeactivateFlag string `json:"deactivateFlag,omitempty"`

	// When to initiate first retry, after the initial call failed. (in mins).
	FirstRetry int64 `json:"firstRetry,omitempty"`

	// The interval between retries (in mins).
	Interval int64 `json:"interval,omitempty"`

	// The number of retries per sequence.
	NumberOfRetries int64 `json:"numberOfRetries,omitempty"`

	// The number of times to repeat the complete retry sequence.
	// 0 => don't repeat the retry sequence
	// 1 => repeat the retry sequence once (R1, R2, R3)+ (R1, R2, R3)
	// 2 => repeat the retry sequence twice (R1, R2, R3) + (R1, R2, R3) + (R1, R2, R3)
	//
	RepeatSequenceCount int64 `json:"repeatSequenceCount,omitempty"`

	// The time to wait to before repeating the complete retry sequence.
	// Amount of time to wait between each sequence.
	// Sample calculation using repeatSequenceWaitTime=10
	// (R1, R2, R3) + (10) + (R1, R2, R3) + (10) + (R1, R2, R3)
	//
	RepeatSequenceWaitTime int64 `json:"repeatSequenceWaitTime,omitempty"`
}

// Validate validates this create webhook subscription params body retry policy
func (o *CreateWebhookSubscriptionParamsBodyRetryPolicy) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create webhook subscription params body retry policy based on context it is used
func (o *CreateWebhookSubscriptionParamsBodyRetryPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodyRetryPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodyRetryPolicy) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionParamsBodyRetryPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionParamsBodySecurityPolicy The security option to authenticate with your API or client server.
swagger:model CreateWebhookSubscriptionParamsBodySecurityPolicy
*/
type CreateWebhookSubscriptionParamsBodySecurityPolicy struct {

	// config
	Config *CreateWebhookSubscriptionParamsBodySecurityPolicyConfig `json:"config,omitempty"`

	// Internal client proxy type to be used by security policy.
	ProxyType string `json:"proxyType,omitempty"`

	// Security Policy of the client server.
	SecurityType string `json:"securityType,omitempty"`
}

// Validate validates this create webhook subscription params body security policy
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionParamsBodySecurityPolicy) validateConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.Config) { // not required
		return nil
	}

	if o.Config != nil {
		if err := o.Config.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create webhook subscription params body security policy based on the context it is used
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionParamsBodySecurityPolicy) contextValidateConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.Config != nil {

		if swag.IsZero(o.Config) { // not required
			return nil
		}

		if err := o.Config.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicy) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionParamsBodySecurityPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionParamsBodySecurityPolicyConfig Optional configuration object for if your API or server requires oAuth for an incoming webhook.
swagger:model CreateWebhookSubscriptionParamsBodySecurityPolicyConfig
*/
type CreateWebhookSubscriptionParamsBodySecurityPolicyConfig struct {

	// additional config
	AdditionalConfig *CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig `json:"additionalConfig,omitempty"`

	// Token expiration for the oAuth server.
	OAuthTokenExpiry string `json:"oAuthTokenExpiry,omitempty"`

	// Token type for the oAuth config.
	OAuthTokenType string `json:"oAuthTokenType,omitempty"`

	// Client direct endpoint to the oAuth server.
	OAuthURL string `json:"oAuthURL,omitempty"`
}

// Validate validates this create webhook subscription params body security policy config
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalConfig(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfig) validateAdditionalConfig(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalConfig) { // not required
		return nil
	}

	if o.AdditionalConfig != nil {
		if err := o.AdditionalConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config" + "." + "additionalConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config" + "." + "additionalConfig")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create webhook subscription params body security policy config based on the context it is used
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAdditionalConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfig) contextValidateAdditionalConfig(ctx context.Context, formats strfmt.Registry) error {

	if o.AdditionalConfig != nil {

		if swag.IsZero(o.AdditionalConfig) { // not required
			return nil
		}

		if err := o.AdditionalConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config" + "." + "additionalConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createWebhookRequest" + "." + "securityPolicy" + "." + "config" + "." + "additionalConfig")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfig) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionParamsBodySecurityPolicyConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*
CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig Additional, free form configuration data.
swagger:model CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig
*/
type CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig struct {

	// aud
	Aud string `json:"aud,omitempty"`

	// client id
	ClientID string `json:"client_id,omitempty"`

	// key Id
	KeyID string `json:"keyId,omitempty"`

	// scope
	Scope string `json:"scope,omitempty"`
}

// Validate validates this create webhook subscription params body security policy config additional config
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create webhook subscription params body security policy config additional config based on context it is used
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig) UnmarshalBinary(b []byte) error {
	var res CreateWebhookSubscriptionParamsBodySecurityPolicyConfigAdditionalConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
